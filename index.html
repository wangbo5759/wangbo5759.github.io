<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Muse--D.D">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Muse--D.D">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Muse--D.D">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Muse--D.D</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Muse--D.D</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/sp安全使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/sp安全使用/" itemprop="url">SharedPreference线程、进程安全性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SharedPreference的线程、进程安全性"><a href="#SharedPreference的线程、进程安全性" class="headerlink" title="SharedPreference的线程、进程安全性"></a>SharedPreference的线程、进程安全性</h2><h3 id="一、安全性结论"><a href="#一、安全性结论" class="headerlink" title="一、安全性结论"></a>一、安全性结论</h3><p>官方文档如是说：</p>
<blockquote>
<p>Note: This class provides strong consistency guarantees. It is using expensive operations which might slow down an app. Frequently changing properties or properties where loss can be tolerated should use other mechanisms. For more details read the comments on <code>SharedPreferences.Editor.commit()</code> and <code>SharedPreferences.Editor.apply()</code>.</p>
<p><em>Note: This class does not support use across multiple processes.</em></p>
</blockquote>
<p><strong>线程安全、进程不安全</strong></p>
<h3 id="二、使用注意"><a href="#二、使用注意" class="headerlink" title="二、使用注意"></a>二、使用注意</h3><ul>
<li><p>第一次getSharedPreferences有ANR风险，sp中数据大时。</p>
<p>第一次getSharedPreferences，如果从disk未加载完毕，则getSharedPreferences方法会阻塞，直到加载完毕后返回。</p>
<p>sp中存储的key和value不应过大和过多，除了以上ANR风险外，内存也会高（全部内存缓存）</p>
</li>
<li><p>apply方法内存同步，disk异步，返回值void，commit方法内存同步，disk同步，返回值boolean（是否更新成功）</p>
</li>
<li><p>从 Android N 开始, 不再支持 MODE_WORLD_READABLE &amp; MODE_WORLD_WRITEABLE. 一旦指定, 会抛异常</p>
</li>
<li><p>不要sp用于多进程，进程不安全。</p>
</li>
</ul>
<h3 id="三、SP原理分析"><a href="#三、SP原理分析" class="headerlink" title="三、SP原理分析"></a>三、SP原理分析</h3><h4 id="1、SharedPreferences的初始化"><a href="#1、SharedPreferences的初始化" class="headerlink" title="1、SharedPreferences的初始化"></a>1、SharedPreferences的初始化</h4><p>首先，从基本使用简单看下SharedPreferences的实现原理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mSharedPreferences = context.getSharedPreferences(&quot;test&quot;, Context.MODE_PRIVATE);</div><div class="line">SharedPreferences.Editor editor = mSharedPreferences.edit();</div><div class="line">editor.putString(key, value);</div><div class="line">editor.apply();</div></pre></td></tr></table></figure>
<p>ContextImpl.java （sdk-26）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">        // At least one application in the world actually passes in a null</div><div class="line">        // name.  This happened to work because when we generated the file name</div><div class="line">        // we would stringify it to &quot;null.xml&quot;.  Nice.</div><div class="line">        if (mPackageInfo.getApplicationInfo().targetSdkVersion &lt;</div><div class="line">                Build.VERSION_CODES.KITKAT) &#123;</div><div class="line">            if (name == null) &#123;</div><div class="line">                name = &quot;null&quot;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        File file;</div><div class="line">        synchronized (ContextImpl.class) &#123;</div><div class="line">            if (mSharedPrefsPaths == null) &#123;</div><div class="line">                mSharedPrefsPaths = new ArrayMap&lt;&gt;();</div><div class="line">            &#125;</div><div class="line">            file = mSharedPrefsPaths.get(name);</div><div class="line">            if (file == null) &#123;</div><div class="line">                file = getSharedPreferencesPath(name);</div><div class="line">                mSharedPrefsPaths.put(name, file);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return getSharedPreferences(file, mode);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>context全局单例中，mSharedPrefsPaths变量map，一个name对应一个xml文件，内部存储空间内。(data/data/packageName/shared_prefs下)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">public SharedPreferences getSharedPreferences(File file, int mode) &#123;</div><div class="line">        checkMode(mode);</div><div class="line">      //真实的实现类：SharedPreferencesImpl，其对象缓存在cache对象中</div><div class="line">      //从getSharedPreferencesCacheLocked()看出</div><div class="line">      //SharedPreferencesImpl与packageName一一对应</div><div class="line">      SharedPreferencesImpl sp;</div><div class="line">      synchronized (ContextImpl.class) &#123;</div><div class="line">          final ArrayMap&lt;File, SharedPreferencesImpl&gt; cache = getSharedPreferencesCacheLocked();</div><div class="line">          sp = cache.get(file);</div><div class="line">          if (sp == null) &#123;</div><div class="line">            //实际SharedPreferencesImpl的初始化开始</div><div class="line">              sp = new SharedPreferencesImpl(file, mode);</div><div class="line">              cache.put(file, sp);</div><div class="line">              return sp;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      //mode == Context.MODE_MULTI_PROCESS时，</div><div class="line">      //从Disk读取数据保存到map中(如果有changed的话)</div><div class="line">      if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">          getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">          sp.startReloadIfChangedUnexpectedly();</div><div class="line">      &#125;</div><div class="line">      return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><p>0 SharedPreferences只是接口，SharedPreferencesImpl才是实现，其实现的对象在contextImpl中map缓存起来。</p>
<p>1 SharedPreferencesImpl并非每次创建，而是从cache中获取，并且和packageName一一对应。SharedPreferencesImpl倾向于优先利用缓存。</p>
<p>2 在getSharedPreferences过程中，对于MODE_MULTI_PROCESS则重新读取disk同步到内存中，否则一切用内存中的cache（缓存）。</p>
<h4 id="2、SharedPreferences数据加载、获取的并发"><a href="#2、SharedPreferences数据加载、获取的并发" class="headerlink" title="2、SharedPreferences数据加载、获取的并发"></a>2、SharedPreferences数据加载、获取的并发</h4><p>在getSharedPreferences方法中，sp从cache中取出==null时，sp = new SharedPreferencesImpl()是初始化的真正开始。</p>
<pre><code>SharedPreferencesImpl(File file, int mode) {
    mFile = file;
    mBackupFile = makeBackupFile(file);
    mMode = mode;
    mLoaded = false;
    mMap = null;
    startLoadFromDisk();
}

private void startLoadFromDisk() {
    synchronized (mLock) {
    //mLoaded标志位设置为false
        mLoaded = false;
    }
    new Thread(&quot;SharedPreferencesImpl-load&quot;) {
        public void run() {
            loadFromDisk();
        }
    }.start();
}

private void loadFromDisk() {

    ···
    Map map = null;
    StructStat stat = null;
    try {
        stat = Os.stat(mFile.getPath());
        if (mFile.canRead()) {
            BufferedInputStream str = null;
            try {
                str = new BufferedInputStream(
                        new FileInputStream(mFile), 16*1024);
                //XmlUtils读取xml到map内存中
                map = XmlUtils.readMapXml(str);
            } ···
        }
    } catch (ErrnoException e) {
        /* ignore */
    }

    //mLock同步锁整体加载过程，加载完成后notifyAll
    synchronized (mLock) {
      //标志位mLoaded重置为true，加载完毕。
        mLoaded = true;
        if (map != null) {
        //mMap中缓存了xml中的数据
            mMap = map;
            mStatTimestamp = stat.st_mtime;
            mStatSize = stat.st_size;
        } else {
                mMap = new HashMap&lt;&gt;();
        }
        mLock.notifyAll();
    }
}

备注：
上文提到getSharedPreferences方法中的sp.startReloadIfChangedUnexpectedly()实际也是直接调用了      loadFromDisk()方法，重新读取xml中的数据。
</code></pre><p>除了mLoaded标志位以外，mLock （Object对象）是个同步对象，保证了并发安全。</p>
<p>如果加载的同时又get请求，会如何，以getLong为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public long getLong(String key, long defValue) &#123;</div><div class="line">		//mLock同步</div><div class="line">        synchronized (mLock) &#123;</div><div class="line">            awaitLoadedLocked();</div><div class="line">            Long v = (Long)mMap.get(key);</div><div class="line">            return v != null ? v : defValue;</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果在加载过程中，getLong会一直等待，直到加载结束。这个mLock是不分xml文件的，只要有一个xml在加载，那么同步锁就在生效。</p>
<p>同时可以看到getLong方法完全是从mMap缓存对象中读取，和disk无关。其他的get方法类似。</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>每次都从xml文件中读取数据，会造成很大的并发问题。为保证线程安全，这也是SharedPreferences中尽量减少文件读取过程，数据保存和读取都在mMap内存的原因。</p>
<h4 id="3、SharedPreferences数据更新的并发"><a href="#3、SharedPreferences数据更新的并发" class="headerlink" title="3、SharedPreferences数据更新的并发"></a>3、SharedPreferences数据更新的并发</h4><p>为了增强并发性，SharedPreferences数据的更新采用事务管理的机制。Editor相当于事务管理器。在SharedPreferences中获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public Editor edit() &#123;</div><div class="line">	//全局同步锁mLock，所以更新的过程，会等待xml加载过程</div><div class="line">    synchronized (mLock) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">    &#125;</div><div class="line">    //每次new 新的EditorImpl对象</div><div class="line">    return new EditorImpl();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>EditorImpl</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">  public final class EditorImpl implements Editor &#123;</div><div class="line">      private final Object mLock = new Object();</div><div class="line"></div><div class="line">//mModified变量将所有要更新的事务缓存起来，一起提交</div><div class="line">      @GuardedBy(&quot;mLock&quot;)</div><div class="line">      private final Map&lt;String, Object&gt; mModified = Maps.newHashMap();</div><div class="line"></div><div class="line">      public Editor putString(String key, @Nullable String value) &#123;</div><div class="line">          synchronized (mLock) &#123;</div><div class="line">              mModified.put(key, value);</div><div class="line">              return this;</div><div class="line">          &#125;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<pre><code>}        
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">EditorImpl对象通过apply（异步）commit（同步）两种方法提交事务到SharePreferences；我们来看下两者的区别：</div><div class="line"></div><div class="line">**Apply方法：**</div></pre></td></tr></table></figure>
<pre><code>public void apply() {
    //更新到内存,返回要更新的内容mcr
    final MemoryCommitResult mcr = commitToMemory();
    //异步任务更新disk
    final Runnable awaitCommit = new Runnable() {
            public void run() {
                try {
                    mcr.writtenToDiskLatch.await();
                } catch (InterruptedException ignored) {
                }
            }
        };

    QueuedWork.addFinisher(awaitCommit);

    Runnable postWriteRunnable = new Runnable() {
            public void run() {
                awaitCommit.run();
                QueuedWork.removeFinisher(awaitCommit);
            }
        };

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, postWriteRunnable);

    notifyListeners(mcr);
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**commit方法：**</div></pre></td></tr></table></figure>
<pre><code>public boolean commit() {
    //更新到内存,返回要更新的内容mcr
      MemoryCommitResult mcr = commitToMemory();

    SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);
    try {
        mcr.writtenToDiskLatch.await();
    } catch (InterruptedException e) {
        return false;
    } 
    notifyListeners(mcr);
    return mcr.writeToDiskResult;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">apply和commit两个方法中，都分为两步，先保存到内存commitToMemory（），</div><div class="line"></div><div class="line">然后储存到disk： SharedPreferencesImpl.this.enqueueDiskWrite</div><div class="line"></div><div class="line">由于commitToMemory是相同的，我们简单看一下：</div></pre></td></tr></table></figure>
<p>// Returns true if any changes were made<br>        private MemoryCommitResult commitToMemory() {<br>            <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//全局锁SharedPreferencesImpl.this.mLock同步</div><div class="line">         synchronized (SharedPreferencesImpl.this.mLock) &#123;</div><div class="line">             synchronized (mLock) &#123;</div><div class="line">                 boolean changesMade = false;</div><div class="line"></div><div class="line">                 for (Map.Entry&lt;String, Object&gt; e : mModified.entrySet()) &#123;</div><div class="line">                     String k = e.getKey();</div><div class="line">                     Object v = e.getValue();</div><div class="line"></div><div class="line">                     if (v == this || v == null) &#123;</div><div class="line">                         if (!mMap.containsKey(k)) &#123;</div><div class="line">                             continue;</div><div class="line">                         &#125;</div><div class="line">                         mMap.remove(k);</div><div class="line">                     &#125; else &#123;</div><div class="line">                         if (mMap.containsKey(k)) &#123;</div><div class="line">                             Object existingValue = mMap.get(k);</div><div class="line">                             //与mMap中每个字段对比，不相等的(待更新的)更新到mMap中</div><div class="line">                             //最终使得mMap变为最新的</div><div class="line">                             if (existingValue != null &amp;&amp; existingValue.equals(v)) &#123;</div><div class="line">                                 continue;</div><div class="line">                             &#125;</div><div class="line">                         &#125;</div><div class="line">                         mMap.put(k, v);</div><div class="line">                     &#125;</div><div class="line"></div><div class="line">                 &#125;</div><div class="line">                 </div><div class="line">		···</div><div class="line">		</div><div class="line">                 mModified.clear();</div><div class="line"></div><div class="line">             &#125;</div><div class="line">         &#125;</div><div class="line">         return new MemoryCommitResult(memoryStateGeneration, keysModified, listeners,</div><div class="line">                 mapToWriteToDisk);</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>SharedPreferencesImpl.this.enqueueDiskWrite方法apply和commit的调用方法不同，不同点在于apply是：</p>
<p><code>SharedPreferencesImpl.this.enqueueDiskWrite</code></p>
<p> 而commit是<code>SharedPreferencesImpl.this.enqueueDiskWrite(mcr, null);</code></p>
<p>那么enqueueDiskWrite方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">  private void enqueueDiskWrite(final MemoryCommitResult mcr,</div><div class="line">                                final Runnable postWriteRunnable) &#123;</div><div class="line">      //字段isFromSyncCommit判断是来自apply还是commit</div><div class="line">      final boolean isFromSyncCommit = (postWriteRunnable == null);</div><div class="line"></div><div class="line">//真正写入disk的异步方法</div><div class="line">      final Runnable writeToDiskRunnable = new Runnable() &#123;</div><div class="line">              public void run() &#123;</div><div class="line">                  synchronized (mWritingToDiskLock) &#123;</div><div class="line">                      writeToFile(mcr, isFromSyncCommit);</div><div class="line">                  &#125;</div><div class="line">                  synchronized (mLock) &#123;</div><div class="line">                      mDiskWritesInFlight--;</div><div class="line">                  &#125;</div><div class="line">                  if (postWriteRunnable != null) &#123;</div><div class="line">                      postWriteRunnable.run();</div><div class="line">                  &#125;</div><div class="line">              &#125;</div><div class="line">          &#125;;</div><div class="line"></div><div class="line">//如果是commit，则在主线程执行writeToDiskRunnable，写入disk并直接return</div><div class="line">      if (isFromSyncCommit) &#123;</div><div class="line">          boolean wasEmpty = false;</div><div class="line">          synchronized (mLock) &#123;</div><div class="line">              wasEmpty = mDiskWritesInFlight == 1;</div><div class="line">          &#125;</div><div class="line">          if (wasEmpty) &#123;</div><div class="line">              writeToDiskRunnable.run();</div><div class="line">              return;</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">//如果是apply，则异步执行writeToDiskRunnable</div><div class="line">      QueuedWork.queue(writeToDiskRunnable, !isFromSyncCommit);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p><strong>总结:</strong></p>
<p>sharedPreferences数据的提交是基于事务的，最终通过apply或commit方法，两个方法都是先同步更新内存（全局mLock锁保证线程安全），然后更新disk，apply在子线程中异步更新disk，commit在主线程中更新disk。</p>
<h4 id="4、SharedPreferences的多进程"><a href="#4、SharedPreferences的多进程" class="headerlink" title="4、SharedPreferences的多进程"></a>4、SharedPreferences的多进程</h4><ul>
<li><strong>是否进程安全？</strong></li>
</ul>
<p>进程安全，类比线程安全，指的是不同的进程同时处理一个字段（此处应该是文件），是否有类似lock的机制，保证同步，如果没有那么就是进程不安全的。</p>
<p>因为进程的隔离性，两个进程不能互相访问对方内存，进程安全主要是针对xml文件而言。从上述的原理分析来看，并没有任何机制保证xml文件，在读和写过程中的同步性。</p>
<ul>
<li><strong>多进程同步数据的可能性</strong></li>
</ul>
<p>进程不安全，所以官方也不建议利用SharedPreferences来同步进程间的数据。</p>
<p>而且一般情况下，在进程A中更新的sp数据，在进程B中取，是未更新的状态。</p>
<p>考虑两种情况，</p>
<p>情况一、在进程A中更新sp数据，然后开启进程B，从sp中取数据，那么数据是更新过的。</p>
<p>情况二、进程A、B均已开启，在进程A中更新sp数据，然后切换到进程B，从sp中取数据，数据是未更新过的。</p>
<p><strong>如何解释？</strong></p>
<p>我们知道，SharedPreferences中大多数数据是缓存在内存中的，get方法都是从内存中直接获取。</p>
<p><img src="https://i.imgur.com/Dp1KcRA.png" alt=""></p>
<p>如图所示，进程A通过put方法写入disk后，如果进程B不重新load，是无法同步更新的。</p>
<p><code>startLoadFromDisk()</code>两个地方会调用，一个是SharePreferenceImpl的构造方法，一个是getSharedPreferences方法中mode == Context.MODE_MULTI_PROCESS；</p>
<p>所以对应到应用场景中，</p>
<ol>
<li><p>新进程启动时访问sp是会走SharePreferenceImpl的构造方法，重新读取disk。</p>
</li>
<li><p>如果在已存在的进程中，必须通过context.getSharedPreferences方法传入multi-process的mode，也可以重新读取disk的数据。</p>
</li>
</ol>
<p><strong>总结</strong></p>
<p>sp中进程不安全，不建议使用sp进行进程间通讯，Context.MODE_MULTI_PROCESS虽然可用，但是官方会逐步deprecated，而且多进程调用的同步性无法保证。</p>
<p>那么数据的进程间共享方案，就是另一个话题了。我会专门开一个专题来说明。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/阿里Android规约/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/阿里Android规约/" itemprop="url">阿里Android开发规约及分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-25T00:00:00+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h3><p>本手册以开发者为视角分为 Java语言规范（遵循《阿里巴巴 Java开发手册》），Android 资源文件命名与使用，Android 基本组件，UI 与布局，进程、线程与消息通信，文件与数据库，Bitmap、 Drawable 与动画，安全，其他等九大部分，根据约束力强弱，规约依次分为【强制】、【推荐】、【参考】三大类：</p>
<p>【强制】 必须遵守，违反本约定或将会引起严重的后果；</p>
<p>【推荐】 尽量遵守，长期遵守有助于系统稳定性和合作效率的提升；</p>
<p>【参考】 充分理解，技术意识的引导，是个人学习、团队沟通、项目合作的方向。</p>
<h3 id="二、内容"><a href="#二、内容" class="headerlink" title="二、内容"></a>二、内容</h3><h1 id="一、Java语言规范"><a href="#一、Java语言规范" class="headerlink" title="一、Java语言规范"></a>一、Java语言规范</h1><p>遵循《阿里巴巴 Java 开发手册》，如果有需要可以关注分享达人秀公众号回复“Java开发手册”获取最新纪念版下载链接。</p>
<h1 id="二、Android资源文件命名与使用"><a href="#二、Android资源文件命名与使用" class="headerlink" title="二、Android资源文件命名与使用"></a>二、Android资源文件命名与使用</h1><p>1.【推荐】资源文件需带模块前缀。</p>
<p>2.【推荐】layout 文件的命名方式。</p>
<blockquote>
<p>​    Activity 的 layout 以 module_activity 开头</p>
<p>​    Fragment 的 layout 以 module_fragment 开头</p>
<p>​    Dialog 的 layout 以 module_dialog 开头</p>
<p>​    include 的 layout 以 module_include 开头</p>
<p>​    ListView 的行 layout 以 module_list_item 开头</p>
<p>​    RecyclerView 的 item layout 以 module_recycle_item 开头</p>
<p>​    GridView 的行 layout 以 module_grid_item 开头</p>
</blockquote>
<p>3.【推荐】drawable 资源名称以小写单词+下划线的方式命名，根据分辨率不同存放在不同的 drawable 目录下，建议只使用一套，例如 drawable-xhdpi。采用规则如下:</p>
<blockquote>
<p>模块名<em>业务功能描述</em>控件描述_控件状态限定词</p>
</blockquote>
<p>​    如：module_login_btn_pressed,module_tabs_icon_home_normal</p>
<p>4.【推荐】anim 资源名称以小写单词+下划线的方式命名，采用以下规则：</p>
<blockquote>
<p>模块名<em>逻辑名称</em>[方向|序号]</p>
</blockquote>
<p>tween 动 画 资 源 ： 尽 可 能 以 通 用 的 动 画 名 称 命 名 ， 如：module_fade_in ,module_fade_out , module_push_down_in (动画+方向)；</p>
<p>frame 动画资源：尽可能以模 块+功能命名+序号。如：module_loading_grey_001</p>
<p>5.【推荐】color 资源使用#AARRGGBB 格式，写入 module_colors.xml 文件中，命名格式采用以下规则：</p>
<blockquote>
<p>模块名<em>逻辑名称</em>颜色</p>
</blockquote>
<p>​    如：#33b5e5e5</p>
<p>6.【推荐】dimen 资源以小写单词+下划线方式命名，写入 module_dimens.xml 文件中，采用以下规则：</p>
<blockquote>
<p>模块名_描述信息</p>
</blockquote>
<p>​    如：1dp</p>
<p>7.【推荐】style 资源采用小写单词+下划线方式命名，写入 module_styles.xml 文件中，采用以下规则：</p>
<blockquote>
<p>父 style 名称.当前 style 名称</p>
</blockquote>
<p>8.【推荐】string资源文件或者文本用到字符需要全部写入 module_strings.xml文件中，字符串以小写单词+下划线的方式命名，采用以下规则：</p>
<blockquote>
<p> 模块名_逻辑名称</p>
</blockquote>
<p>​    如：moudule_login_tips,module_homepage_notice_desc</p>
<p>9.【推荐】Id 资源原则上以驼峰法命名，View 组件的资源 id 需要以 View 的缩写作为前缀。常用缩写表如下：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/4706202-ed072c3a8d95cb22?imageMogr2/auto-orient/strip%7CimageView2/2/w/631/format/webp" alt="img"></p>
<p>​    其它控件的缩写推荐使用小写字母并用下划线进行分割，例如：</p>
<p>ProgressBar 对应的缩写为 progress_bar</p>
<p>DatePicker 对应的缩写为 date_picker</p>
<p>10.【推荐】大分辨率图片（单维度超过 1000）大分辨率图片建议统一放在 xxhdpi 目录下管理，否则将导致占用内存成倍数增加。</p>
<p>​    说明：</p>
<p>​    为了支持多种屏幕尺寸和密度， Android 为多种屏幕提供不同的资源目录进行适配。为不同屏幕密度提供不同的位图可绘制对象，可用于密度特定资源的配置限定符（在</p>
<p>下面详述） 包括 ldpi（低）、 mdpi（中）、 hdpi（高）、 xhdpi（超高）、 xxhdpi （超超高）和 xxxhdpi（超超超高）。例如，高密度屏幕的位图应使用 drawable-hdpi/。</p>
<p>​    根据当前的设备屏幕尺寸和密度，将会寻找最匹配的资源，如果将高分辨率图片放入低密度目录，将会造成低端机加载过大图片资源，又可能造成 OOM，同时也是资源浪费，没有必要在低端机使用大图。</p>
<h1 id="三、Android基本组件"><a href="#三、Android基本组件" class="headerlink" title="三、Android基本组件"></a>三、Android基本组件</h1><p>Android 基本组件指 Activity、 Fragment、 Service、 BroadcastReceiver、ContentProvider 等等。</p>
<p>1.【强制】Activity 间的数据通信，对于数据量比较大的，避免使用 Intent + Parcelable的方式，可以考虑 EventBus 等替代方案，以免造成 TransactionTooLargeException。</p>
<p>2.【推荐】Activity#onSaveInstanceState()方法不是 Activity 生命周期方法，也不保证一定会被调用。它是用来在 Activity 被意外销毁时保存 UI 状态的，只能用于保存临时性数据，例如 UI 控件的属性等，不能跟数据的持久化存储混为一谈。持久化存储应该在 Activity#onPause()/onStop()中实行。</p>
<p>3.【强制】Activity 间通过隐式 Intent 的跳转，在发出 Intent 之前必须通过 resolveActivity检查，避免找不到合适的调用组件，造成 ActivityNotFoundException 的异常。</p>
<p>4.【强制】避免在 Service#onStartCommand()/onBind()方法中执行耗时操作，如果确实有需求，应改用 IntentService 或采用其他异步机制完成。</p>
<p>5.【强制】避免在 BroadcastReceiver#onReceive()中执行耗时操作，如果有耗时工作，应该创建 IntentService 完成，而不应该在 BroadcastReceiver 内创建子线程去做。</p>
<p>​    说明：</p>
<p>​    由于该方法是在主线程执行，如果执行耗时操作会导致 UI 不流畅。可以使用IntentService 、 创 建 HandlerThread 或 者 调 用 Context#registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)方法等方式，在其他 Wroker 线程执行 onReceive 方法。BroadcastReceiver#onReceive()方法耗时超过 10 秒钟，可能会被系统杀死。</p>
<p>6.【强制】避免使用隐式 Intent 广播敏感信息，信息可能被其他注册了对应BroadcastReceiver 的 App 接收。</p>
<p>​    说明：</p>
<p>​    通过 Context#sendBroadcast()发送的隐式广播会被所有感兴趣的 receiver 接收，恶意应用注册监听该广播的 receiver 可能会获取到 Intent 中传递的敏感信息，并进行其他危险操作。如果发送的广播为使用 Context#sendOrderedBroadcast()方法发送的有序广播，优先级较高的恶意 receiver 可能直接丢弃该广播，造成服务不可用，或者向广播结果塞入恶意数据。</p>
<p>​    如果广播仅限于应用内，则可以使用 LocalBroadcastManager#sendBroadcast()实现，避免敏感信息外泄和 Intent 拦截的风险。</p>
<p>7.【推荐】添 加 Fragment 时 ， 确 保 FragmentTransaction#commit() 在Activity#onPostResume()或者 FragmentActivity#onResumeFragments()内调用。不要随意使用 FragmentTransaction#commitAllowingStateLoss()来代替，任何commitAllowingStateLoss()的使用必须经过 code review，确保无负面影响。</p>
<p>​    说明：</p>
<p>​    Activity 可 能 因 为 各 种 原 因 被 销 毁 ， Android 支 持 页 面 被 销 毁 前 通 过Activity#onSaveInstanceState() 保 存 自 己 的 状 态 。 但 如 果FragmentTransaction.commit()发生在 Activity 状态保存之后，就会导致 Activity 重建、恢复状态时无法还原页面状态，从而可能出错。为了避免给用户造成不好的体验，系统会抛出 IllegalStateExceptionStateLoss 异常。推荐的做法是在 Activity 的onPostResume() 或 onResumeFragments() （ 对 FragmentActivity ） 里 执 行FragmentTransaction.commit()，如有必要也可在 onCreate()里执行。不要随意改用FragmentTransaction.commitAllowingStateLoss() 或 者 直 接 使 用 try-catch 避 免crash，这不是问题的根本解决之道，当且仅当你确认 Activity 重建、恢复状态时，本次 commit 丢失不会造成影响时才可这么做。</p>
<p>8.【推荐】不要在 Activity#onDestroy()内执行释放资源的工作，例如一些工作线程的销毁和停止，因为 onDestroy()执行的时机可能较晚。可根据实际需要，在Activity#onPause()/onStop()中结合 isFinishing()的判断来执行。</p>
<p>9.【推荐】如非必须，避免使用嵌套的 Fragment。</p>
<p>​    说明：</p>
<p>​    嵌套 Fragment 是在 Android API 17 添加到 SDK 以及 Support 库中的功能，Fragment 嵌套使用会有一些坑，容易出现 bug，比较常见的问题有如下几种：</p>
<p>​    1) onActivityResult()方法的处理错乱，内嵌的 Fragment 可能收不到该方法的回调，需要由宿主 Fragment 进行转发处理；</p>
<p>​    2) 突变动画效果；</p>
<p>​    3) 被继承的 setRetainInstance()，导致在 Fragment 重建时多次触发不必要的逻辑。</p>
<p>​    非必须的场景尽可能避免使用嵌套 Fragment，如需使用请注意上述问题。</p>
<p>10.【推荐】总是使用显式 Intent 启动或者绑定 Service，且不要为服务声明 Intent Filter，保证应用的安全性。如果确实需要使用隐式调用，则可为 Service 提供 Intent Filter并从 Intent 中排除相应的组件名称，但必须搭配使用 Intent#setPackage()方法设置Intent 的指定包名，这样可以充分消除目标服务的不确定性。</p>
<p>11.【推荐】Service 需要以多线程来并发处理多个启动请求，建议使用 IntentService，可避免各种复杂的设置。</p>
<p>​    说明：</p>
<p>​    Service 组件一般运行主线程，应当避免耗时操作，如果有耗时操作应该在 Worker线程执行。 可以使用 IntentService 执行后台任务。</p>
<p>12.【推荐】对于只用于应用内的广播，优先使用 LocalBroadcastManager 来进行注册和发送，LocalBroadcastManager 安全性更好，同时拥有更高的运行效率。</p>
<p>​    说明：</p>
<p>​    对于使用 Context#sendBroadcast()等方法发送全局广播的代码进行提示。如果该广播仅用于应用内，则可以使用 LocalBroadcastManager 来避免广播泄漏以及广播被拦截等安全问题，同时相对全局广播本地广播的更高效。</p>
<p>13.【推荐】当前 Activity的 onPause方法执行结束后才会执行下一个 Activity的 onCreate方法，所以在 onPause 方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率。</p>
<p>14.【强制】不要在 Android 的 Application 对象中缓存数据。基础组件之间的数据共享请使用 Intent 等机制，也可使用 SharedPreferences 等数据持久化机制。</p>
<p>15.【推荐】使用 Toast 时，建议定义一个全局的 Toast 对象，这样可以避免连续显示Toast 时不能取消上一次 Toast 消息的情况(如果你有连续弹出 Toast 的情况，避免使用 Toast.makeText)。</p>
<p>16.【强制】使用 Adapter 的时候，如果你使用了 ViewHolder 做缓存，在 getView()的方法中无论这项 convertView 的每个子控件是否需要设置属性(比如某个 TextView设置的文本可能为 null，某个按钮的背景色为透明，某控件的颜色为透明等)，都需要为其显式设置属性(Textview 的文本为空也需要设置 setText(“”)，背景透明也需要设置)，否则在滑动的过程中，因为 adapter item 复用的原因，会出现内容的显示错乱。</p>
<p>17.【强制】Activity或者 Fragment 中动态注册 BroadCastReceiver 时， registerReceiver()和 unregisterReceiver()要成对出现。</p>
<p>​    说明：</p>
<p>​    如果 registerReceiver()和 unregisterReceiver()不成对出现，则可能导致已经注册的receiver 没有在合适的时机注销，导致内存泄漏，占用内存空间，加重 SystemService负担。</p>
<p>​    部分华为的机型会对 receiver 进行资源管控，单个应用注册过多 receiver 会触发管控模块抛出异常，应用直接崩溃。</p>
<p>​    Activity 的生命周期不对应，可能出现多次 onResume 造成 receiver 注册多个，但最终只注销一个，其余 receiver 产生内存泄漏。</p>
<h1 id="四、UI与布局"><a href="#四、UI与布局" class="headerlink" title="四、UI与布局"></a>四、UI与布局</h1><p>1.【强制】布局中不得不使用 ViewGroup 多重嵌套时，不要使用 LinearLayout 嵌套，改用 RelativeLayout，可以有效降低嵌套数。</p>
<p>​    说明：</p>
<p>​    Android 应用页面上任何一个 View 都需要经过 measure、 layout、 draw 三个步骤才能被正确的渲染。从 xml layout 的顶部节点开始进行 measure，每个子节点都需要向自己的父节点提供自己的尺寸来决定展示的位置，在此过程中可能还会重新measure（由此可能导致 measure 的时间消耗为原来的 2-3 倍）。节点所处位置越深，套嵌带来的 measure 越多，计算就会越费时。这就是为什么扁平的 View 结构会性能更好。</p>
<p>​    同时，页面拥上的 View 越多，measure、 layout、 draw 所花费的时间就越久。要缩短这个时间，关键是保持 View 的树形结构尽量扁平，而且要移除所有不需要渲染的View。理想情况下，总共的 measure，layout，draw 时间应该被很好的控制在 16ms以内，以保证滑动屏幕时 UI 的流畅。</p>
<p>​    要找到那些多余的 View（增加渲染延迟的 view），可以用 Android Studio Monitor里的 Hierarachy Viewer 工具，可视化的查看所有的 view。</p>
<p>2.【推荐】在 Activity 中显示对话框或弹出浮层时，尽量使用 DialogFragment，而非Dialog/AlertDialog，这样便于随Activity生命周期管理对话框/弹出浮层的生命周期。</p>
<p>3.【推荐】源文件统一采用 UTF-8 的形式进行编码。</p>
<p>4.【强制】禁止在非 ui 线程进行 view 相关操作。</p>
<p>5.【推荐】文本大小使用单位 dp，view 大小使用单位 dp。对于 Textview，如果在文字大小确定的情况下推荐使用 wrap_content 布局避免出现文字显示不全的适配问题。</p>
<p>6.【强制】禁止在设计布局时多次设置子 view 和父 view 中为同样的背景造成页面过度绘制，推荐将不需要显示的布局进行及时隐藏。</p>
<p>7.【推荐】灵活使用布局，推荐 Merge、 ViewStub 来优化布局，尽可能多的减少 UI布局层级，推荐使用 FrameLayout，LinearLayout、 RelativeLayout 次之。</p>
<p>8.【推荐】在需要时刻刷新某一区域的组件时，建议通过以下方式避免引发全局 layout刷新:</p>
<p>​    1) 设置固定的 view 大小的高宽，如倒计时组件等；</p>
<p>​    2) 调用 view 的 layout 方式修改位置，如弹幕组件等；</p>
<p>​    3) 通过修改 canvas 位置并且调用 invalidate(int l, int t, int r, int b)等方式限定刷新区域；</p>
<p>​    4) 通过设置一个是否允许 requestLayout 的变量，然后重写控件的 requestlayout、onSizeChanged 方 法 ， 判 断 控 件 的 大 小 没 有 改 变 的 情 况 下 ， 当 进 入requestLayout 的时候，直接返回而不调用 super 的 requestLayout 方法。</p>
<p>9.【推荐】不能在 Activity 没有完全显示时显示 PopupWindow 和 Dialog。</p>
<p>10.【推荐】尽量不要使用 AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错。</p>
<p>​    说明：</p>
<p>​    Android 的帧动画可以使用 AnimationDrawable 实现，但是如果你的帧动画中如果包含过多帧图片，一次性加载所有帧图片所导致的内存消耗会使低端机发生 OOM异常。帧动画所使用的图片要注意降低内存消耗，当图片比较大时，容易出现 OOM。</p>
<p>11.【强制】不能使用 ScrollView 包裹 ListView/GridView/ExpandableListVIew;因为这样会把 ListView 的所有 Item 都加载到内存中，要消耗巨大的内存和 cpu 去绘制图面。</p>
<p>​    说明：</p>
<p>​    ScrollView 中嵌套 List 或 RecyclerView 的做法官方明确禁止。除了开发过程中遇到的各种视觉和交互问题，这种做法对性能也有较大损耗。 ListView 等 UI 组件自身有垂直滚动功能，也没有必要在嵌套一层 ScrollView。目前为了较好的 UI 体验，更贴近 Material Design 的设计，推荐使用 NestedScrollView。</p>
<h1 id="五、进程、线程与消息通信"><a href="#五、进程、线程与消息通信" class="headerlink" title="五、进程、线程与消息通信"></a>五、进程、线程与消息通信</h1><p>1.【强制】不要通过 Intent 在 Android 基础组件之间传递大数据（binder transaction缓存为 1MB），可能导致 OOM。</p>
<p>2.【强制】在 Application 的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。</p>
<p>3.【强制】新建线程时，必须通过线程池提供（AsyncTask 或者 ThreadPoolExecutor或者其他形式自定义的线程池） ，不允许在应用中自行显式创建线程。</p>
<p>​    说明：</p>
<p>​    使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 另外创建匿名线程不便于后续的资源使用分析，对性能分析等会造成困扰。</p>
<p>4.【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>​    说明：</p>
<p>​    Executors 返回的线程池对象的弊端如下：</p>
<p>​    1) FixedThreadPool 和 SingleThreadPool ： 允 许 的 请 求 队 列 长 度 为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM；</p>
<p>​    2) CachedThreadPool 和 ScheduledThreadPool ： 允 许 的 创 建 线 程 数 量 为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>
<p>5.【强制】子线程中不能更新界面，更新界面必须在主线程中进行，网络操作不能在主线程中调用。</p>
<p>6.【强制】不要在非 UI 线程中初始化 ViewStub，否则会返回 null。</p>
<p>7.【推荐】尽量减少不同 APP 之间的进程间通信及拉起行为。拉起导致占用系统资源，影响用户体验。</p>
<p>8.【推荐】新建线程时，定义能识别自己业务的线程名称，便于性能优化和问题排查。</p>
<p>9.【推荐】ThreadPoolExecutor 设置线程存活时间(setKeepAliveTime)，确保空闲时线程能被释放。</p>
<p>10.【推荐】禁 止 在 多 进 程 之 间 用 SharedPreferences 共 享 数 据 ， 虽 然 可 以(MODE_MULTI_PROCESS)，但官方已不推荐。</p>
<p>11.【推荐】谨慎使用 Android 的多进程，多进程虽然能够降低主进程的内存压力，但会遇到如下问题：</p>
<p>​    1) 不能实现完全退出所有 Activity 的功能；</p>
<p>​    2) 首次进入新启动进程的页面时会有延时的现象（有可能黑屏、白屏几秒，是白屏还是黑屏和新 Activity 的主题有关） ；</p>
<p>​    3) 应用内多进程时，Application 实例化多次，需要考虑各个模块是否都需要在所有进程中初始化；</p>
<p>​    4) 多进程间通过 SharedPreferences 共享数据时不稳定。</p>
<h1 id="六、文件与数据库"><a href="#六、文件与数据库" class="headerlink" title="六、文件与数据库"></a>六、文件与数据库</h1><p>1.【强制】任何时候不要硬编码文件路径，请使用 Android 文件系统 API 访问。</p>
<p>​    说明：</p>
<p>​    Android 应用提供内部和外部存储，分别用于存放应用自身数据以及应用产生的用户数据。可以通过相关 API 接口获取对应的目录，进行文件操作。</p>
<p>2.【强制】当使用外部存储时，必须检查外部存储的可用性。</p>
<p>3.【强制】应用间共享文件时，不要通过放宽文件系统权限的方式去实现，而应使用FileProvider。</p>
<p>4.【推荐】SharedPreference 中只能存储简单数据类型（int、 boolean、 String 等），复杂数据类型建议使用文件、数据库等其他方式存储。</p>
<p>5.【推荐】SharedPreference 提 交 数 据 时 ， 尽 量 使 用 Editor#apply() ， 而 非Editor#commit()。一般来讲，仅当需要确定提交结果，并据此有后续操作时，才使用 Editor#commit()。</p>
<p>​    说明：</p>
<p>​    SharedPreference 相关修改使用 apply 方法进行提交会先写入内存，然后异步写入磁盘， commit 方法是直接写入磁盘。如果频繁操作的话 apply 的性能会优于 commit，apply 会将最后修改内容写入磁盘。但是如果希望立刻获取存储操作的结果，并据此做相应的其他操作，应当使用 commit。</p>
<p>6.【强制】数据库 Cursor 必须确保使用完后关闭，以免内存泄漏。</p>
<p>​    说明：</p>
<p>​    Cursor 是对数据库查询结果集管理的一个类，当查询的结果集较小时，消耗内存不易察觉。但是当结果集较大，长时间重复操作会导致内存消耗过大，需要开发者在操作完成后手动关闭 Cursor。</p>
<p>​    数据库 Cursor 在创建及使用时，可能发生各种异常，无论程序是否正常结束，必须在最后确保 Cursor 正确关闭，以避免内存泄漏。同时，如果 Cursor 的使用还牵涉多线程场景，那么需要自行保证操作同步。</p>
<p>7.【强制】多线程操作写入数据库时，需要使用事务，以免出现同步问题。</p>
<p>​    说明：</p>
<p>​    Android 的通过 SQLiteOpenHelper 获取数据库 SQLiteDatabase 实例， Helper 中会自动缓存已经打开的 SQLiteDatabase 实例，单个 App 中应使用 SQLiteOpenHelper的单例模式确保数据库连接唯一。由于 SQLite 自身是数据库级锁，单个数据库操作是保证线程安全的（不能同时写入），transaction 时一次原子操作，因此处于事务中的操作是线程安全的。</p>
<p>​    若同时打开多个数据库连接，并通过多线程写入数据库，会导致数据库异常，提示数据库已被锁住。</p>
<p>8.【推荐】大数据写入数据库时，请使用事务或其他能够提高 I/O 效率的机制，保证执行速度。</p>
<p>9.【强制】执行 SQL 语句时，应使用 SQLiteDatabase#insert()、 update()、 delete()，不要使用 SQLiteDatabase#execSQL()，以免 SQL 注入风险。</p>
<p>10.【强制】如果 ContentProvider 管理的数据存储在 SQL 数据库中，应该避免将不受信任的外部数据直接拼接在原始 SQL 语句中，可使用一个用于将 ? 作为可替换参数的选择子句以及一个单独的选择参数数组，会避免 SQL 注入。</p>
<h1 id="七、Bitmap、Drawable与动画"><a href="#七、Bitmap、Drawable与动画" class="headerlink" title="七、Bitmap、Drawable与动画"></a>七、Bitmap、Drawable与动画</h1><p>1.【强制】加载大图片或者一次性加载多张图片，应该在异步线程中进行。图片的加载，涉及到 IO 操作，以及 CPU 密集操作，很可能引起卡顿。</p>
<p>2.【强制】在 ListView，ViewPager，RecyclerView，GirdView 等组件中使用图片时，应做好图片的缓存，避免始终持有图片导致内存泄露，也避免重复创建图片，引起性 能 问 题 。 建 议 使 用 Fresco （ <a href="https://github.com/facebook/fresco" target="_blank" rel="external">https://github.com/facebook/fresco</a> ）、 Glide（<a href="https://github.com/bumptech/glide）等图片库。" target="_blank" rel="external">https://github.com/bumptech/glide）等图片库。</a></p>
<p>3.【强制】png 图片使用 tinypng 或者类似工具压缩处理，减少包体积。</p>
<p>4.【推荐】应根据实际展示需要，压缩图片，而不是直接显示原图。手机屏幕比较小，直接显示原图，并不会增加视觉上的收益，但是却会耗费大量宝贵的内存。</p>
<p>5.【强制】使用完毕的图片，应该及时回收，释放宝贵的内存。</p>
<p>6.【推荐】针对不同的屏幕密度，提供对应的图片资源，使内存占用和显示效果达到合理的平衡。如果为了节省包体积，可以在不影响 UI 效果的前提下，省略低密度图片。</p>
<p>7.【强制】在 Activity.onPause()或 Activity.onStop()回调中，关闭当前 activity 正在执行的的动画。</p>
<p>8.【推荐】在动画或者其他异步任务结束时，应该考虑回调时刻的环境是否还支持业务处理。例如 Activity 的 onStop()函数已经执行，且在该函数中主动释放了资源，此时回调中如果不做判断就会空指针崩溃。</p>
<p>9.【推荐】使用 inBitmap 重复利用内存空间，避免重复开辟新内存。</p>
<p>10.【推荐】使用 ARGB_565 代替 ARGB_888，在不怎么降低视觉效果的前提下，减少内存占用。</p>
<p>​    说明：</p>
<p>​    android.graphics.Bitmap.Config 类中关于图片颜色的存储方式定义：</p>
<p>​    1) ALPHA_8 代表 8 位 Alpha 位图；</p>
<p>​    2) ARGB_4444 代表 16 位 ARGB 位图；</p>
<p>​    3) ARGB_8888 代表 32 位 ARGB 位图；</p>
<p>​    4) RGB_565 代表 8 位 RGB 位图。</p>
<p>​    位图位数越高，存储的颜色信息越多，图像也就越逼真。大多数场景使用的是ARGB_8888 和 RGB_565，RGB_565 能够在保证图片质量的情况下大大减少内存的开销，是解决 oom 的一种方法。</p>
<p>​    但是一定要注意 RGB_565 是没有透明度的，如果图片本身需要保留透明度，那么就不能使用 RGB_565。</p>
<p>11.【推荐】尽量减少 Bitmap （BitmapDrawable）的使用，尽量使用纯色（ColorDrawable）、渐变色（GradientDrawable）、 StateSelector（StateListDrawable）等与 Shape 结合的形式构建绘图。</p>
<p>12.【推荐】谨慎使用 gif 图片，注意限制每个页面允许同时播放的 gif 图片，以及单个gif 图片的大小。</p>
<p>13.【参考】大图片资源不要直接打包到 apk，可以考虑通过文件仓库远程下载，减小包体积。</p>
<p>14.【推荐】根据设备性能，选择性开启复杂动画，以实现一个整体较优的性能和体验；</p>
<p>15.【推荐】在有强依赖 onAnimationEnd 回调的交互时，如动画播放完毕才能操作页面 ， onAnimationEnd 可 能 会 因 各 种 异 常 没 被 回 调 （ 参 考 ：<a href="https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine" target="_blank" rel="external">https://stackoverflow.com/questions/5474923/onanimationend-is-not-getting-called-onanimationstart-works-fine</a> ）， 建 议 加 上 超 时 保 护 或 通 过 postDelay 替 代onAnimationEnd。</p>
<p>16.【推荐】当 View Animation 执行结束时，调用 View.clearAnimation()释放相关资源。</p>
<h1 id="八、安全"><a href="#八、安全" class="headerlink" title="八、安全"></a>八、安全</h1><p>1.【强制】使用 PendingIntent 时，禁止使用空 intent，同时禁止使用隐式 Intent</p>
<p>​    说明：</p>
<p>​    1) 使用 PendingIntent 时，使用了空 Intent,会导致恶意用户劫持修改 Intent 的内容。禁止使用一个空 Intent 去构造 PendingIntent，构造 PendingIntent 的 Intent一定要设置 ComponentName 或者 action。</p>
<p>​    2) PendingIntent 可以让其他 APP 中的代码像是运行自己 APP 中。 PendingIntent的intent接收方在使用该intent时与发送方有相同的权限。在使用PendingIntent时，PendingIntent 中包装的 intent 如果是隐式的 Intent，容易遭到劫持，导致信息泄露。</p>
<p>2.【强制】禁止使用常量初始化矢量参数构建 IvParameterSpec，建议 IV 通过随机方式产生。</p>
<p>​    说明：</p>
<p>​    使用固定初始化向量，结果密码文本可预测性会高得多，容易受到字典式攻击。 iv的作用主要是用于产生密文的第一个 block，以使最终生成的密文产生差异（明文相同的情况下），使密码攻击变得更为困难，除此之外 iv 并无其它用途。因此 iv 通过随机方式产生是一种十分简便、有效的途径。</p>
<p>3.【强制】将 android:allowbackup 属性设置为 false，防止 adb backup 导出数据。</p>
<p>​    说明：</p>
<p>​    在 AndroidManifest.xml 文件中为了方便对程序数据的备份和恢复在 Android APIlevel 8 以后增加了 android:allowBackup 属性值。默认情况下这个属性值为 true,故当 allowBackup 标志值为 true 时，即可通过 adb backup 和 adb restore 来备份和恢复应用程序数据。</p>
<p>4.【强制】在实现的 HostnameVerifier 子类中，需要使用 verify 函数效验服务器主机名的合法性，否则会导致恶意程序利用中间人攻击绕过主机名效验。</p>
<p>​    说明：</p>
<p>​    在握手期间，如果 URL 的主机名和服务器的标识主机名不匹配，则验证机制可以回调此接口的实现程序来确定是否应该允许此连接。如果回调内实现不恰当，默认接受所有域名，则有安全风险。</p>
<p>5.【强制】利用 X509TrustManager 子类中的 checkServerTrusted 函数效验服务器端证书的合法性。</p>
<p>​    说明：</p>
<p>​    在实现的 X509TrustManager 子类中未对服务端的证书做检验，这样会导致不被信任的证书绕过证书效验机制。</p>
<p>6.【强制】META-INF 目录中不能包含如.apk,.odex,.so 等敏感文件，该文件夹没有经过签名，容易被恶意替换。</p>
<p>7.【强制】Receiver/Provider 不能在毫无权限控制的情况下，将 android:export 设置为 true。</p>
<p>8.【参考】数据存储在 Sqlite 或者轻量级存储需要对数据进行加密，取出来的时候进行解密。</p>
<p>9.【强制】阻止 webview 通过 file:schema 方式访问本地敏感数据。</p>
<p>10.【强制】不要广播敏感信息，只能在本应用使用 LocalBroadcast，避免被别的应用收到，或者 setPackage 做限制。</p>
<p>11.【强制】不要把敏感信息打印到 log 中。</p>
<p>​    说明：</p>
<p>​    在 APP 的开发过程中，为了方便调试，通常会使用 log 函数输出一些关键流程的信息，这些信息中通常会包含敏感内容，如执行流程、明文的用户名密码等，这会让攻击者更加容易的了解 APP 内部结构方便破解和攻击，甚至直接获取到有价值的敏感信息。</p>
<p>12.【强制】对于内部使用的组件，显示设置组件的”android:exported”属性为 false。</p>
<p>​    说明：</p>
<p>​    Android 应用使用 Intent 机制在组件之间传递数据，如果应用在使用 getIntent()，getAction()，Intent.getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异常捕获，应用就会发生 Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向受害者应用发送此类空数据、异常或者畸形数据从而使应用产生本地拒绝服务。</p>
<p>13.【强制】应用发布前确保 android:debuggable 属性设置为 false。</p>
<p>14.【强制】使用 Intent Scheme URL 需要做过滤。</p>
<p>​    说明：</p>
<p>​    如果浏览器支持 Intent Scheme Uri 语法，如果过滤不当，那么恶意用户可能通过浏览器 js 代码进行一些恶意行为，比如盗取 cookie 等。如果使用了 Intent.parseUri函 数 ， 获 取 的 intent 必 须 严 格 过 滤 ， intent 至 少 包 含addCategory(“android.intent.category.BROWSABLE”) ， setComponent(null) ，setSelector(null)3 个策略。</p>
<p>15.【强制】密钥加密存储或者经过变形处理后用于加解密运算，切勿硬编码到代码中。</p>
<p>​    说明：</p>
<p>​    应用程序在加解密时，使用硬编码在程序中的密钥，攻击者通过反编译拿到密钥可以轻易解密 APP 通信数据。</p>
<p>16.【强制】将所需要动态加载的文件放置在 apk 内部，或应用私有目录中，如果应用必须要把所加载的文件放置在可被其他应用读写的目录中(比如 sdcard)，建议对不可信的加载源进行完整性校验和白名单处理，以保证不被恶意代码注入。</p>
<p>17.【强制】除非 min API level &gt;=17，请注意 addJavascriptInterface 的使用。</p>
<p>​    说明：</p>
<p>​    API level&gt;=17，允许 js 被调用的函数必须以@JavascriptInterface 进行注解，因此不受影响； 对于 API level &lt; 17，尽量不要使用 addJavascriptInterface，如果一定要用，那么：</p>
<p>​    1) 使用 https 协议加载 URL，使用证书校验，防止访问的页面被篡改挂马；</p>
<p>​    2) 对加载 URL 做白名单过滤、完整性校验等防止访问的页面被篡改；</p>
<p>​    3) 如果加载本地 html,应该会 HTML 内置在 APK 中，以及对 HTML 页面进行完整性校验。</p>
<p>18.【强制】使用 Android 的 AES/DES/DESede 加密算法时，不要使用默认的加密模式ECB，应显示指定使用 CBC 或 CFB 加密模式。</p>
<p>​    说明：</p>
<p>​    加密模式 ECB、 CBC、 CFB、 OFB 等，其中 ECB 的安全性较弱，会使相同的铭文在不同的时候产生相同的密文，容易遇到字典攻击，建议使用 CBC 或 CFB 模式。</p>
<p>​    1) ECB：Electronic codebook，电子密码本模式</p>
<p>​    2) CBC：Cipher-block chaining，密码分组链接模式</p>
<p>​    3) CFB：Cipher feedback，密文反馈模式</p>
<p>​    4) OFB：Output feedback，输出反馈模式</p>
<p>19.【强制】不要使用 loopback 来通信敏感信息。</p>
<p>20.【推荐】对于不需要使用 File 协议的应用，禁用 File 协议，显式设置 webView.getSettings().setAllowFileAccess(false)，对于需要使用 File 协议的应用，禁止 File协议调用 JavaScript，显式设置 webView.getSettings().setJavaScriptEnabled(false)。</p>
<p>21.【强制】Android APP 在 HTTPS 通信中，验证策略需要改成严格模式。</p>
<p>​    说明： AndroidAPP 在 HTTPS 通信中，使用ALLOW_ALL_HOSTNAME_VERIFIER，表示允许和所有的 HOST 建立 SSL 通信，这会存在中间人攻击的风险，最终导致敏感信息可能会被劫持，以及其他形式的攻击。</p>
<p>22.【推荐】Android5.0 以后安全性要求 较高的应用 应该使 用 window.setFlag(LayoutParam.FLAG_SECURE) 禁止录屏。</p>
<p>23.【推荐】zip 中不建议允许../../file 这样的路径，可能被篡改目录结构，造成攻击。</p>
<p>​    说明：当 zip 压缩包中允许存在”../“的字符串，攻击者可以利用多个”../“在解压时改变zip 文件存放的位置，当文件已经存在是就会进行覆盖，如果覆盖掉的文件是 so、dex 或者 odex 文件，就有可能造成严重的安全问题。</p>
<p>24.【强制】开放的 activity/service/receiver 等需要对传入的 intent 做合法性校验。</p>
<p>25.【推荐】加密算法：使用不安全的 Hash 算法(MD5/SHA-1)加密信息，存在被破解的风险，建议使用 SHA-256 等安全性更高的 Hash 算法。</p>
<p>26.【推荐】Android WebView 组件加载网页发生证书认证错误时,采用默认的处理方法handler.cancel()，停止加载问题页面。</p>
<p>​    说明：</p>
<p>​    Android WebView 组件加载网页发生证书认证错误时，会调用 WebViewClient 类的onReceivedSslError 方法，如果该方法实现调用了 handler.proceed()来忽略该证书错误，则会受到中间人攻击的威胁，可能导致隐私泄露。</p>
<p>27.【推荐】直接传递命令字或者间接处理有敏感信息或操作时，避免使用 socket 实现，使用能够控制权限校验身份的方式通讯。</p>
<h1 id="九、其他"><a href="#九、其他" class="headerlink" title="九、其他"></a>九、其他</h1><p>1.【强制】不要通过 Msg 传递大的对象，会导致内存问题。</p>
<p>2.【强制】不能使用 System.out.println 打印 log。</p>
<p>3.【强制】Log 的 tag 不能是” “。</p>
<p>作者：鑫鱻</p>
<p>链接：<a href="https://www.jianshu.com/p/cc17c4d180fa" target="_blank" rel="external">https://www.jianshu.com/p/cc17c4d180fa</a></p>
<p>來源：简书</p>
<p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/30/ReactiveX3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/ReactiveX3/" itemprop="url">RxJava2 复杂异步场景之——Token前置请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-30T00:00:00+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542448088434&amp;di=32f275cf3a1f761431b6ed1c48bf6f85&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2017-11-20%2F5a127cc5f2620.jpg" alt=""></p>
<h3 id="RxJava的用武之地"><a href="#RxJava的用武之地" class="headerlink" title="RxJava的用武之地"></a>RxJava的用武之地</h3><p>Rxjava这个库和其他常见库不太一样，一般的库例如Glide，ButterKnife都是为了解决实际问题出现的，一定程度上是刚需。Glide库如果不用他，那么应用自己就要处理图片下载、压缩、内存管理、多级缓存等等复杂的逻辑。这类问题复杂而常见，而像Glide这类的轮子，Api的设计都比较友好，一个简单的api调用就能完成一个原本很复杂的功能，简直不要太爽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Glide.with(context)</div><div class="line">    .load(url)//图片加载</div><div class="line">    .crossFade()//动画设置</div><div class="line">    .placeholder(R.drawable.place_image)//占位图</div><div class="line">    .error(R.drawable.error_image)//失败占位图</div><div class="line">    .override(width,height)//图片裁剪</div><div class="line">    .thumbnail(thumbnailRequest)//配置缩略图</div><div class="line">    .diskCacheStrategy(DiskCacheStrategy.SOURCE)//缓存策略</div><div class="line">    .into(imageView);</div></pre></td></tr></table></figure></p>
<p>而Rxjava，你刚开始看起来，都不知道他是干什么的。“异步处理”？不是一般都使用观察者模式吗？AsyncTask，Handler也可以，要rxjava干嘛？如果你有兴趣研究过一点rxjava，会发现网上的教程都会说：”zip map flatmap debounce等操作符把异步回调变得‘简洁’‘优雅’”，然后对比一下原来的代码和使用rxjava后的代码，最后感叹一下rxjava设计的鬼才和功能的强大。我自己在初次接触rxjava时也感觉，这些rxjava的优点描述比较空洞，这项技术的意义大于实用。<br>实际情况是这样么？在具体开发中，异步调用给我们的最大困扰是：异步回调的时间并不可控。当有多个异步回调时，这些调用相互联系和依赖，搞清楚每个回调何时返回是个重要的问题。在每个关键时间节点对‘分散的callback’做正确的事，有过类似编程经验的人都知道，是非常痛苦的事，如果还想代码容易看懂，简直是疯了。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542204750068&amp;di=9b8b158cf28431c81169ea0b66c630fa&amp;imgtype=0&amp;src=http%3A%2F%2Fwx2.sinaimg.cn%2Fbmiddle%2F9e31678cgy1frlkvhvb74j206o06oaa3.jpg" alt=""><br>rxjava号称异步调用的终极解决方案，能否解决以上困扰？随着学习和应用的深入，体会会更明显。以下会用一个稍复杂的例子，实操一个复杂异步场景，看看rxjava处理的怎么样。</p>
<h3 id="典型复杂异步场景-–-Token的前置校验"><a href="#典型复杂异步场景-–-Token的前置校验" class="headerlink" title="典型复杂异步场景 – Token的前置校验"></a>典型复杂异步场景 – Token的前置校验</h3><p>经常遇到这种需求，接口的请求依赖token信息。一个请求需要先请求token（token如果存在缓存则使用缓存），依赖这个token才能进行正常网络请求。这个token有一定的时效性，在时效性内可以使用缓存，过期后需要重新请求token并重新发起一次请求。这个流程可以归纳如下图：<br><img src="https://upload-images.jianshu.io/upload_images/2432018-f715dadc4d40d252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="token前置请求.png"><br>光看这些需求，是不是觉得已经够你喝一壶了，别忙，还有些潜在的逻辑这个图没有表现出来：<br>1 高并发网络请求时，如果token正在请求，需要对请求阻塞（token请求过程中，不再接受新的token请求）<br>2 阻塞的同时，要把这些请求记录下来，token请求成功后，再‘依次’发送这些阻塞的请求。<br>3 token失效情况下，网络请求限制重试次数。（防止递归调用）<br>4 token请求本身，重试策略需单独配置。</p>
<h4 id="不使用rxjava，我们如何实现上述需求："><a href="#不使用rxjava，我们如何实现上述需求：" class="headerlink" title="不使用rxjava，我们如何实现上述需求："></a>不使用rxjava，我们如何实现上述需求：</h4><p>1、网络请求前，对token是否有缓存判断，如果没有先请求token，并把这个请求阻塞且缓存<br>2、token请求过程中，如果有新的token请求进来，加入阻塞队列<br>3、token请求后，通知阻塞的队列（广播等方式），依次进行阻塞的请求<br>4、对两种次数限制，分别做逻辑判断</p>
<p>以上就是传统实现方法，就不贴代码了，这样实现有以下特点：<br>1、要时刻维护一个阻塞队列 （注意其添加和清空的时机）<br>2、token请求结束后，有一个回调机制通知阻塞队列，（这个回调需要注册和反注册）<br>3、两处的次数限制，次数维护的变量，不好维护（一般动态秘钥为了便于使用会做成单例，单例内的变量类似static，维护较复杂）<br>4、请求重试的逻辑不好实现，</p>
<p>我们可以看到这里涉及到很多静态变量的维护，广播等异步回调的处理，这种情况一多，编程者会变得很被动。而且token的异步请求和真正的网络异步请求杂糅在一起，增大了问题的复杂性。</p>
<h4 id="我们来看下rxjava如何处理："><a href="#我们来看下rxjava如何处理：" class="headerlink" title="我们来看下rxjava如何处理："></a>我们来看下rxjava如何处理：</h4><p>一些代码网络请求部分与前一篇博客《基于RxJava Retrofit的网络框架》相关。</p>
<h5 id="先看看完整的请求过程"><a href="#先看看完整的请求过程" class="headerlink" title="先看看完整的请求过程"></a>先看看完整的请求过程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public static &lt;R&gt; Observable send(final MapiHttpRequest request, final MapiTypeReference&lt;R&gt; t)&#123;</div><div class="line">    return Observable.defer(new Callable&lt;ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;String&gt; call() throws Exception &#123;</div><div class="line">                    //传入token缓存</div><div class="line">                    return Observable.just(Store.sToken);</div><div class="line">                &#125;</div><div class="line">            &#125;).flatMap(new Function&lt;String, ObservableSource&lt;R&gt;&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;R&gt; apply(String key) throws Exception &#123;</div><div class="line">                    if(TextUtils.isEmpty(key) &amp;&amp; !request.skipCheckKeyValid())&#123;</div><div class="line">                        //token没有缓存，需要请求Token</div><div class="line">                        return Observable.&lt;R&gt;error(new KeyNotValidThrowable());</div><div class="line">                    &#125; else &#123;</div><div class="line">                        //Token存在缓存，直接请求</div><div class="line">                        return sendRequestInternal(request,t);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            //进入失败重试流程</div><div class="line">            .retryWhen(new Function&lt;Observable&lt;? extends Throwable&gt;, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                private int retryCount = 0;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;String&gt; apply(Observable&lt;? extends Throwable&gt; throwableObservable) throws Exception &#123;</div><div class="line">                    return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                        @Override</div><div class="line">                        public ObservableSource&lt;String&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">                            if (throwable instanceof KeyNotValidThrowable)&#123;</div><div class="line">                                //同一Request，有过一次KeyNotValidThrowable,则不再重试</div><div class="line">                                if (retryCount &gt; 0)&#123;</div><div class="line">                                    return Observable.error(throwable);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                //token缓存不在，进入TokenLoader请求token</div><div class="line">                                    retryCount++;</div><div class="line">                                    return TokenLoader.getInstance().getNetTokenLocked();</div><div class="line">                                &#125;</div><div class="line">                            &#125; else if (throwable instanceof ApiException)&#123;</div><div class="line">                                  //token过期的情况，重新获取token，并重试</div><div class="line">                                  ApiException apiException = (ApiException)throwable;</div><div class="line">                                  if (apiException.getCode() == MapiResultCode.SECRETKEY_EXPIRED.value())&#123;</div><div class="line">                                      if (retryCount &gt; 0)&#123;</div><div class="line">                                          return Observable.error(throwable);</div><div class="line">                                      &#125; else &#123;</div><div class="line">                                          //token缓存失效，进入TokenLoader请求token</div><div class="line">                                          retryCount++;</div><div class="line">                                          return DynamicKeyLoader.getInstance().getNetTokenLocked();</div><div class="line">                                      &#125;</div><div class="line">                                  &#125;</div><div class="line">                            &#125;</div><div class="line">                            //其他类型错误，直接抛出，不再重试</div><div class="line">                            return Observable.error(throwable);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也许你第一次看也挺晕，别怕，你顺着注释捋捋逻辑，是不是感觉代码的实现好像画了一个时序图。<br>除了注释以外，几点说明：<br>1、defer操作符的作用是在retry时，会重新创建新的Observable，否则会使用上次的Observable，不会重新获取Store.sToken<br>2、retryWhen操作符，与sendRequestInternal内部统一配置的retryWhen并不冲突，相当于二次retry<br>3、retryWhen中如果抛出error ，则不再重试；<br>4、重试请求，通过返回getNetTokenLocked这个subject实现。（下面详述）</p>
<h5 id="阶段总结："><a href="#阶段总结：" class="headerlink" title="阶段总结："></a>阶段总结：</h5><p>整体的流程被压缩到了一个函数中，rxjava本身的retrywhen和subject机制，已经替我们完成了这么几点：<br>1、自动重试的注册和反注册，subject被回调完直接失效，再次请求要重新注册。<br>2、高并发request，维护队列，通过mTokenObservable的回调自动解决了这个问题<br>3、retry次数的维护，由于每次request的retry都是重新创建的内部类，所以变量的维护变的简单。<br>4、重试的逻辑被retry操作符自动实现了，只要重写retry的返回值就可以控制重试的策略。</p>
<h5 id="TokenLoader：Token的获取过程"><a href="#TokenLoader：Token的获取过程" class="headerlink" title="TokenLoader：Token的获取过程"></a>TokenLoader：Token的获取过程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">public class TokenLoader &#123;</div><div class="line"></div><div class="line">    public static final String TAG = TokenLoader.class.getSimpleName();</div><div class="line"></div><div class="line">    private AtomicBoolean mRefreshing = new AtomicBoolean(false);</div><div class="line">    private PublishSubject&lt;String&gt; mPublishSubject;</div><div class="line">    private Observable&lt;String&gt; mTokenObservable;</div><div class="line"></div><div class="line">    private TokenLoader() &#123;</div><div class="line">        final TokenRequest request = new TokenRequest(CarOperateApplication.getInstance());</div><div class="line">        mTokenObservable = Observable</div><div class="line">                  .defer(new Callable&lt;ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;TokenRequest&gt; call() throws Exception &#123;</div><div class="line">                          return Observable.just(request);</div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">                  .flatMap(new Function&lt;TokenRequest, ObservableSource&lt;MapiHttpResponse&lt;Boolean&gt;&gt;&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;MapiHttpResponse&lt;Boolean&gt;&gt; apply(RefreshKeyRequest refreshKeyRequest) throws Exception &#123;</div><div class="line">                          //Token请求接口</div><div class="line">                          return ApiHelper.sendDynamicKey(refreshKeyRequest,new MapiTypeReference&lt;MapiHttpResponse&lt;Boolean&gt;&gt;()&#123;&#125;);</div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">                  .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                      private int retryCount = 0;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;TokenRequest&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123;</div><div class="line">                          return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                              @Override</div><div class="line">                              public ObservableSource&lt;RefreshKeyRequest&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">                                  retryCount++;</div><div class="line">                                  if (retryCount == 3)&#123;</div><div class="line">                                      //失败次数达到阈值，更改请求策略</div><div class="line">                                      request.setFlag(0);</div><div class="line">                                      return Observable.just(request);</div><div class="line">                                  &#125; else if (retryCount &gt; 3)&#123;</div><div class="line">                                      //失败次数超过阈值，抛出失败，放弃请求</div><div class="line">                                      mRefreshing.set(false);</div><div class="line">                                      return Observable.error(throwable);</div><div class="line">                                  &#125; else &#123;</div><div class="line">                                      //再次请求token</div><div class="line">                                      return Observable.just(request);</div><div class="line">                                  &#125;</div><div class="line">                              &#125;</div><div class="line">                          &#125;);</div><div class="line"></div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">    //                      .delay(6000, TimeUnit.MILLISECONDS) //模拟token请求延迟</div><div class="line">                  .map(new Function&lt;MapiHttpResponse&lt;Boolean&gt;,String&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public String apply(MapiHttpResponse&lt;Boolean&gt; response) throws Exception &#123;</div><div class="line">                          //成功，保存token缓存</div><div class="line">                          if (response.getContent().booleanValue() == true)&#123;</div><div class="line">                              setCacheToken(response.getToken());</div><div class="line">                          &#125; else if (response.getContent().booleanValue() == false)&#123;</div><div class="line">                              setCacheToken(UcarK.getSign());</div><div class="line">                          &#125;</div><div class="line">                          //请求完成标识</div><div class="line">                          mRefreshing.set(false);</div><div class="line">                          return getCacheToken();</div><div class="line">                      &#125;</div><div class="line">                  &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static TokenLoader getInstance() &#123;</div><div class="line">        return Holder.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Holder &#123;</div><div class="line">        private static final TokenLoader INSTANCE = new TokenLoader();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCacheToken() &#123;</div><div class="line">        return Store.sToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCacheToken(String key)&#123;</div><div class="line">        Store.sToken = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public Observable&lt;String&gt; getNetTokenLocked() &#123;</div><div class="line">        if (mRefreshing.compareAndSet(false, true)) &#123;</div><div class="line">            Log.d(TAG, &quot;没有请求，发起一次新的Token请求&quot;);</div><div class="line">            startTokenRequest();</div><div class="line">        &#125; else &#123;</div><div class="line">            Log.d(TAG, &quot;已经有请求，直接返回等待&quot;);</div><div class="line">        &#125;</div><div class="line">        return mPublishSubject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startTokenRequest() &#123;</div><div class="line">        mPublishSubject = PublishSubject.create();</div><div class="line">        mTokenObservable.subscribe(mPublishSubject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是读注释，除了注释以外，几点说明：<br>1、mRefreshing的作用是在token请求过程中，不再允许新的token请求，<br>变量采用原子类，而非boolean；这样在多线程环境下，原子类的方法是线程安全的。<br>compareAndSet(boolean expect, boolean update)这个方法两个作用<br>    1）比较expect和mRefresh是否一致<br>    2）将mRefreshing置为update</p>
<p>2、startTokenRequest()方法开启token请求，注意Observable在subscribe时才正式开始</p>
<p>3、这里使用了PublishSubject较为关键，在rxjava中Subject既是observable，又是observer，在TokenLoader中，mPublishSubject是mTokenObservable的观察者，token请求的会由mPublishSubject响应，同时mPublishSubject也作为Observable返回给TokenLoader的调用者作为retryWhen的返回值返回。（所以这里PublishSubject的泛型与send（）方法中Observable的泛型应该是一致的）</p>
<p>4、对于mRefreshing是true的情况，直接返回mPublishSubject，这样每个阻塞的请求retryWhen都会等待mPublishSubject的返回值，回调通知的顺序与加入阻塞的顺序是队列关系（先请求的接口，先回调），满足我们的需求。</p>
<p>最后：<br>感觉怎么样，是豁然开朗还是越陷越深，不管那样都没有关系，你需要的是了解还存在另一种处理异步任务的方法。在你下一次遇到同样让你头疼的问题时，你可以把这篇文章拿起来再看看，也许你的头疼会好一点了。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/ReactiveX2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/ReactiveX2/" itemprop="url">基于Observable网络框架的搭建（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T00:00:00+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2019/1/2/1680d4166d125b5b?w=1024&amp;h=682&amp;f=jpeg&amp;s=204862" alt=""></p>
<h3 id="Observable网络框架的解耦和复用"><a href="#Observable网络框架的解耦和复用" class="headerlink" title="Observable网络框架的解耦和复用"></a>Observable网络框架的解耦和复用</h3><h4 id="Observer一端的解耦"><a href="#Observer一端的解耦" class="headerlink" title="Observer一端的解耦"></a>Observer一端的解耦</h4><p>我们可以看到BaseObserver实际做了errorcode响应，loading控制，对外接口的定义等工作。这几部分工作集中在一个类中有一定的耦合。我们设计的目标是业务使用自定义的Observer或者直接使用BaseObserver都很方便，但目前的设计业务要么使用BaseObserver全部功能，要么自己从头定义，扩展性不强。<br>我们可以如下优化：</p>
<h5 id="将callback接口化"><a href="#将callback接口化" class="headerlink" title="将callback接口化"></a>将callback接口化</h5><p>BaseObserver定义的onSuccess(T)和onFail（boolean isException ,Object object）两个抽象方法是完全面向业务使用者的。可将其抽象为接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface ObserverCallback &lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;&#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求成功</div><div class="line">     * @param t</div><div class="line">     */</div><div class="line">    void onSuccess(T t);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求失败</div><div class="line">     * @param isException true：返回Throwable false：返回String（ErrorMsg）</div><div class="line">     * @param object</div><div class="line">     */</div><div class="line">    void onFail(boolean isException ,Object object);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>化为接口有两个作用</p>
<ol>
<li>规范自定义的Observer的回调接口。</li>
<li>可以与其他的网络请求调用方式（callback方式，非observable方式），回调接口上统一，降低切换成本。</li>
</ol>
<h5 id="将loading逻辑和error响应逻辑分离"><a href="#将loading逻辑和error响应逻辑分离" class="headerlink" title="将loading逻辑和error响应逻辑分离"></a>将loading逻辑和error响应逻辑分离</h5><p>定义LoadingObserver，其实现ObserverCallback接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class LoadingObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        implements Observer&lt;T&gt; ,ObserverCallback&lt;T&gt;&#123;</div><div class="line"></div><div class="line">    protected BaseContext mBaseContext;</div><div class="line"></div><div class="line">    public LoadingObserver(BaseContext baseContext)&#123;</div><div class="line">        mBaseContext = baseContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onSubscribe(Disposable d) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNext(T t) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">        onSuccess(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onComplete() &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void showProgress(boolean isShow)&#123;</div><div class="line">        if (mBaseContext != null) &#123;</div><div class="line">            mBaseContext.showLoading(isShow);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求是否loading显示</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowProgress()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做：<br>1、将更为通用的loading逻辑抽离，使其可以被独立使用或继承。<br>2、如果app存在不同业务线，可将error影响单独处理（不同业务线code定义可能不同），将loadingObserver类下沉，适配多业务线情况</p>
<h5 id="BaseObserver代码如下："><a href="#BaseObserver代码如下：" class="headerlink" title="BaseObserver代码如下："></a>BaseObserver代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class  MapiObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        extends LoadingObserver&lt;T&gt;&#123;</div><div class="line"></div><div class="line"></div><div class="line">    public MapiObserver(BaseContext baseContext)&#123;</div><div class="line">        super(baseContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        super.onError(e);</div><div class="line"></div><div class="line">        handleError(e);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleError(Throwable e)&#123;</div><div class="line">        //handle error code</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，Observer被分为了三层，原来BaseObserver这一层可以由多个更为具体的Observer来扩展。每一层都有自己的扩展功能。</p>
<h4 id="ObservableSource一端的解耦"><a href="#ObservableSource一端的解耦" class="headerlink" title="ObservableSource一端的解耦"></a>ObservableSource一端的解耦</h4><p>我们看下Observable一端做了哪些事情：</p>
<ol>
<li>对Request 参数做发送前处理：组合和加密处理</li>
<li>返回Response 解密处理，Java实体化</li>
<li>返回Response code码判断及分类</li>
</ol>
<p>Observable端解耦的目的</p>
<ol>
<li>耦合性降低后，方便后续的扩展和组合</li>
<li>将公共的，不易变化的逻辑下沉</li>
</ol>
<p>这是最终Observable生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）</div><div class="line">  &#123;</div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">              .map(new JavaBeanFunc(t))</div><div class="line">              .compose(ResponseTransformer.handleResult())</div><div class="line">              .subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Request请求params参数组合加密处理放到何处？"><a href="#Request请求params参数组合加密处理放到何处？" class="headerlink" title="Request请求params参数组合加密处理放到何处？"></a>Request请求params参数组合加密处理放到何处？</h5><p>前面一章已经提到，params是通过HttpRequest类中的getURLParam()方法完成。<br>原因有2点<br>1、params定义在HttpRequest中，在Httprequest类中拿最方便。<br>2、组合和加密的过程如果需要定制，那么直接在HttpRequest子类中就可以，和框架不会有耦合。</p>
<h5 id="Response解密处理，Java实体化，在何处处理？"><a href="#Response解密处理，Java实体化，在何处处理？" class="headerlink" title="Response解密处理，Java实体化，在何处处理？"></a>Response解密处理，Java实体化，在何处处理？</h5><p>Response解密处理网上有两种处理方式，<br>1、在okhttp里使用interceptor拦截器解密 2、ResponseTransformer中处理。<br>这两种方式都有问题：<br>虽然app内部一般解密方式不变，但是要适应多业务线，或者作为适应性更广的框架来讲，这块解密逻辑放到框架中显然耦合性太高。<br>我们采用的方式是定义接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ResponseDecryptHandler &#123;</div><div class="line">    String decrypt(String var1) throws IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HttpRequest类中定义实现接口，并将这种解密方式作为Convertor设置给Retrofit，这样将加密的逻辑耦合转移到了HttpRequest基类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addConverterFactory(SecurityConvertFactory.create(request.responseDecryptHandler()))</div></pre></td></tr></table></figure></p>
<p>对于JavaBean实体化，一般都采用fastJson方式，这里我们通过map操作符完成，作为链式调用中的一环出现，替换方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.map(new JavaBeanFunc(t))</div></pre></td></tr></table></figure></p>
<h5 id="Response的code解析，在何处处理？"><a href="#Response的code解析，在何处处理？" class="headerlink" title="Response的code解析，在何处处理？"></a>Response的code解析，在何处处理？</h5><p>前面提到，response的code分为了解析和处理两个部分，分别放在observable和observer中完成。其中ResponseTransformer是用于解析response的返回值。<br>ErrorResumeFunction和ResponseFunction分别是网络错误和业务错误，网络错误不会变，业务错误的判断是可能扩展的。ResponseFunction的实现是可以多样的。<br></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）</div><div class="line">  &#123;</div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">              .map(new JavaBeanFunc(t))</div><div class="line">              .compose(ResponseTransformer.handleResult())</div><div class="line">              .subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上可以看出Observable的生成过程中，除了一部分的逻辑放入的Request的接口中用于扩展，其他的功能在Observable的生成过程中以链式调用的方式存在，每个链式调用的功能由一个类承担。这也是rxjava的优势所在，在调用方式上天然地将各部分解耦了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/ReactiveX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/ReactiveX/" itemprop="url">基于Observable网络框架的搭建（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T00:00:00+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2018/12/20/167cbc97890ed044?w=4500&amp;h=2722&amp;f=jpeg&amp;s=850890" alt=""></p>
<h2 id="Observable网络框架设计的背景和原则"><a href="#Observable网络框架设计的背景和原则" class="headerlink" title="Observable网络框架设计的背景和原则"></a>Observable网络框架设计的背景和原则</h2><h3 id="Observable网络框架建立的原因"><a href="#Observable网络框架建立的原因" class="headerlink" title="Observable网络框架建立的原因"></a>Observable网络框架建立的原因</h3><p><strong>两个问题：</strong></p>
<ul>
<li><p><em>Retrofit已经对网络请求做了封装，为什么还要封装?</em></p>
<p>答：网络请求中对于请求流程、配置、入参封装、加解密、异常处理每个app都是固定不变的，如果业务每次请求都自己处理，会存在冗余代码，且质量不易保证。所以我们需要基于Retrofit对这些流程和操作做二次封装，并对调用方式进行统一，我们称之为网络框架。</p>
</li>
<li><p><em>框架封装Observable方式是什么？</em></p>
<p>答：传统网络框架封装方式采用callback/listener异步回调网络请求结果。但是这种callback的方式，没有利用到Retrofit的一大优势–rxjava调用，所以我们要基于rxjava调用方式，封装一个基于返回Observable的网络请求框架。<br>以下所说网络框架，均指基于返回Observable的网络请求二次封装框架。</p>
</li>
</ul>
<h3 id="Observable网络框架设计目标"><a href="#Observable网络框架设计目标" class="headerlink" title="Observable网络框架设计目标"></a>Observable网络框架设计目标</h3><ul>
<li>T1：业务对Request的业务params、url可轻松配置，框架对params组合和加密统一处理</li>
<li>T2：框架对返回Response解密、code判断等统一处理，并直接返回业务JavaBean结果</li>
<li>T3：返回值Observable，使网络请求可作为rxjava调用链中的一环</li>
<li>T4：调用入口统一、封装流程，对业务透明</li>
<li>T5：请求支持cancle机制、progressBar等通用处理</li>
</ul>
<h3 id="Observable网络框架设计原则"><a href="#Observable网络框架设计原则" class="headerlink" title="Observable网络框架设计原则"></a>Observable网络框架设计原则</h3><p><strong>设计原则：</strong></p>
<ol>
<li><p>网络框架Api返回Observable对象，并作为网络请求事件的生产者：</p>
<p> 生产者负责请求的发起接收，和返回数据的预处理。</p>
</li>
<li><p>业务注册Observer类，作为消费者。</p>
<p>只负责对返回数据的响应</p>
</li>
</ol>
<p>这是为了T3的设计目标，生产者和消费者界限明确，做到完全解耦，为网络请求与其他rxjava异步调用的整合打基础。</p>
<p><em>这篇文章详细讲述框架中生产者的实现，消费者的实现在<a href="https://juejin.im/post/5c2c585f518825544d43dd4c" target="_blank" rel="external">RxJava练武场之——Observable网络框架的解耦和复用</a>中介绍</em></p>
<hr>
<h2 id="Observable网络框架如何实现"><a href="#Observable网络框架如何实现" class="headerlink" title="Observable网络框架如何实现"></a>Observable网络框架如何实现</h2><h3 id="在Observable的创建过程中，框架如何封装？"><a href="#在Observable的创建过程中，框架如何封装？" class="headerlink" title="在Observable的创建过程中，框架如何封装？"></a>在Observable的创建过程中，框架如何封装？</h3><p>首先我们需要一个Manager或Helper全局句柄，通过他可以发起网络请求，一般设计为单例全局持有，有利于网络请求一些资源的共用。<br>我们暂定为NetHelper,其网络请求Api定义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static &lt;R extends HttpResponse&lt;?&gt;&gt; Observable sendRequest(final HttpRequest&lt;R&gt; orgRequest)</div></pre></td></tr></table></figure>
<p>sendRequest方法中，返回Observable对象，通过泛型规范Response的类型（T2目标的基础），HttpRequest（T1目标的基础）</p>
<h4 id="第一步-HttpRequest定义"><a href="#第一步-HttpRequest定义" class="headerlink" title="第一步 HttpRequest定义"></a>第一步 HttpRequest定义</h4><p>定义Request接口，这个接口是retrofit指定的方式。Retrofit本来希望你这么做的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface LoginRequest &#123;</div><div class="line"></div><div class="line">    @POST(&quot;&#123;/get/login&#125;&quot;)</div><div class="line">    Observable&lt;LoginInfo&gt; login(@FieldMap Map&lt;String, String&gt; params);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在LoginRequest中你定义了url，Response JavaBean, 入参params的方式（map）<br>通过 <code>LoginRequest loginRequest = retrofit.create(LoginRequest.class);</code> 动态代理的方式帮你把request的配置都生成好了。</p>
<p>但是map的传入这部分，需要业务自行处理入参的组合和加密，当然业务可以通过工具类的方式来规范这一步骤（网上多是此种方案），但这样会让业务参与到请求流程来了，不符合T4的目标。</p>
<p>我们希望业务定义LoginRequest如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class LoginRequest extends HttpRequest&lt;R extends HttpResponse&gt; &#123;</div><div class="line"></div><div class="line">    private String userAccount;</div><div class="line">    private String userPwd;</div><div class="line">    private int accountType;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected String getURL() &#123;</div><div class="line">        return &quot;/get/login&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>业务只关心入参和url的定义，不需要关心入参的组合和加密方式（T1目标），通过NetHelper.send(loginRequest)一个调用就能拿到结果。这种定义方式不仅和Retrofit原生方式一样将url和Response类型都定义了，还一起将params也定义了进来。</p>
<p>所以我们不直接使用Retrofit的接口定义方式，封装了一个专为业务定义的HttpRequest类，最终也由这个类向Retrofit接口传递数据。</p>
<p>要满足上述调用方式，满足两个前提条件</p>
<ol>
<li>HttRequest基类，要处理入参的组合和加密处理</li>
<li>Retrofit对应的Request定义接口，要改为通用的方式，以适应不同的HttpRequest子类的定义</li>
</ol>
<p>Request接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Request &#123;</div><div class="line"></div><div class="line">    @POST(&quot;&#123;url&#125;&quot;)</div><div class="line">    Observable&lt;JSONObject&gt; postJSONResult(@Path(value=&quot;url&quot;,encoded =true) String url, @FieldMap Map&lt;String, String&gt; params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们定义的Observable泛型是通用的JSONObject，url是通过入参方式传入。</p>
<h4 id="第二步-创建retrofit；"><a href="#第二步-创建retrofit；" class="headerlink" title="第二步 创建retrofit；"></a>第二步 创建retrofit；</h4><p>NetHelper.java中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 初始化okhttp</div><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">        .build();</div><div class="line">/**</div><div class="line"> *OkHttpClient每次请求的时候都要创建，注意：OkHttpClient.Builder()中有ConnectionPool作为OkHttp的   	*连接池要复用，否则请求过多时容易导致内存溢出</div><div class="line">**/</div><div class="line"></div><div class="line">// 初始化Retrofit</div><div class="line">retrofit = new Retrofit.Builder()</div><div class="line">        .client(client)</div><div class="line">        .baseUrl(Request.HOST)</div><div class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">        .addConverterFactory(MyConverterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure>
<p>一般addConverterFactory配置是GsonConverterFactory，用于把Response通过GSon转为javaBean（Request接口中定义的类型），由于我们定义为了JsonObject，所以我们使用MyConverterFactory自定义实现</p>
<h4 id="第三步-生成Observable"><a href="#第三步-生成Observable" class="headerlink" title="第三步 生成Observable"></a>第三步 生成Observable</h4><p>Observable的真正创建，我们放到Request基类中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public abstract class HttpRequest&lt;R extends HttpResponse&gt;&#123;</div><div class="line">    protected abstract String getURLAction();</div><div class="line">    </div><div class="line">    //Observable的创建</div><div class="line">    public Observable getObservable(Retrofit retrofit) &#123;</div><div class="line">        Request request = retrofit.create(Request.class);</div><div class="line">		return request.postJSONResult(getURLAction(),getURLParam());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //子类中复写该接口的url</div><div class="line">    public String getBaseURL()&#123;</div><div class="line">        //return base url;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public SortedMap&lt;String, String&gt; getURLParam() &#123;</div><div class="line">    	//return 对HttpRequest子类(业务类)，定义的params，进行组合和加密</div><div class="line">    	//通用的组合和加密逻辑就在此处。</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //response类型解析</div><div class="line">    protected Type type;</div><div class="line"></div><div class="line">    public ObservableMapiRequest(BaseContext context) &#123;</div><div class="line">        super(context);</div><div class="line">        initType();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //泛型R类型的获取，拿到HttpResponse的类型</div><div class="line">    private void initType() &#123;</div><div class="line">        Type superClass = getClass().getGenericSuperclass();</div><div class="line"></div><div class="line">        this.type = ((ParameterizedType) superClass).getActualTypeArguments()[0];</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Type getType() &#123;</div><div class="line">        return type;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步中，我们将HttpRequest子类（例如LoginRequest）中定义的url params HttpResponse都获取到了。</p>
<h4 id="第四步-NetHelper-Api的调用"><a href="#第四步-NetHelper-Api的调用" class="headerlink" title="第四步 NetHelper Api的调用"></a>第四步 NetHelper Api的调用</h4><p>以上三步，已经初步将Observable返回。下面的处理NetHelper中Api的调用，也是框架的重点和核心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private static &lt;R extends HttpResponse&lt;?&gt;&gt; Observable sendRequest(final ObservableRequest&lt;R&gt; orgRequest)&#123;</div><div class="line">        return NetHelper.getObservable(orgRequest)</div><div class="line">                //对Response的JsonObject进行类型转化</div><div class="line">                .map(new JavaBeanFunc(orgRequest.getType()))</div><div class="line">                //添加拦截器、Log等</div><div class="line">                .filter(new LogInterceptor(orgRequest))</div><div class="line">                //对Response预处理，code分类等</div><div class="line">                .compose(ResponseTransformer.handleResult())</div><div class="line">                //配置线程</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<hr>
<p>NetHelper.getApiObservable方法后，再加上网络请求的线程配置，这时候业务subscribe消费者，就可以直接得到解密后的JsonObject了。注意此时只是JSONObject，我们需要转换成我们需要的Response。</p>
<p>我们在HttpRequest类中看到了，定义HttpRequest子类时，是需要传入Response类型的（就是R），在HttpRequest类中已经将Response的类型解析出来，并保存了。在JavaBeanFunc中进行了转化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class JavaBeanFunc&lt;J extends JSONObject,T extends HttpResponse&gt; implements Function&lt;J,T&gt; &#123;</div><div class="line">    Type mCon;</div><div class="line">    public JavaBeanFunc(Type con)&#123;</div><div class="line">        mCon = con;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public T apply(J jsonObject) throws Exception &#123;</div><div class="line">        if (jsonObject != null)&#123;</div><div class="line">            T response = jsonObject.toJavaObject(mCon);</div><div class="line">            return response;</div><div class="line">        &#125; else &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时配置了拦截器，用于log输出，和异常的拦截,也可以做网络性能指标的记录等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public class LogInterceptor&lt;R extends HttpResponse&lt;?&gt;&gt; implements Predicate&lt;R&gt; &#123;</div><div class="line">    private HttpRequest&lt;R&gt; orgRequest;</div><div class="line"></div><div class="line">    public LogInterceptor(HttpRequest&lt;R&gt; request)&#123;</div><div class="line">        orgRequest = request;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean test(R response) throws Exception &#123;</div><div class="line">        boolean isPredicate = false;</div><div class="line">        if (orgRequest != null &amp;&amp; response != null) &#123;</div><div class="line">            HttpHelper.printHttpLog(orgRequest, JSONObject.toJSONString(response));</div><div class="line">            isPredicate = true;</div><div class="line">        &#125;</div><div class="line">        return isPredicate;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>response解析完毕之后，还没有完事；必须对response的正常和异常两种情况做一个判断，哪些情况作为onNext传递，哪些情况作为onError传递，也要定义清楚。此处我们采用ObservableTransformer来对数据流处理。</p>
<p>有些文章对于progressbar的控制也放到这里，我认为并不符合框架的设计原则，也就无法实现目标T3，不属于生产者该做的事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Serializable&gt; ObservableTransformer&lt;T, T&gt; handleResult() &#123;</div><div class="line">    return upstream -&gt; upstream</div><div class="line">            .onErrorResumeNext(new ErrorResumeFunction&lt;T&gt;())</div><div class="line">            .flatMap(new ResponseFunction&lt;T&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ErrorResumeFunction&lt;T extends Serializable&gt; implements Function&lt;Throwable, ObservableSource&lt;? extends T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;? extends T&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">        return Observable.error(CustomException.handleException(throwable));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ResponseFunction&lt;T extends Serializable&gt; implements Function&lt;T, ObservableSource&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;T&gt; apply(T tResponse) throws Exception &#123;</div><div class="line">        int code = tResponse.getCode();</div><div class="line">        String message = tResponse.getMsg();</div><div class="line"></div><div class="line">        if (code == SUCCESS.value()) &#123;</div><div class="line">            return Observable.just(tResponse);</div><div class="line">        &#125; else &#123;</div><div class="line">            return Observable.error(new ApiException(code, message));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，你可能有两个疑问，一个是response中code的判定可以在observer中处理吗，另一个是服务器错误和业务错误为何都作为error抛出。</p>
<p>第一个问题：<br>code值的判定不可以在observer中处理，而必须在Observable一端处理。因为Observable形式的网络请求是作为数据流中的一环出现的，可能当前网络请求只是一连串异步调用（rxjava调用）的一环。这是实现目标T3的关键点。<br>第二个问题：<br>response中code!=SUCCESS是业务错误的情况，必须向数据流中发出，让业务处理此异常。（那同时对于Response的定义也是，code!=SUCCESS必须是不需要业务处理的情况才行）<br>两种错误都抛出error（内部code不同），方便架构使用者在事件响应时，既能捕捉所有错误，又能区分错误的类型。</p>
<h3 id="框架的封装性和Request-cancle机制"><a href="#框架的封装性和Request-cancle机制" class="headerlink" title="框架的封装性和Request cancle机制"></a>框架的封装性和Request cancle机制</h3><h4 id="框架的封装性"><a href="#框架的封装性" class="headerlink" title="框架的封装性"></a>框架的封装性</h4><p>看下最终使用的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">LoginRequest request = new LoginRequest();</div><div class="line">request.setUserAccount(&quot;888&quot;);</div><div class="line">request.setUserPwd(&quot;888&quot;);</div><div class="line"></div><div class="line">ApiHelper.send(request)</div><div class="line">    .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(LoginResponse s) throws Exception &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Throwable throwable) throws Exception &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure></p>
<p>业务在使用上很简洁，LoginRequest和LoginResponse的定义也是业务关注的内容。基本达到T4的目标</p>
<h4 id="Request的Cancle机制"><a href="#Request的Cancle机制" class="headerlink" title="Request的Cancle机制"></a>Request的Cancle机制</h4><p>Request的cancle机制，一般原理是这样：在Activity/Fragment关闭时，需要cancle调正在请求中的网络，所以需要BaseActivity/BaseFragment的支持。<br>方案有二，这篇文章就不赘述了，因为都是比较成熟的方案。</p>
<ol>
<li>框架中加入RxLifecycle的绑定，这样在调用NetHelper的Api时，要传入BaseActivity/BaseFragment的实例</li>
<li>自己实现：在框架返回Observable的doOnSubscribe方法中，对当前request的disposable进行保存，并设置tag保存disposable和activity的对应关系，在BaseActivity的onDestroy方法中统一对disposable进行清理。</li>
</ol>
<h3 id="框架基于Rxjava的链式调用"><a href="#框架基于Rxjava的链式调用" class="headerlink" title="框架基于Rxjava的链式调用"></a>框架基于Rxjava的链式调用</h3><p>我们常常遇到这样一种场景，一个网络请求往往基于上一个网络请求的结果，或者一个页面的数据来自两个网络请求的组合，我们的网络框架是如何满足这种需求的呢？这也是我们这套框架设计的出发点和落脚点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">RegisterRequest registerRequest = new RegisterRequest();</div><div class="line">registerRequest.setUserAccount(account.getText());</div><div class="line">registerRequest.setUserPwd(pwd.getText());</div><div class="line">registerRequest.setUserSex(sex.getType());</div><div class="line"></div><div class="line">ApiHelper</div><div class="line">    .send(registerRequest)</div><div class="line">    .flatMap(new Function&lt;RegisterResponse, ObservableSource&lt;HttpResponse&lt;LoginResponse&gt;&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public ObservableSource&lt;HttpResponse&lt;LoginResponse&gt;&gt; apply(RegisterResponse response) throws Exception &#123;</div><div class="line">                LoginRequest loginRequest = new LoginRequest();</div><div class="line">                loginRequest.setUserAccount(account.getText());</div><div class="line">                loginRequest.setUserPwd(pwd.getText();</div><div class="line">                return ApiHelper.send(loginRequest);</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">    &#125;)</div><div class="line">    .subscribe(new Consumer&lt;LoginResponse&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(LoginResponse s) throws Exception &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">            &#125;, new Consumer&lt;Throwable&gt;() &#123;</div><div class="line">                    @Override</div><div class="line">                    public void accept(Throwable throwable) throws Exception &#123;</div><div class="line"></div><div class="line">                    &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure></p>
<p>这样我们就完成了一个先注册后登陆的网络请求流程，将网络框架融入了rxjava的调用链之中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章着重对基于Observable的网络框架中，Observable生产者部分进行了阐述，在‘框架的封装性’一节所举的例子中，我们只采用了最普通的Consumer来进行事件的消费，我们在下一篇文章中<a href="https://juejin.im/post/5c2c585f518825544d43dd4c" target="_blank" rel="external">RxJava练武场之——Observable网络框架的解耦和复用</a>会专门对消费者进行封装，使该框架的规范性和扩展性更强。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/LRecycler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/LRecycler/" itemprop="url">下拉刷新分页加载控件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T00:00:00+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc07429ae2de?w=900&amp;h=588&amp;f=jpeg&amp;s=30221" alt=""></p>
<h2 id="一篇文章撸遍下拉刷新-分页加载控件"><a href="#一篇文章撸遍下拉刷新-分页加载控件" class="headerlink" title="一篇文章撸遍下拉刷新 分页加载控件"></a>一篇文章撸遍下拉刷新 分页加载控件</h2><p>本文的研究对象是，在实际开发中经常用到的下拉刷新和分页加载功能。这两个功能往往相伴相生，下拉刷新是基于交互体验上的功能，已经是普遍工人的移动端的数据刷新交互（不限于列表）；分页加载一般考虑到后台数据的分页请求，降低后台的压力和网络延迟。<br>有没有将二者结合的比较好的第三方控件呢，本文将针对主流github三方控件，带你一一解读。</p>
<hr>
<h3 id="主流下拉刷新控件横评"><a href="#主流下拉刷新控件横评" class="headerlink" title="主流下拉刷新控件横评"></a>主流下拉刷新控件横评</h3><p>备注：我将从实现原理、易用性、扩展性、稳定性四个方面比较<br>易用性：包括<br>1、使用是否方便，xml java均可配置使用<br>2、是否将常用的逻辑功能封装（分页计算、footer显示与否等），使用者不关心细节<br>3、对一些常用的扩展是否已支持可配置（如header的自定义样式等）<br>扩展性：包括<br>1、支持的下拉、分页的ViewGroup是否可方便扩展<br>2、header footer等是否扩展方便<br>稳定性：包括<br>1、github活跃性，issue是否及时处理<br>2、上线后控件内部crash</p>
<h4 id="一、最早的先行者：XListView"><a href="#一、最早的先行者：XListView" class="headerlink" title="一、最早的先行者：XListView"></a>一、最早的先行者：XListView</h4><p>（<a href="https://github.com/Maxwin-z/XListView-Android）" target="_blank" rel="external">https://github.com/Maxwin-z/XListView-Android）</a></p>
<h5 id="1、实现原理："><a href="#1、实现原理：" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>XListView直接extends ListView，使用也和Listview一样，header和footer也是采用ListView自带的功能，仅对二者的layout做了封装XListViewFooter和XListViewHeader。<br>从代码结构来看，非常简单。header和footer的显示与否，通过listview的onTouchEvent来判断。<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc075a657c56?w=445&amp;h=313&amp;f=png&amp;s=36152" alt=""></p>
<h5 id="2、易用性："><a href="#2、易用性：" class="headerlink" title="2、易用性："></a>2、易用性：</h5><p>与ListView同，但是下拉和分页的可配置性几乎没有，常用封装全无</p>
<h5 id="3、扩展性："><a href="#3、扩展性：" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5><p>很差，只能在使用ListView时使用，扩展需要改动代码，代码本身扩展性考虑很少。</p>
<h5 id="4、稳定性："><a href="#4、稳定性：" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5><p>github已停更，有些线上经典crash难于解决。</p>
<ul>
<li>作为最早Android下拉刷新功能的实践者，仅有有历史意义</li>
</ul>
<hr>
<h4 id="二、广泛应用者：PullToRefresh"><a href="#二、广泛应用者：PullToRefresh" class="headerlink" title="二、广泛应用者：PullToRefresh"></a>二、广泛应用者：PullToRefresh</h4><p>(<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="external">https://github.com/chrisbanes/Android-PullToRefresh</a>)</p>
<h5 id="1、实现原理：-1"><a href="#1、实现原理：-1" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>其类图可以较好的说明，其架构方式：<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc075b86b5c8?w=1017&amp;h=606&amp;f=png&amp;s=85629" alt=""><br>PullToRefresh基本奠定了经典下拉刷新控件的架构形式：</p>
<ul>
<li>1）一部分是下拉和分页的骨架：核心content的加载和扩展、footer和header的加载、state的切换</li>
<li>2）一部分是footer和header的处理：footer header的交互、定制和扩展基于state。<br>依据以上两部分，基于IPullToRefresh和 ILoadingLayout两个接口开发。</li>
</ul>
<ol>
<li>核心骨架<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private void init(Context context, AttributeSet attrs) &#123;</div><div class="line">	setGravity(Gravity.CENTER);</div><div class="line"></div><div class="line">	ViewConfiguration config = ViewConfiguration.get(context);</div><div class="line">	mTouchSlop = config.getScaledTouchSlop();</div><div class="line"></div><div class="line">	....//Parse styleable</div><div class="line"></div><div class="line">	// Refreshable View 用于扩展</div><div class="line">	// By passing the attrs, we can add ListView/GridView params via XML</div><div class="line">	mRefreshableView = createRefreshableView(context, attrs);</div><div class="line">	addRefreshableView(context, mRefreshableView);</div><div class="line"></div><div class="line">	// We need to create now layouts now</div><div class="line">   	//createLoadingLayout方法构造header 和 footer</div><div class="line">	mHeaderLayout = createLoadingLayout(context, Mode.PULL_FROM_START, a);</div><div class="line">	mFooterLayout = createLoadingLayout(context, Mode.PULL_FROM_END, a);</div><div class="line"></div><div class="line"></div><div class="line">	if (a.hasValue(R.styleable.PullToRefresh_ptrOverScroll)) &#123;</div><div class="line">		mOverScrollEnabled = 					  a.getBoolean(R.styleable.PullToRefresh_ptrOverScroll, true);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if 	(a.hasValue(R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled)) &#123;</div><div class="line">		mScrollingWhileRefreshingEnabled = a.getBoolean(</div><div class="line">				R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled, false);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Let the derivative classes have a go at handling attributes, then</div><div class="line">	// recycle them...</div><div class="line">	handleStyledAttributes(a);</div><div class="line">	a.recycle();</div><div class="line"></div><div class="line">	// Finally update the UI for the modes</div><div class="line">   	//updateUIForMode 用于添加footer和header到linearlayout中</div><div class="line">	updateUIForMode();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PullToRefreshBase本身是LinearLayout，其支持横向和纵向的下拉刷新，把contentView（mRefreshableView）和footer header作为childView添加到其中。</p>
<ul>
<li>扩展方式：<br>abstract方法createRefreshableView（），在子类中实现用于扩展contentView<br>footer header的扩展通过createLoadingLayout()返回，只要继承自LoadingLayout即可扩展。当然控件本身提供了集中常用的Loadinglayout(FlipLoadingLayout RotateLoadingLayout)</li>
<li>交互处理：<br>如何从手势的变化决定header以及footer的state呢？是通过onInterceptTouchEvent和OnTouchEvent。<br>和其他的touch事件处理类似，onInterceptTouchEvent方法作为前置准备，onTouchEvent方法实际处理手势操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public final boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line"></div><div class="line">  if (!isPullToRefreshEnabled()) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // If we&apos;re refreshing, and the flag is set. Eat the event</div><div class="line">  if (!mScrollingWhileRefreshingEnabled &amp;&amp; isRefreshing()) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; event.getEdgeFlags() != 0) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  switch (event.getAction()) &#123;</div><div class="line">    case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">      if (mIsBeingDragged) &#123;</div><div class="line">        mLastMotionY = event.getY();</div><div class="line">        mLastMotionX = event.getX();</div><div class="line">        pullEvent();//处理拉动过程中，header footer状态的变化</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">      if (isReadyForPull()) &#123;</div><div class="line">        mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">        mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    case MotionEvent.ACTION_CANCEL:</div><div class="line">    case MotionEvent.ACTION_UP: &#123;</div><div class="line">      //ACTION_UP事件的处理，在不同state下松手，处理方式的不同</div><div class="line">      if (mIsBeingDragged) &#123;</div><div class="line">        mIsBeingDragged = false;</div><div class="line"></div><div class="line">        if (mState == State.RELEASE_TO_REFRESH</div><div class="line">            &amp;&amp; (null != mOnRefreshListener || null != mOnRefreshListener2)) &#123;</div><div class="line">          //拉动结束，在RELEASE_TO_REFRESH状态下松手，变为REFRESHING</div><div class="line">          setState(State.REFRESHING, true);</div><div class="line">          return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If we&apos;re already refreshing, just scroll back to the top</div><div class="line">        if (isRefreshing()) &#123;</div><div class="line">          //拉动结束，在REFRESHING状态下松手，回到原点</div><div class="line">          smoothScrollTo(0);</div><div class="line">          return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If we haven&apos;t returned by here, then we&apos;re not in a state</div><div class="line">        // to pull, so just reset</div><div class="line">        //拉动结束，在其他状态（PULL_TO_REFRESH）下松手，reset到初始状态</div><div class="line">        setState(State.RESET);</div><div class="line"></div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Actions a Pull Event</div><div class="line"> *</div><div class="line"> * @return true if the Event has been handled, false if there has been no</div><div class="line"> *         change</div><div class="line"> */</div><div class="line">private void pullEvent() &#123;</div><div class="line">  final int newScrollValue;</div><div class="line">  final int itemDimension;</div><div class="line">  final float initialMotionValue, lastMotionValue;</div><div class="line"></div><div class="line"></div><div class="line">  switch (mCurrentMode) &#123;</div><div class="line">    case PULL_FROM_END:</div><div class="line">      newScrollValue = Math.round(Math.max(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">      itemDimension = getFooterSize();</div><div class="line">      break;</div><div class="line">    case PULL_FROM_START:</div><div class="line">    default:</div><div class="line">      newScrollValue = Math.round(Math.min(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">      itemDimension = getHeaderSize();</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeaderScroll(newScrollValue);</div><div class="line"></div><div class="line">  if (newScrollValue != 0 &amp;&amp; !isRefreshing()) &#123;</div><div class="line">    float scale = Math.abs(newScrollValue) / (float) itemDimension;</div><div class="line">    switch (mCurrentMode) &#123;</div><div class="line">      case PULL_FROM_END://上拉分页</div><div class="line">        mFooterLayout.onPull(scale);//根据滑动的位置更新footerLayout</div><div class="line">        break;</div><div class="line">      case PULL_FROM_START://下拉刷新</div><div class="line">      default:</div><div class="line">        mHeaderLayout.onPull(scale);//根据滑动的位置更新headerLayout</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //根据滑动的位置（是否超过阈值），决定状态PULL_TO_REFRESH or RELEASE_TO_REFRESH</div><div class="line">    if (mState != State.PULL_TO_REFRESH &amp;&amp; itemDimension &gt;= Math.abs(newScrollValue)) &#123;</div><div class="line">      setState(State.PULL_TO_REFRESH);</div><div class="line">    &#125; else if (mState == State.PULL_TO_REFRESH &amp;&amp; itemDimension &lt; Math.abs(newScrollValue)) &#123;</div><div class="line">      setState(State.RELEASE_TO_REFRESH);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上代码容易理解下拉刷新的逻辑脉络，但是上拉分页加载是怎么实现的呢?<br>PullToRefreshBase控件通过mCurrentMode来区分上拉和下拉，其实上拉和下拉的逻辑，从整体上是可以归一的，有几个关键点</p>
<ul>
<li>1、判断上拉 下拉的逻辑阈值：isReadyForPullStart（）isReadyForPullEnd（）分别是下拉 上拉的阈值方法，子类需要根据 mRefreshableView来实现</li>
<li>2、在不同的state下做不同的处理: 两者都有 reset PULL_TO_REFRESH RELEASE_TO_REFRESH REFRESHING等状态，上拉不需要区分PULL_TO_REFRESH RELEASE_TO_REFRESH两种state而已。所以既然都是基于一套state的处理方案，那么根据手势滑动方向决定当前mCurrentMode，进而交给header 或 footer来处理state就是可行的。</li>
</ul>
<ol>
<li>footer和header的扩展和处理</li>
</ol>
<p>刚才说到了footer和header是在同一套state状态下的处理机制，其回调也类似。所以两者继承同一接口和基类。PullToRefreshBase控件采用了Proxy的方式，实现了二者的统一调用。<br>也就是说LoadingLayoutProxy 、headerLoadingLayout、footerLoadingLayout均实现ILoadingLayout，LoadingLayoutProxy是headerLoadingLayout与footerLoadingLayout二者的代理，在state的流转过程中，通过LoadingLayoutProxy的调用，达到header 和footer两个loadingLayout的同步调用。<br>LoadingLayout基类已经实现了基本的layout，我们自己定制的子类（例如CustomLoadingLayout）,对里面的动画，文案等进行定制即可，基于ILoadingLayout接口完全重写一个新的,目前看不行，一方面PullToRefreshBase控件内部很多地方强转到LoadingLayout。而且LoadingLayout基类（abstract类）预留了stated的回调抽象方法，供子类实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected abstract void onLoadingDrawableSet(Drawable imageDrawable);</div><div class="line"></div><div class="line">protected abstract void onPullImpl(float scaleOfLayout);</div><div class="line"></div><div class="line">protected abstract void pullToRefreshImpl();</div><div class="line"></div><div class="line">protected abstract void refreshingImpl();</div><div class="line"></div><div class="line">protected abstract void releaseToRefreshImpl();</div><div class="line"></div><div class="line">protected abstract void resetImpl();</div></pre></td></tr></table></figure></p>
<h5 id="2、易用性：-1"><a href="#2、易用性：-1" class="headerlink" title="2、易用性："></a>2、易用性：</h5><ul>
<li>1、使用是否方便，xml和java代码都可以初始化和配置控件，这是控件设计初期就考虑到的</li>
<li>2、我们知道为了保证扩展性，架构上的实现不能过于具体，否则灵活性降低。架构上基于接口和抽象类进行设计，能保证在整体架构内部方便扩展。同时也提供了一些常用的具体实现类，比如PullToRefreshListView FlipLoadingLayout。</li>
<li>3、一些业务上的常用逻辑：（分页计算、footer多个状态的显示等）没有集成，需要二次开发<h5 id="3、扩展性：-1"><a href="#3、扩展性：-1" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5></li>
<li>mRefreshableView的设计理念，可以说让控件理论上可以支持任何视图类（ViewGroup）的下拉刷新操作，比如后期扩展RecyclerView、ViewPager等。</li>
<li>从类图中可以看出 PullToRefreshBase的多层子类，设计合理，层次分明。二次开发中可以选择合适的基类进行扩展。</li>
<li>LoadingLayoutProxy机制的引入，为实现更多LoadingLayout的state流转提供了可能。</li>
<li>模板方法设计模式，基于接口开发，abstract基类，易于扩展和维护<h5 id="4、稳定性：-1"><a href="#4、稳定性：-1" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5>github star 8700多，多个工程中考验，类库内部崩溃率较低。</li>
</ul>
<hr>
<h4 id="三、官方控件：SwipeRefreshLayout"><a href="#三、官方控件：SwipeRefreshLayout" class="headerlink" title="三、官方控件：SwipeRefreshLayout"></a>三、官方控件：SwipeRefreshLayout</h4><h5 id="一两句就能说清："><a href="#一两句就能说清：" class="headerlink" title="一两句就能说清："></a>一两句就能说清：</h5><p>这个控件作为targetView（比如listview）的parentView出现，而且SwipeRefreshLayout只能有一个childView。<br>交互上比较单一，materialDesign风格，loading图标在targetView之上显示，targetView本身可以是任何view，扩展性没的说。</p>
<hr>
<h4 id="四、基于RecyclerView的控件：LRecyclerView"><a href="#四、基于RecyclerView的控件：LRecyclerView" class="headerlink" title="四、基于RecyclerView的控件：LRecyclerView"></a>四、基于RecyclerView的控件：LRecyclerView</h4><p>LRecyclerView是csdn大牛‘一叶飘舟’所著，设计的初衷是为了打造一个更为好用的RecyclerView,一切基于RecyclerView架构搭建。</p>
<ul>
<li>增加了header footer功能（不同于listview，为了扩展性，原生的RecyclerView并不支持header和footer）。</li>
<li>增加了下拉刷新和上拉分页加载功能（这个功能后来被更广泛使用，所以在已有架构上支持了PullScrollView、PullWebView）。最终达到了现有的面貌。</li>
<li>目前我们已经将RecyclerView作为开发的主力控件，那么基于RecyclerView的一个易用性、扩展性和稳定性各方面都均衡的控件，就是我们研究的目标。</li>
</ul>
<h5 id="1、实现原理：-2"><a href="#1、实现原理：-2" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>有了以上的背景，我们对LRecyclerView这个控件会有一个大概认识。我们看下代码分布：<br><img src="https://user-gold-cdn.xitu.io/2018/11/27/1675418224fa413a?w=872&amp;h=1304&amp;f=png&amp;s=316640" alt=""><br>从他的代码分布可以看出，基本是围绕LRecyclerview开展的。类之间的相互关系比较简单，就不用类图展开了。</p>
<p>以下我们将从两个方面分析实现原理 </p>
<ul>
<li>1、LRecyclerView是如何在RecyclerView基础上加上footer和header；</li>
<li>2、LRecyclerView是如何实现下拉刷新和上拉分页加载的。</li>
</ul>
<ol>
<li>LRecyclerView是如何在RecyclerView基础上加上footer和header的：<br>我们知道listview原生支持footer和header，如果我们看过listview的源码的话，就知道他们是在通过adapter实现的，listView在添加header时代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void addHeaderView(View v, Object data, boolean isSelectable) &#123;</div><div class="line"></div><div class="line">  if (mAdapter != null) &#123;</div><div class="line">    //如果是设置header，那么通过HeaderViewListAdapter的代理wrapperadapter来包装真正的adapter</div><div class="line">      if (!(mAdapter instanceof HeaderViewListAdapter)) &#123;</div><div class="line">          wrapHeaderListAdapterInternal();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // In the case of re-adding a header view, or adding one later on,</div><div class="line">      // we need to notify the observer.</div><div class="line">      if (mDataSetObserver != null) &#123;</div><div class="line">          mDataSetObserver.onChanged();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当添加header时，将mAdapter通过方法wrapHeaderListAdapterInternal()包装，HeaderViewListAdapter是mAdapter的代理类，可以看到类内部有成员变量mAdapter,就是ListView的使用者真实创建的adapter。<br>通过以下代码我们就一目了然他的实现原理了：实现原理请参考注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</div><div class="line">    // Header (negative positions will throw an IndexOutOfBoundsException)</div><div class="line">    int numHeaders = getHeadersCount();</div><div class="line">    //如果是position指向header，那么从mHeaderViewInfos返回对应view</div><div class="line">    if (position &lt; numHeaders) &#123;</div><div class="line">        return mHeaderViewInfos.get(position).view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Adapter</div><div class="line">    final int adjPosition = position - numHeaders;</div><div class="line">    int adapterCount = 0;</div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        adapterCount = mAdapter.getCount();</div><div class="line">        //如果是position指向mAdapter实际列表数据，那么调用mAdapter.getView</div><div class="line">        if (adjPosition &lt; adapterCount) &#123;</div><div class="line">            return mAdapter.getView(adjPosition, convertView, parent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果是position指向footer，那么从mFooterViewInfos返回对应view</div><div class="line">    // Footer (off-limits positions will throw an IndexOutOfBoundsException)</div><div class="line">    return mFooterViewInfos.get(adjPosition - adapterCount).view;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时getCount getItemType getItem等实现均对 footer和header进行了考虑，这样包装类封装了mAdapter本身和 footer header，将他们作为一个整体提供给listview。<br>本控件的作者借鉴了这个思路，设计了代理类LRecyclerViewAdapter，类里类似的也含有mInnerAdapter实际的adapter，mHeaderViews和mFooterViews则用于保存信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">    //分别RefreshHeader header footer三种类型返回不同的ViewHolder</div><div class="line">    //这里RefreshHeader没有像PullRefreshView一样作为listview之外的view存在，而是放入</div><div class="line">    //adapter内部让listview(RecyclerView)一起加载。</div><div class="line">    //如何虽手势控制RefreshHeader的Layout，后面详细说。</div><div class="line">    if (viewType == TYPE_REFRESH_HEADER) &#123;</div><div class="line">        return new ViewHolder(mRefreshHeader.getHeaderView());</div><div class="line">    &#125; else if (isHeaderType(viewType)) &#123;</div><div class="line">        return new ViewHolder(getHeaderViewByType(viewType));</div><div class="line">    &#125; else if (viewType == TYPE_FOOTER_VIEW) &#123;</div><div class="line">        return new ViewHolder(mFooterViews.get(0));</div><div class="line">    &#125;</div><div class="line">    return mInnerAdapter.onCreateViewHolder(parent, viewType);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和listview的HeaderViewListAdapter一样，LRecyclerViewAdapter也是类似的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int getItemCount() &#123;</div><div class="line">    if (mInnerAdapter != null) &#123;</div><div class="line">        //此处+1，是考虑到RefreshHeader，就是说header和RefreshHeader是不同的功能，可能同时出现</div><div class="line">        //而footer作为一般的footer或者上拉加载的footer，只会出现一种</div><div class="line">        return getHeaderViewsCount() + getFooterViewsCount() + mInnerAdapter.getItemCount() + 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return getHeaderViewsCount() + getFooterViewsCount() + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在阅读以上代码时，大家不免会有个疑问，LRecyclerView的使用上并不像listview那样简练，LRecyclerView在设置adapter时，需要手动创建innerAdapter和wrapperadapter，将innerAdapter包裹进WrapperAdapter后设置给LRecyclerView；反观listview会根据header/footer使用情况自动创建wrapperadapter,使用者并不知道代理类的存在。此处的设计在文章的最后会阐述我的一些看法。</p>
<ol>
<li>LRecyclerView是如何实现下拉刷新和上拉分页的</li>
</ol>
<ul>
<li>如何下拉刷新：LRecyclerView下拉刷新也是是通过onInterceptTouchEvent和onTouchEvent来实现的，具体的实现和PullRefreshView类似，此处不单独分析了。通过接口IRefreshHeader来控制RefreshHeader的状态改变。刷新后通过OnRefreshListener接口通知业务刷新数据。</li>
<li>如何分页加载：利用RecyclerView的onScrolled回调，控件滑动过程中不断回调此方法，通过判断是否滑动到最底部来决定是否上拉加载，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (mLoadMoreListener != null &amp;&amp; mLoadMoreEnabled) &#123;</div><div class="line">    int visibleItemCount = layoutManager.getChildCount();</div><div class="line">    int totalItemCount = layoutManager.getItemCount();</div><div class="line">    if (visibleItemCount &gt; 0</div><div class="line">            &amp;&amp; lastVisibleItemPosition &gt;= totalItemCount - 1</div><div class="line">            &amp;&amp; totalItemCount &gt; visibleItemCount</div><div class="line">            &amp;&amp; !isNoMore</div><div class="line">            &amp;&amp; !mRefreshing) &#123;</div><div class="line"></div><div class="line">        mFootView.setVisibility(View.VISIBLE);</div><div class="line">        if (!mLoadingData) &#123;</div><div class="line">            mLoadingData = true;</div><div class="line">            //更新footerView的状态</div><div class="line">            mLoadMoreFooter.onLoading();</div><div class="line">            if (mWrapAdapter != null) &#123;</div><div class="line">                //回调业务 分页加载更多</div><div class="line">                mWrapAdapter.loadMore(mLoadMoreListener);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2、易用性：-2"><a href="#2、易用性：-2" class="headerlink" title="2、易用性："></a>2、易用性：</h5><p>此控件将IRefreshHeader和ILoadMoreFooter两个接口拆分，相比较PullRefreshView对于上拉footer的处理更加直接和便捷。两个不同接口更加适应于分页加载的不同状态。并且不同状态的文案是可以定制的：</p>
<p><code>public void setFooterViewHint(String loading, String noMore, String noNetWork)</code></p>
<p>这样对于上拉分页的情况，不需要业务再对控件做二次开发（PullRefreshView需要），是更加易用的。<br>但是业务上对于分页加载需求的逻辑负担还是比较大，集中在以下两点</p>
<ul>
<li>1）分页pageNumber pageSize等需要业务维护，而这些逻辑都是通用的。</li>
<li>2）判断是否需要加载更多，还是没有更多数据，的逻辑业务需要维护，这些逻辑也是通用的。</li>
</ul>
<p>基于此，我们针对LRecyclerView的分页加载功能做了二次封装。这两个问题都可以在wrapperAdapter中通过统一的逻辑来处理，只不过业务加载后要要通过接口ILoadCallback通知控件：</p>
<p>我们自定义的ILoadCallback接口，业务在onLoadMore处理完后，要根据返回的结果调用的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface ILoadCallback &#123;</div><div class="line">    //业务loadMore的结果 success和failue都通知wrapperAdapter</div><div class="line">    </div><div class="line">    void onSuccess();</div><div class="line"></div><div class="line">    void onFailure();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WrapperAdapter对接口调用的处理：维护pageNumber,和footer是否加载更多等状态<br>此前这些逻辑都需要重复写在业务代码中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private ILoadCallback mLoadCallback = new ILoadCallback() &#123;</div><div class="line">  @Override</div><div class="line">  public void onSuccess() &#123;</div><div class="line">      notifyDataSetChanged();</div><div class="line">      if ((mInnerAdapter.getItemCount() % getItemNumInPage()) == 0)&#123;</div><div class="line">        //判断还需要加载下一页</div><div class="line">          mCurrentPage++;</div><div class="line">          if (mLRecyclerView != null) &#123;</div><div class="line">              mLRecyclerView.setNoMore(false);</div><div class="line">          &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">        //判断没有更多数据，并将footerview设置为noMore</div><div class="line">          if (mLRecyclerView != null) &#123;</div><div class="line">              mLRecyclerView.setNoMore(true);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      if (mLRecyclerView != null) &#123;</div><div class="line">          mLRecyclerView.refreshComplete(getItemNumInPage());</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onFailure() &#123;</div><div class="line">    //失败时统一提示，并集成再次点击，多加载一次的功能</div><div class="line">      mLRecyclerView.refreshComplete(getItemNumInPage());</div><div class="line">      mLRecyclerView.setOnNetWorkErrorListener(new OnNetWorkErrorListener() &#123;</div><div class="line">          @Override</div><div class="line">          public void reload() &#123;</div><div class="line">              if (mLoadMoreCallback != null) &#123;</div><div class="line">                  mLoadMoreCallback.onLoadMore(mCurrentPage, getItemNumInPage(), mLoadCallback);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>经过这样进一步的封装，LRecyclerView的使用易用性进一步提升了。可以说比PullRefreshView本身的易用性要强一些，尤其是在分页加载的逻辑封装方面</p>
<h5 id="3、扩展性：-2"><a href="#3、扩展性：-2" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5><p>PullRefreshView自身支持所有ViewGroup的下拉刷新。我觉得LRecyclerView与PullRefreshView相比，在架构上牺牲了一些扩展性，但易用性有很大的提升，应用场景有较强的针对性。实际使用中，利用Recyclerview自身很强的扩展性，就可以应付大部分使用场景。</p>
<h5 id="4、稳定性：-2"><a href="#4、稳定性：-2" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5><p>github star数在2000以上，issue修改及时，在二次开发的过程中，上拉分页的footer状态维护有些小bug，但是基本不影响稳定性，产品上线后控件的崩溃率一直很低。基本可以放心使用。</p>
<h5 id="5、其他的思考："><a href="#5、其他的思考：" class="headerlink" title="5、其他的思考："></a>5、其他的思考：</h5><p>wrapperAdapter的设置：<br>文中提及过的，WrapperAdapter和innerAdapter都需要在业务上新建有点鸡肋（因为可以在LRecyclerView setAdatper时，内部创建wrapperAdapter，和listview的做法一致），作者这么做的原因，我想可能是WrapperAdapter承载了很多框架业务的功能，那么业务持有此变量可以非常方便的调用WrapperAdapter的接口。在我看来，较为合理的方式还是将WrapperAdapter不对外暴露，将原来WrapperAdapter的对外接口改到LRecyclerView来实现。这样用户调用方便，同时对控件的封装性更好。<br>此封装方案我在demo project中试验过，没有太大问题，可能有些细节需要处理，后续我们的控件二次开发会采用这种方式。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在我们自己的项目演进过程中，经历从xlistview到PullRefreshView到LRecyclerView的转变，所以对各自控件的优点、劣势，适用范围都比较清楚。之所以最终将LRecyclerView最为主力控件，除了文中提到的原因以外，还有比较关键的一点：在分页加载的二次开发中，LRecyclerView给予了足够的扩展性，也为今后我们功能的拓展提供了足够的信心。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/JVM GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/JVM GC/" itemprop="url">JVM GC原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象的四种引用类型"><a href="#对象的四种引用类型" class="headerlink" title="对象的四种引用类型"></a>对象的四种引用类型</h3><h3 id="JVM-GC原理"><a href="#JVM-GC原理" class="headerlink" title="JVM GC原理"></a>JVM GC原理</h3><h3 id="LeakCanary开源库-对泄漏的分析原理（haha库）"><a href="#LeakCanary开源库-对泄漏的分析原理（haha库）" class="headerlink" title="LeakCanary开源库 对泄漏的分析原理（haha库）"></a>LeakCanary开源库 对泄漏的分析原理（haha库）</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/ClassLoader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/ClassLoader/" itemprop="url">ClassLoader原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/Robust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/Robust/" itemprop="url">Robust原理及修复范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/LNMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/LNMP/" itemprop="url">LNMP环境搭建 及多端口访问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Linux下WebServer的搭建"><a href="#Linux下WebServer的搭建" class="headerlink" title="Linux下WebServer的搭建"></a>Linux下WebServer的搭建</h3><h4 id="linux-初始化及登录"><a href="#linux-初始化及登录" class="headerlink" title="linux 初始化及登录"></a>linux 初始化及登录</h4><p>使用的linux服务器供应商：<a href="https://bwh8.net/" target="_blank" rel="external">https://bwh8.net/</a></p>
<ul>
<li><p>重新安装centos 6 x86_64</p>
</li>
<li><p>执行shadowsocks server端的脚本：<a href="https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocks" target="_blank" rel="external">https://kiwivm.64clouds.com/main-exec.php?mode=extras_shadowsocks</a>  根据提示即可配置ss客户端</p>
</li>
<li><p>安装ddos deflate 防止/减轻 ddos攻击</p>
<p><a href="https://www.jianshu.com/p/f1e44408c195" target="_blank" rel="external">https://www.jianshu.com/p/f1e44408c195</a></p>
</li>
<li><p>为了linux服务器的安全，采用以下登录策略</p>
<ol>
<li><p>非root登录 创建普通账户： root下，adduser wangbo ;   passwd wangbo;  则wangbo用户根目录在/home/wangbo;</p>
<p>将root账户和普通账户的密码区分开 </p>
</li>
<li><p>采用普通用户秘钥登录（公私钥）登录</p>
<p><a href="https://blog.csdn.net/asahinokawa/article/details/84324526" target="_blank" rel="external">https://blog.csdn.net/asahinokawa/article/details/84324526</a> 具体可以参考文章</p>
<p>备注：</p>
<ul>
<li><p>1）公私钥的产生ssh-keygen可以在客户端，也可以在linux端，都在.ssh目录下（如果是linux端，需要是home/wangbo/.ssh目录下，而不是root目录下）</p>
<p>（一般是客户端产生，这样不同客户端产生的私钥/公钥对，可以对应同一台linux；这样linux保存多个公钥，客户端保存各自私钥）</p>
</li>
<li><p>2）私钥放在客户端，linux端保存公钥 </p>
</li>
<li><p>3）利用ssh config管理的方式，可以用别名直接登录linux </p>
</li>
<li><p>4）linux端 把公钥串 复制到.ssh/authorized_keys文件中，多个公钥依次复制，这样可以客户端无需密码，直接ssh alias（别名）登录 </p>
</li>
<li><p>5）删除原来在客户端.ssh/config中配置的host * interval 轮询发送数据包的机制</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="tomcat-mysql-搭建"><a href="#tomcat-mysql-搭建" class="headerlink" title="tomcat mysql 搭建"></a>tomcat mysql 搭建</h3><ul>
<li><p>jdk的安装</p>
<p>因为tomcat这套webserver是基于java的，依赖于jdk环境，我们先安装jdk</p>
<ul>
<li><p>jdk下载</p>
<p>如果不用yum或者npm方式自动安装，我们采用自行wget下载的方式，需要注意的是：</p>
<p>wget + oracle官网上找到的tar.gz包下载地址   这种方式：</p>
<figure class="highlight plain"><figcaption><span>https://download.oracle.com/otn-pub/java/jdk/8u191-b12/2787e4a523244c269598db4e85c51e0c/jdk-8u191-linux-i586.tar.gz ```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">  你通过这个命令下载下来的包不是完整的。（好像官网下载默认是不授权的）</div><div class="line"></div><div class="line">  所以我们必须先下载，再上传到服务器，位置一般是/usr/java/</div><div class="line"></div><div class="line">- 环境变量配置</div><div class="line"></div><div class="line">  ```tar -xzvf jdk-8u191-linux-i586.tar.gz</div></pre></td></tr></table></figure>
<p>解压之后，配置环境变量在 linux中 </p>
<figure class="highlight vim"><figcaption><span>/etc/profile```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>#set java environment<br>JAVA_HOME=/usr/java/jdk1.7.0_79<br>JRE_HOME=/usr/java/jdk1.7.0_79/jre<br>CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib<br>PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin<br>export JAVA_HOME JRE_HOME CLASS_PATH PATH</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">出现以下，说明jdk环境配置成功</div></pre></td></tr></table></figure>
<p>[root@localhost bin]# java -version<br>java version “1.8.0_191”<br>Java(TM) SE Runtime Environment (build 1.8.0_191-b12)<br>Java HotSpot(TM) Client VM (build 25.191-b12, mixed mode)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- tomcat 安装</div><div class="line"></div><div class="line">  - tomcat下载</div><div class="line"></div><div class="line">    wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.12/bin/apache-tomcat-9.0.12.tar.gz</div><div class="line"></div><div class="line">    解压文件：tar -xzvf apache-tomcat-9.0.12.tar.gz</div><div class="line"></div><div class="line">    位置我选择在/home/wangbo/下，用户目录中</div><div class="line"></div><div class="line">  - tomcat启动</div><div class="line"></div><div class="line">    执行</div><div class="line"></div><div class="line">    ```apache-tomcat-9.0.14/bin/startup.sh</div></pre></td></tr></table></figure>
<p>我们在 <a href="http://yourip:8080" target="_blank" rel="external">http://yourip:8080</a> 就可以看到 tomcat的启动页面了</p>
<p><img src="https://i.imgur.com/stjQ17s.png" alt=""></p>
</li>
<li><p>tomcat 目录结构</p>
<p>bin/ : 各种脚本  startup stop restart等</p>
<p>logs/: 日志信息在此处查询</p>
<p>webapps/: webserver中各种webapp都是部署在此文件夹下了 </p>
<ul>
<li>其下的ROOT目录: 是8080端口的默认位置，我们看到的‘三脚猫’页面就在此处部署</li>
<li>其他目录：我们可以新建folder，来部署新的webapp，访问地址就是<a href="http://youip/folder:8080" target="_blank" rel="external">http://youip/folder:8080</a></li>
</ul>
</li>
</ul>
</li>
<li><p>mysql 安装</p>
<ul>
<li><p>基于centos6系统的mysql安装指南：</p>
<p><a href="https://segmentfault.com/a/1190000003049498" target="_blank" rel="external">https://segmentfault.com/a/1190000003049498</a></p>
<p>因为之前安装失败后，没有卸载mysql干净，会导致安装过程中有冲突，</p>
<p>附上卸载指南：<a href="https://www.jianshu.com/p/3f263c3c3d63" target="_blank" rel="external">https://www.jianshu.com/p/3f263c3c3d63</a></p>
</li>
<li><p>上一步中命令：service mysqld start ，启动了mysql的server</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[root@localhost wangbo]# mysql</div><div class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</div><div class="line">Your MySQL connection id is 2</div><div class="line">Server version: 5.6.42 MySQL Community Server (GPL)</div><div class="line"></div><div class="line">Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved.</div><div class="line"></div><div class="line">Oracle is a registered trademark of Oracle Corporation and/or its</div><div class="line">affiliates. Other names may be trademarks of their respective</div><div class="line">owners.</div><div class="line">mysql&gt;</div></pre></td></tr></table></figure>
<p>通过mysql命令，就可以通过命令行客户端来访问服务器了。</p>
</li>
<li><p>mysql账户的设置</p>
<p>创建root账户密码：mysqladmin <code>-</code>u root password <em>*</em></p>
<p>登录时：mysql -u root -p<em>*</em></p>
<p>可以参考：<a href="https://www.cnblogs.com/fu-yong/p/9025576.html" target="_blank" rel="external">https://www.cnblogs.com/fu-yong/p/9025576.html</a></p>
</li>
<li><p>mysql重要目录</p>
<ul>
<li>数据库目录：/var/lib/mysql/    databases都在这里</li>
<li>配置文件：/usr/share/mysql   （mysql.server命令及配置文件）</li>
<li>命令行文件：/<code>usr</code>/<code>bin</code>（mysqladmin mysqldump等命令）</li>
<li>启动脚本：/<code>etc</code>/<code>rc.d</code>/<code>init.d</code>/``（启动脚本文件mysql的目录）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="springboot搭建"><a href="#springboot搭建" class="headerlink" title="springboot搭建"></a>springboot搭建</h3><p>启蒙blog <a href="https://www.jianshu.com/p/575990ebb2ba" target="_blank" rel="external">https://www.jianshu.com/p/575990ebb2ba</a></p>
<ul>
<li><p>SpringBoot IDE的搭建</p>
</li>
<li><p>Tomcat 安装及启动</p>
</li>
<li><p>springboot在tomcat上的部署</p>
<ol>
<li><p>部署后报错</p>
<blockquote>
<p>SEVERE: Error deploying web application archive /var/lib/tomcat/webapps/restful-0.0.1-SNAPSHOT.war<br>java.lang.IllegalStateException: ContainerBase.addChild: start: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/restful-0.0.1-SNAPSHOT]]</p>
</blockquote>
</li>
</ol>
<p><strong>这个问题是jdk和tomcat中的servlet版本不一致造成的</strong></p>
<p><em><code>java -version</code></em></p>
<p>openjdk version “1.8.0_191”</p>
<p><code>rpm -qa tomcat</code></p>
<p>tomcat 是7.0版本</p>
<p>tomcat与jdk版本兼容关系</p>
<p>tomcat v7.0——-support——–&gt;Java EE 5 and 6</p>
<p>tomcat v8.0——-support——–&gt;Java EE 5,6 and 7</p>
<p>tomcat v8.5——-support——–&gt;Java EE 5,6 and 7</p>
<p>tomcat v9.0——-support——–&gt;Java EE 5,6,7 and 8</p>
</li>
</ul>
<ol>
<li>重新安装tomcat 9.0</li>
</ol>
<p>卸载yum安装的tomcat， yum -y remove tomcat，卸载之后</p>
<p>这次我们不适用yum安装，采用自行下载安装的方法，这样可以自行选择版本</p>
<p>下载地址：</p>
<p>wget <a href="http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.12/bin/apache-tomcat-9.0.12.tar.gz" target="_blank" rel="external">http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.12/bin/apache-tomcat-9.0.12.tar.gz</a></p>
<p>解压文件：tar -xzvf apache-tomcat-9.0.12.tar.gz </p>
<p>tomcat依赖jre环境，需要先安装jdk，</p>
<p>依照这个流程    <a href="https://blog.csdn.net/qq_36090419/article/details/82787980" target="_blank" rel="external">https://blog.csdn.net/qq_36090419/article/details/82787980</a></p>
<p>重启tomcat既可</p>
<h3 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h3><p>安装mysql（本地mac 下homebrew，）</p>
<p>远程登录服务器端mysql：<a href="https://www.cnblogs.com/weifeng1463/p/7941625.html" target="_blank" rel="external">https://www.cnblogs.com/weifeng1463/p/7941625.html</a></p>
<p>navicat 配置，远程控制服务器 mysql 及本地mysql</p>
<p>防火墙开放3306端口：/sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT</p>
<p>Idea中，配置mysql的依赖：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line"></div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;5.1.46&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure>
<p>开始会标红，选择compile的task后，会自动下载依赖，</p>
<p>.yml文件中，mysql配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">spring:</div><div class="line">  profiles:</div><div class="line">    active: prod</div><div class="line"></div><div class="line">  datasource:</div><div class="line">    driver-class-name: com.mysql.jdbc.Driver</div><div class="line">    url: jdbc:mysql://localhost:3306/restful</div><div class="line">    username: root</div><div class="line">    password: 575986wa!</div><div class="line"></div><div class="line">  jpa:</div><div class="line">    hibernate:</div><div class="line">      ddl-auto: create</div><div class="line">    show-sql: true</div></pre></td></tr></table></figure>
<p><code>com.mysql.jdbc.Driver</code>开始标红，pom.xml右键 – maven– reimport 就ok了</p>
<p>开始springboot中操作数据库mysql：</p>
<p>jpa hiberation 框架原理 主要参考：<a href="http://blog.didispace.com/springbootdata2/" target="_blank" rel="external">http://blog.didispace.com/springbootdata2/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">bo.wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bo.wang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
