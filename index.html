<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-ARouter" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/15/ARouter/" class="article-date">
  <time datetime="2017-09-14T16:00:00.000Z" itemprop="datePublished">2017-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/15/ARouter/">ARouter:Anroid组件化方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>##ARouter:Anroid组件化方案</p>
<p>###组件化的引入<br>一般认为组件化是业务和人员庞大后，团队协作的基础。也是业务庞大后代码架构的必经之路。</p>
<p>####组件化可以带来<br>1.降低代码耦合度<br>（高耦合的代码随着项目的复杂性不断增加，最后会变成一团浆糊，功能A改动会导致功能B、C也要改动，牵一发动全身。<br>辛苦写的功能A耦合着其他功能的代码，新的需求没办法直接复用。）</p>
<p>2.架构更清晰<br>（整个工程像是功能的堆砌，没有合理的层次、结构。<br>工程模块越来越大，开发中解决冲突花费大量时间， 实现方案替换困难，程序难以扩展）</p>
<p>####组件化中要解决的问题<br>1.依赖关系<br>依赖倒置，面向接口编程<br>2.调用方式<br>扩展性，易于管理</p>
<p>####组件化模块间调用的场景包括<br>1.Activity的页面跳转<br>2.接口服务调用<br>3.Fragment获得实例</p>
<p>####以前的方案<br>1.Activity跳转<br>Intent<br>显式调用：模块依赖<br>隐式调用：Manifest 扩展性差，管理不方便<br>2.EventBus 容易被滥用<br>不清楚谁调用，也不清楚请求被谁接受；注册管理困难；</p>
<hr>
<p>###业内Route方案比较<br>| 方案对比 | DeepLinkDispatch |ARouter |天猫统跳协议 |ActivityRouter |<br>|——–|——–|——-|——-|——-|<br>|路由注册 | Module手动注册 |注解自动注册 | Manifest配置|注解自动注册|<br>|路由查找        |  路由表      |路由表       |系统Intent       |路由表       |<br>|动态拦截        |  不支持    |  支持     |  不支持     |   支持    |<br>|服务接口        |  不支持      |   支持    | 不支持      | 不支持      |<br>|结果返回        |onActivityResult|onActivityResult|onActivityResult|onActivityResult|<br>|InstantRun        |  不支持      |支持       |支持       |支持       |</p>
<hr>
<p>###ARouter最佳实践<br>ARouter的配置和初始化，见ARouter的github官方网站<br>在专车、租车app中，典型的应用场景为<br>1.从外部URL映射到内部页面，以及参数传递和解析<br>2.跨模块页面跳转，模块间解耦<br>3.拦截跳转过程，处理登录、埋点等逻辑<br>4.跨模块API调用，通过控制反转来做组件间解耦</p>
<p>####应用内页面跳转<br>调用方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//  跳转并携带参数</div><div class="line">ARouter.getInstance().build(&quot;/test/activity1&quot;)</div><div class="line">			.withInt(&quot;key1&quot;, 666L)</div><div class="line">			.withString(&quot;girl&quot;, &quot;888&quot;)</div><div class="line">			.withObject(&quot;key4&quot;, new TestObj(&quot;Jack&quot;, &quot;Rose&quot;))</div><div class="line">			.navigation();</div></pre></td></tr></table></figure></p>
<p>注册方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 为每一个参数声明一个字段，并使用 @Autowired 标注</div><div class="line">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</div><div class="line">@Route(path = &quot;/test/activity1&quot;)</div><div class="line">public class Test1Activity extends Activity &#123;</div><div class="line">    @Autowired</div><div class="line">    public String name;</div><div class="line">    @Autowired</div><div class="line">    int age;</div><div class="line">    @Autowired(name = &quot;girl&quot;) // 通过name来映射URL中的不同参数</div><div class="line">    String boy;</div><div class="line">    @Autowired</div><div class="line">    TestObj obj;    // 支持解析自定义对象，URL中使用json传递</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	super.onCreate(savedInstanceState);</div><div class="line">	ARouter.getInstance().inject(this);</div><div class="line"></div><div class="line">	// ARouter会自动对字段进行赋值，无需主动获取</div><div class="line">	Log.d(&quot;param&quot;, name + age + boy);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果所有的页面都使用ARouter的页面path跳转，可能出现调用方不知道跳到哪里，被调用方不知道是谁调起的情况，这也是完全解耦带来的弊端（类似于EventBus的过度使用），而且对于编译时间的影响也很大。<br>建议：<br>1 模块内部跳转采用原生方式，模块对外采用path跳转，模块维护对外(path,target） MAP<br>2 采用代码糖方式（所有跳转都由ARouter管理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Route(Path=&quot;/message/center&quot;,name=&quot;消息中心&quot;)</div><div class="line">public class MessageCenterActivity&#123;</div><div class="line">	public static void launch(Activity c)&#123;</div><div class="line">    	ARouter.getInstance().build(&quot;/message/center&quot;).navigation(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####通过URI跳转（解析web、第三方应用跳转）<br>SchemeFilterActivity接受URI后，ARouter统一解析跳转协议，此协议与应用内部native跳转相同，保证协议的统一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可</div><div class="line">public class SchameFilterActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">	Uri uri = getIntent().getData();</div><div class="line">	ARouter.getInstance().build(uri).navigation();</div><div class="line">	finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SchemeFilterActivity的注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.activity.SchameFilterActivity&quot;&gt;</div><div class="line">	&lt;!-- Schame --&gt;</div><div class="line">	&lt;intent-filter&gt;</div><div class="line">	    &lt;data</div><div class="line">		android:host=&quot;host&quot;</div><div class="line">		android:scheme=&quot;ucar2015&quot;/&gt;</div><div class="line"></div><div class="line">	    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</div><div class="line"></div><div class="line">	    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</div><div class="line">	    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</div><div class="line">	&lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure></p>
<p>举例：<br>外部Url跳转链接：<br>ucar2015://host/test/activity1?name=alex&amp;age=18&amp;boy=true</p>
<p>####模块间通讯解耦：控制反转<br>除了模块间页面跳转，模块之间的调用通信也很常见。比如一些反向依赖，底层的逻辑抛到上层处理，或者模块A需要调用模块B的服务。</p>
<p>以往的处理方式只能是模块都耦合在一起，相互调用和影响。我们也可以利用依赖反转，将各个模块都依赖于IoC容器，这样模块之间的耦合被解开了。ARouter本身就是一个IoC容器，IProvider提供的是一种Service，此处的Service类似于服务端的Service，提供的是一种服务，而不是Android的Service。有点类似于AIDL的调用方式。<br>优势：<br>1 模块间解耦<br>2 模块可独立打包<br><img src="http://oqjv79a9c.bkt.clouddn.com/%E5%9B%BE%E7%89%87%201.png" alt=""><br>Ioc容器定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明接口,其他组件通过接口来调用服务</div><div class="line">public interface HelloService extends IProvider &#123;</div><div class="line">    String sayHello(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口实现层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 实现接口</div><div class="line">@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)</div><div class="line">public class HelloServiceImpl implements HelloService &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String name) &#123;</div><div class="line">	return &quot;hello, &quot; + name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(Context context) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    @Autowired</div><div class="line">    HelloService helloService;</div><div class="line"></div><div class="line">    @Autowired(name = &quot;/service/hello&quot;)</div><div class="line">    HelloService helloService2;</div><div class="line"></div><div class="line">    HelloService helloService3;</div><div class="line"></div><div class="line">    HelloService helloService4;</div><div class="line"></div><div class="line">    public Test() &#123;</div><div class="line">	ARouter.getInstance().inject(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void testService() &#123;</div><div class="line">	 // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</div><div class="line">	 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</div><div class="line">	helloService.sayHello(&quot;Vergil&quot;);</div><div class="line">	helloService2.sayHello(&quot;Vergil&quot;);</div><div class="line"></div><div class="line">	// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</div><div class="line">	helloService3 = ARouter.getInstance().navigation(HelloService.class);</div><div class="line">	helloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation();</div><div class="line">	helloService3.sayHello(&quot;Vergil&quot;);</div><div class="line">	helloService4.sayHello(&quot;Vergil&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>四、ARouter源码分析<br>定义：ARouter是Android平台中对页面、服务提供路由功能的中间件。<br>优势：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%201.png" alt=""><br>代码结构：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%202.png" alt=""><br>ARouter的依赖工程分为Annotation compiler Api三部分，Annotation保存自定义注解，Compiler 保证在编译期，按照注解、规则生成帮助代码。Api是客户端实际调用。</p>
<p>下面从编译、运行时初始化、调用三方面分析ARouter的实现方案。</p>
<p>#####编译阶段：<br>compiler自动生成的代码（路由清单的生成）<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%203.png" alt=""><br>ARouter$$Group$$service和ARouter$$Group$$test分别是分组service和test的组内清单，可以想象成1班和2班的学生名单。<br>ARouter$$Root$$app是组别的清单列表，可以想象成班级清单，1班和2班。</p>
<p>这也体现了分组归类、按需加载的原则，初始化只加载ARouter$$Root$$app，首次调用时把该group内所有内容加载，并内存缓存。</p>
<p>注：PROVIDER在Providers类别里有一份，在Group里也有一份，provider的启动也有两种。</p>
<p>看一下：BlankFragment$$ARouter$$Autowired，了解入参自动注入如何完成。</p>
<p>通过这些编译产物，我们可以看到以下几点：<br>1 ARouter的自动注册，是通过初始化时加载这些路由清单完成的。<br>2 我们可以通过两种方式找到PROVIDER的节点。<br>3 页面自动赋值功能，在页面被打开时，调用了ISyringe接口的inject方法</p>
<p>#####ARouter初始化过程 Init<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%204.png" alt=""><br>在LogisticsCenter.init()完成了初始化，可以看到初始化时对红框内的路由表加载并缓存在wareHouse里，wareHouse类如下：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%205.png" alt=""><br>在wareHouse里，不仅帮我们保存了路由清单，还给我们提供了缓存。也就是说同一个目标（RouteMeta、IProvider、IInterceptor）仅会在第一次使用的时候创建一次。</p>
<p>#####API调用过程<br>举例：ARouter.getInstance().build(“/test/activity”).navigation()</p>
<p>走到_ARouter.getInstance().navigation()方法，核心调用：<br>1）    找到并填充PostCard：<br>LogisticsCenter.completion(postCard) 分组按需找到path对应的Postcard并填充携带信息，对于Provider类型则懒加载其对象，并缓存。<br>2）核心跳转：<br>跳转逻辑真正在_navigation()，支持三种：<br>1 Activity跳转，调用原生intent跳转<br>2 Provider调用，返回Service实例<br>3 Fragment，返回新建的Fragment实例</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/15/ARouter/" data-id="cj7lij7xm00004fx3ktegpm6y" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码及架构/">代码及架构</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-perf-memory" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/06/06/perf-memory/" class="article-date">
  <time datetime="2017-06-05T16:00:00.000Z" itemprop="datePublished">2017-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/06/perf-memory/">内存问题的解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="内存可以引发的问题"><a href="#内存可以引发的问题" class="headerlink" title="内存可以引发的问题"></a>内存可以引发的问题</h4><ol>
<li>程序卡顿，响应速度慢（JVM频繁调用GC，造成主线程卡顿）</li>
<li>崩溃率上升（OOM问题，此类问题各场景都可能出现，难于定位和复现）</li>
<li>后台被kill概率升高</li>
<li>图片加载失败（图片多的场景， oom往往被loader catch）</li>
</ol>
<h5 id="通过如下的5R方法来对ANDROID内存进行优化："><a href="#通过如下的5R方法来对ANDROID内存进行优化：" class="headerlink" title="通过如下的5R方法来对ANDROID内存进行优化："></a>通过如下的5R方法来对ANDROID内存进行优化：</h5><p>1.Reckon（计算）<br>首先需要知道你的app所消耗内存的情况，<br>2.Reduce（减少）<br>消耗更少的资源<br>3.Reuse（重用）<br>Cache的使用<br>4.Recycle（回收）<br>资源利用后的释放，回收；防止内存泄露<br>5.Review（检查）<br>回顾检查你的程序，看看设计或代码有什么不合理的地方。</p>
<h5 id="Reckon-（计算）"><a href="#Reckon-（计算）" class="headerlink" title="Reckon （计算）"></a>Reckon （计算）</h5><h6 id="内存的监控：我们监控的内存究竟是分配的哪部分？"><a href="#内存的监控：我们监控的内存究竟是分配的哪部分？" class="headerlink" title="内存的监控：我们监控的内存究竟是分配的哪部分？"></a>内存的监控：我们监控的内存究竟是分配的哪部分？</h6><p>一般Java在内存分配时会涉及到以下区域：<br>寄存器（Registers）：速度最快的存储场所，因为寄存器位于处理器内部，我们在程序中无法控制<br>栈（Stack）：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中；栈的大小和个数是受限制的。方法的调用顺序按照先进后出的顺序存入栈中，程序的运行由栈维护<br>堆（Heap）：堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器（GC）来管理。<br>静态域（static field）： Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量<br>常量池（constant pool）：虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。</p>
<p>Java数据类型的分类如图：<br><img src="http://images.cnitblog.com/blog/488573/201309/15165530-8a570626bf3741a1b4937759a89a5a93.png" width="660" height="300"><br>图一<br><strong>内存的监控就是对堆内存的监控，不仅因为其大小最大，还考虑到GC的回收情况影响整体内存的大小</strong></p>
<h6 id="监控方法："><a href="#监控方法：" class="headerlink" title="监控方法："></a>监控方法：</h6><p>Android Studio之前，通过adb shell dumpsys meminfo com.szzc.ucar.pilot 打印app内存信息<br><img src="http://oqjv79a9c.bkt.clouddn.com/1.png" width="460" height="300"><br>图二<br>通过不断的打印，监控内存的走势。<br>或者Android Device Monitor中的Update Heap，也是监控allocated和free的内存，但是缺点都是无法实时监控，可视化不够。</p>
<p>现有的监控：<br>1 性能监控系统<br>app轮询，获得指定进程的内存值，并上传dreport，同时上传页面、点击事件等信息<br>dreport统计数据后通过内存曲线展示，该监控方式做到可视化和结果固化，方便分析不同场景下的内存表现趋势，可以多版本比较，用于日常和线上监控。<br>2 Android Monitor监控<br><img src="http://oqjv79a9c.bkt.clouddn.com/2.png" width="460" height="300"><br>图三<br>图中free和allocated 内存大小，一一对应于图二meminfo的红框内的内存信息。只是更加直观<br>这种监控方式，一般是在开发过程中，或oom复现debug 等一些有目的性的内存监控，用来观察，比如：<br>1）实时查看App的内存分配情况、走势情况<br>2）发现大内存对象分配的场景<br>3）快速判断App是否由GC造成卡顿<br>4）发现内存不断增长的场景 初步判断泄漏</p>
<h5 id="Reduce（减少）"><a href="#Reduce（减少）" class="headerlink" title="Reduce（减少）"></a>Reduce（减少）</h5><h6 id="知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？"><a href="#知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？" class="headerlink" title="知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？"></a>知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？</h6><p>先看几个概念<br><code>Runtime rt=Runtime.getRuntime();
        long maxMemory=rt.maxMemory();</code><br>maxMemory指系统能分配给app的最大内存，不同系统不一样，且与<code>android:largeHeap=&quot;true&quot;</code>有关，代表app能使用的最大内存；<br>而app启动后需要多少，申请多少（totalMemory），所以totalMemory一直在增长或波动，但totalMemory &lt; maxMemory<br>totalMemory包含哪些呢？看到图二中最后一行，TOTAL就表示totalMemory, 其中包含 Native Heap以及  Dalvik Heap<br>关系如下：<br><code>Max &gt; Total = (Native free + allocated) + (Dalvik free + allocated)</code><br>（其中free代表申请的totalMemory中未被分配的内存，申请时的预留和GC回收导致的剩余都是free的来源）<br>如果图二的手机max = 128M，当 Total 临界 Max 时，再次申请heap内存时，OOM发生了。</p>
<p>从上述公式可以看出，评判allocated内存的合理范围，不仅要考虑maxMemory的大小，还要给native heap留出余量。<br>根据经验来讲，如果dalvik层的内存超过maxMemory的2/3时，OOM的概率就很高了。而在启动后和使用中，dalvik层的内存处于maxMemory的1/3左右较为合理。</p>
<h6 id="如何分析大内存？"><a href="#如何分析大内存？" class="headerlink" title="如何分析大内存？"></a>如何分析大内存？</h6><p>有了判断的标准，我们需要在app启动、使用过程中各场景，监控内存的大小。如果发现内存过大，直接通过内存快照分析。<br>Studio –&gt; Android Monitor –&gt; Dump Java Heap可以直接导出prof文件（导出前主动GC），通过hprof-conv转换，在MAT中分析<br>MAT有很多的分析工具，我总结了我认为的较为实用几个<br><img src="http://oqjv79a9c.bkt.clouddn.com/MAT%20Histogram.png" width="460" height="300"><br>在Overview页面，可以直观看到app的内存占用值和比例；</p>
<p>在Histograme页面直接按照Retained Heap排序，从最大开始逐个分析</p>
<p>也可以通过Dominator Tree看到不同class的内存占用比例，按照优先级分析，例如最高Bitmap；<br>接下来在Histograme柱状图列表中，搜索Bitmap，结果为class列表，右键list objects –&gt; with incomming references,可以看到相关类的对象列表，通过Path To GCRoot 查找到bitmap究竟是什么对象，存在是否合理。<br><img src="http://oqjv79a9c.bkt.clouddn.com/MAT%20GcRoot.png" width="400" height="300"><br>不合理的Bitmap有以下特征：<br>1）上个页面的大背景图<br>2）bitmap大小明显大于其容器的大小<br>3）浮窗、蒙版、背景等代码可以实现的效果</p>
<p>对于这三种情况，<br>1）是否有页面泄漏，imageView.setImageDrawable(null)<br>2) imageLoader 或其他加载器，要传入view容器宽高，以便bitmap裁剪<br>3）BackgroundColor 自定义View  9patch 等方式实现，避免整张bitmap图</p>
<p>以上只是拿Bitmap举了例子，除了bitmap之外，内存快照里还会有其他内存大户，需要用类似的方法进行分析。</p>
<h5 id="Reuse（重用）"><a href="#Reuse（重用）" class="headerlink" title="Reuse（重用）"></a>Reuse（重用）</h5><p>如果一些内存大户必须存在，那考虑是否可以缓存或重用<br>1 Bitmap重用 使用第三方库加载bitmap，第三方库一般采用二级或三级缓存，可以对不再使用的bitmap及时释放，重用已有的内存<br>2 使用AdapterView、viewHolder复用<br>3 一些全局使用的大数据，如果可以全局公用，不采用每次获取。</p>
<h5 id="Recycle（回收）"><a href="#Recycle（回收）" class="headerlink" title="Recycle（回收）"></a>Recycle（回收）</h5><p>除了必须的内存足够小之外，不需要的内存及时释放也非常重要，<br>JVM的heap回收依赖GC，app无法控制GC的时机和频率，能做的就是保证在系统GC时自身不再使用的内存，可以顺利被释放。<br>无法被释放，就是内存泄漏，查找泄漏目前最有效的方法是MAT，如何使用在reduce一节有描述。这里重点说说泄漏的分析：</p>
<h6 id="什么时候分析泄漏？"><a href="#什么时候分析泄漏？" class="headerlink" title="什么时候分析泄漏？"></a>什么时候分析泄漏？</h6><p>1）对疑似泄漏的地方反复操作  2）内存曲线持续异常上涨 3）重度使用app后 4）Monkey测试 自动化测试之后<br>这些方式可以发现最基本、最明显的内存泄漏，对用户价值极大，性价比高。</p>
<h6 id="拿到内存快照后如何分析泄漏？"><a href="#拿到内存快照后如何分析泄漏？" class="headerlink" title="拿到内存快照后如何分析泄漏？"></a>拿到内存快照后如何分析泄漏？</h6><p>MAT对于泄漏分析的支持还是全面的，功能复杂而繁多，以我的经验来说，一般从几方面检查泄漏：<br>1）基于class<br>MAT支持sql查询，app的泄漏大多发生在Activity上<br><code>select * from instanceof android.app.Activity</code><br><img src="http://oqjv79a9c.bkt.clouddn.com/activity%20leak.png" width="560" height="300"><br>SplashActivity是上一个页面，但是还存在于内存中，说明泄漏了。然后根据Path To GCRoot –&gt; exclude weak/soft references 找到泄漏原因 — 引用持有链<br><code>select * from instanceof com.ucar.base.fragment.BaseFragment</code>可以找到Fragment的泄漏<br>这种查法基于以前的经验，效率高，但覆盖程度不够。<br>2）基于内存块<br>MAT中Leak suspects具有一定参考性，但通过Dominator Tree 对内存占用排序后，更有针对性的进行泄漏排查。<br><img src="http://oqjv79a9c.bkt.clouddn.com/dominator%20tree.png" width="660" height="350"><br>3）基于prof对比<br>需要两个Dump结果作对比，打开 Navigator History面板，将两个表的 Histogram结果都添加到 Compare Basket中去<br>步骤如下：<br>a.打开第一个hprof，打开histogram view<br>b.在NavigationHistory view里 (如果看不到就从Window &gt;show view&gt;MAT- Navigation History ), 右击histogram然后选择Add to Compare Basket<br>c.打开第二个prof，重复步骤b 点击右上角红色‘！’<br>快速定位内存增量，那么泄漏的部分显而易见。</p>
<p><em>对于内存泄漏问题，亡羊补牢当然犹未为晚，但是防微杜渐更为可取。优秀的代码实践，会大大降低内存泄漏的概率。在设计、开发过程中，始终关注app的性能表现，是一名合格app工程师的基本素质。</em></p>
<p>几条大的原则：</p>
<ol>
<li>保存对象前要三思（static）<br>I. 对象本身有无隐含的引用<br>II. 保存后何时能够回收</li>
<li>要了解常见的隐含引用<br>I. anonymous class outer class<br>II. View to context</li>
<li>创建大对象时，要检查它的生命周期</li>
</ol>
<p>Android常见的内存泄漏汇总</p>
<ol>
<li>单例造成的泄漏<br>单例模式广受程序员喜爱，是最早接触的设计模式之一。单例的生命周期与app相同，要慎用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class AppManager &#123;</div><div class="line">    private static AppManager instance;</div><div class="line">    private Context context;</div><div class="line">    private AppManager(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line">    public static AppManager getInstance(Context context) &#123;</div><div class="line">        if (instance != null) &#123;</div><div class="line">            instance = new AppManager(context);</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果传入Context instanceof Activity, 那么在Activity被destroy之后，仍然被AppManager所持有，无法释放。如果传入context instanceof Application则没问题。<br>哪些情况可以直接使用Application Context<br><img src="http://img.blog.csdn.net/20151123144226349" width="760" height="350"><br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">com.ucar.basecommon.pay.recharge.ui.RechargeActivity @ 0x4543ae98 | 408 | 3,872</div><div class="line">|- this$0 com.ucar.basecommon.pay.recharge.ui.RechargeActivity$5 @ 0x4313c498 | 16 | 16</div><div class="line">| &apos;- stateChangedListener com.ucar.basecommon.pay.utils.KeyboardUtil @ 0x44fad8c8 | 32 | 280</div><div class="line">| &apos;- keyboardUtil class com.ucar.basecommon.pay.utils.KeyboardUtil @ 0x43b442c0 System Class| 8 | 328</div></pre></td></tr></table></figure></p>
<ol>
<li>Android组件或特殊集合对象的使用<br>BraodcastReceiver，ContentObserver，FileObserver，Cursor，Callback，都是系统的回调，在Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则Activity会一直被system强引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">com.szzc.ucar.rollorder.activity.DispatchActivity @ 0x4545bcf0 | 344 | 4,688</div><div class="line">&apos;- val$listener com.ucar.base.mapic.amap.AMapWrapper$1 @ 0x453a71c8 | 16 | 16</div><div class="line">&apos;- aa com.amap.api.mapcore.AMapDelegateImp @ 0x449ab330 | 432 | 23,616</div><div class="line">&apos;- a com.amap.api.mapcore.AMapDelegateImp$TimeChangedReceiver @ 0x4537e510 | 24 | 24</div><div class="line">&apos;- [16] java.lang.Object[24] @ 0x45394208 | 112 | 112</div><div class="line">&apos;- mArray android.util.ArrayMap @ 0x432cbc70 | 24 | 200</div><div class="line">&apos;- [1] java.lang.Object[8] @ 0x432cbcb8 | 48 | 352</div><div class="line">&apos;- mArray android.util.ArrayMap @ 0x42d95ab8 | 24 | 408</div><div class="line">&apos;- mReceivers android.app.LoadedApk @ 0x42d95a40 | 88 | 2,296</div></pre></td></tr></table></figure>
<p>地图的初始化会注册系统一个TimeChangedReceiver，地图的api规范里说明在页面销毁时调用map.onDestroy,此处会解注册系统回调。如果不调用，会造成内存泄漏。</p>
<ol>
<li><p>Handler Thread 使用不当<br>Handler 发送的 Message 尚未被处理，当线程的 run 函数耗时较长没有结束时，Handler和Thread都不会被销毁；二者都是异步调用，生命周期与Activity并不同步，同时匿名内部的Handler Thread类会持有外部Activity的对象，导致泄漏。<br>解决的办法就是使用静态内部类，并在Activity销毁时移除内部回调。<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private MyHandler mHandler = new MyHandler(this);</div><div class="line">    private TextView mTextView ;</div><div class="line">    private static class MyHandler extends Handler &#123;</div><div class="line">        private WeakReference&lt;Context&gt; reference;</div><div class="line">        public MyHandler(Context context) &#123;</div><div class="line">            reference = new WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            MainActivity activity = (MainActivity) reference.get();</div><div class="line">            if(activity != null)&#123;</div><div class="line">                activity.mTextView.setText(&quot;&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        mHandler.removeCallbacksAndMessages(null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>静态变量的不当使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private static TestResource mResource = null;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        if(mManager == null)&#123;</div><div class="line">            mManager = new TestResource();</div><div class="line">        &#125;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">    class TestResource &#123;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>静态mResource被MainActivity类本身引用，但mResource由于是内部类，内部含有MainActivity.this，发生泄漏<br>静态变量的使用要比单例更为慎重，如果要使用也要注意主动释放。<br>5.集合类<br>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com.szzc.tcar.book.fragment.TCarPickFragment @ 0x4703ce28 | 296 | 57,032</div><div class="line">&apos;- [16] java.lang.Object[27] @ 0x466775b0 | 120 | 1,004,992</div><div class="line">&apos;- array java.util.ArrayList @ 0x444dbd00 | 24 | 1,005,016</div><div class="line">&apos;- mFragmentList com.ucar.base.fragmentation.Fragmentation @ 0x444dbcc8 | 24 | 1,005,056</div><div class="line">&apos;- mFragmentation com.szzc.home.activity.MainActivity @ 0x444d9340 | 352 | 6,176</div></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/06/06/perf-memory/" data-id="cj3lmp9k30000m4x3hc9pc219" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android性能优化/">Android性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-perf-overdraw" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/27/perf-overdraw/" class="article-date">
  <time datetime="2017-05-26T16:00:00.000Z" itemprop="datePublished">2017-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/27/perf-overdraw/">过度绘制的解决</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。<br>本文关注渲染方向：</p>
<hr>
<p>渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。<br>CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。</p>
<p>Overdraw 过度绘制：<br>定义：屏幕上的某个像素在同一帧的时间内被绘制了多次<br>例如UI是层叠的，看不见的UI也做绘制操作，就是多余的。当设计效果上更加华丽炫酷时，堆叠视图层级是常见的情况，但这很容易产生性能问题。</p>
<p>怎么过度绘制打开开关和如何看，不介绍了就。</p>
<hr>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>1.写合理而高效的布局<br>Android的布局可以通过xml来实现，这使得开发者布局时较为随意，只以实现功能为目的，忽略性能问题的累积效应。<br>在开发设计之初，就应该考虑布局的效率问题，以免出现后期修改的高成本。<br>降低Layout层级，有很多方法 不列举了。</p>
<p>2.移除非必须的background: Activity的DecorView有默认的背景色，可以改为透明<br><code>getWindow().getDecorView().setBackgroundColor(getResources().getColor(R.color.transparent));</code><br>这个颜色从ActivityTheme设置，被decorView所持有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Theme&quot;&gt;</div><div class="line">    ...</div><div class="line">    &lt;!-- Window attributes --&gt;</div><div class="line">    &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_dark&lt;/item&gt;</div><div class="line">    ...</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>screen_background_selector_dark在sdk中定义为纯黑色<br>所以也可以<code>android:windowbackground=&quot;null&quot;</code>方法来修改</p>
<p>后续会在Theme自定义，或BaseActivity 统一优化</p>
<p>3.View BackGround 优化：<br>1) 所有的View都可以设置Background，ImageView除了可以设置BackGround外，还可以设置imageResource<br>在使用ImageView时，尤其是ListView ViewHolder中，可能imageView设置默认bitmap给background，然后<br>真正的bitmap给imageResource，导致了重复绘制。解决方法是都通过imageResource设置<br>2) 有时采用selector背景，可以normal状态设置为transparent</p>
<p>4.移除不必要的背景色<br>比如Activity中含Fragment,如果Fragment有背景色而且是全屏的，Activity就不必要。<br>又比如ViewPager中含fragment ViewPager的背景色是不必要的</p>
<p>5.ClipRect<br>在ViewGroup的drawChild方法中，<br><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime)</code><br>在ViewGroup的Canvas上绘制子child，不同的child都在同一个canvas绘制，如果view相互遮盖，则重复绘制难免。<br>Canvas的clipRect方法，提供了限定绘制区域的功能，在某个child 绘制时，可以限定绘制区域为自己的显示区域，解决了这个问题。<br>v4包中的DrawerLayout，就专门做了ClipRect优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</div><div class="line">        final int height = getHeight();</div><div class="line">        final boolean drawingContent = isContentView(child);//是否mainContent</div><div class="line">        int clipLeft = 0, clipRight = getWidth();</div><div class="line"></div><div class="line">		//如果是绘制mainContent，则先canvas.save 再 canvas.restore</div><div class="line">        //并拿到drawerContent的right作为自己绘制的left，通过canvas.clipRect限定绘制区域</div><div class="line">        final int restoreCount = canvas.save();</div><div class="line">        if (drawingContent) &#123;</div><div class="line">            final int childCount = getChildCount();</div><div class="line">            //此for循环找到drawerCotnent，</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                final View v = getChildAt(i);</div><div class="line">                //注意此处对于drawerContent的筛选条件：</div><div class="line">                //visible，背景非透明!hasOpaqueBackground(v)</div><div class="line">                //如果drawerContent无背景色，此优化直接continue,因为mainContent要全显示</div><div class="line">                if (v == child || v.getVisibility() != VISIBLE ||</div><div class="line">                        !hasOpaqueBackground(v) || !isDrawerView(v) ||</div><div class="line">                        v.getHeight() &lt; height) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) &#123;</div><div class="line">                    final int vright = v.getRight();</div><div class="line">                    if (vright &gt; clipLeft) clipLeft = vright;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final int vleft = v.getLeft();</div><div class="line">                    if (vleft &lt; clipRight) clipRight = vleft;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.clipRect(clipLeft, 0, clipRight, getHeight());</div><div class="line">        &#125;</div><div class="line">        final boolean result = super.drawChild(canvas, child, drawingTime);</div><div class="line">        canvas.restoreToCount(restoreCount);</div></pre></td></tr></table></figure></p>
<p>pilot端的问题就在于DrawerContent没有背景，而是把背景设置在了里面的Fragment，导致DrawerLayout优化没有生效<br>此优化一般用于自定义view中，而且控件交互存在View之间重叠的情况</p>
<p>Android中每个Window对应一个Canvas，window下所有view绘制公用一个canvas，viewtree的父节点在调用child.draw之前都会根据child的layout边界对canvas进行裁剪，这也是为什么超过view边界的内容不会被显示的原因。<br>但是对于各child大部分重叠的控件，会产生过度绘制，就需要clipRect优化。大部分容易重叠的控件FrameLayout RelativeLayout本身没有优化，需要开发者根据实际情况对自定义控件进行优化。</p>
<p>优化前：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-unmodified.png" width="160" height="300">优化后：<img src="http://oqjv79a9c.bkt.clouddn.com/0516-modified.png" width="160" height="300">滴滴：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-didi.png" width="160" height="300"></p>
<p>6.善用9patch，背景图如果只显示边框，选用9patch，中间的透明会被2D渲染器优化overdraw</p>
<hr>
<p>过度绘制的原因无外乎：复杂的Layout层级、重叠的背景、重叠的View几种。开发人员在设计之初就要充分考虑过度绘制等性能敏感地带，要知道等到功能实现之后再去改Layout层级，onDraw方法等，成本和风险都会指数型提高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/27/perf-overdraw/" data-id="cj3mfe3xj0000c4x35a0dr2x7" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android性能优化/">Android性能优化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-essay" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/26/essay/" class="article-date">
  <time datetime="2017-05-25T16:00:00.000Z" itemprop="datePublished">2017-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/26/essay/">随笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="Android-getResources-getColor-Deprecated"><a href="#Android-getResources-getColor-Deprecated" class="headerlink" title="Android getResources().getColor() Deprecated"></a>Android getResources().getColor() Deprecated</h5><p>getColor方法在Android 6.0即API 23中 已经过时，替代方法为：</p>
<p>ContextCompat.getColor(context, R.color.black)<br>ContextCompat 在v4包。</p>
<hr>
<h5 id="Gradle-配置异常"><a href="#Gradle-配置异常" class="headerlink" title="Gradle 配置异常"></a>Gradle 配置异常</h5><ol>
<li>You have not accepted the license agreements of the following SDK components: [Android SDK Build-Tools 24.0.2]</li>
</ol>
<p>从Android Gradle plugin 2.2.0开始，gradle会自动加载需要的SDK, build-tools，但是因为没有接受license，导致加载依赖终止<br>例如依赖了google gms服务的依赖，gradle会下载sdk对应的包，此时会报这个错误。<br>问题解决：</p>
<p>license存放在$ANDROID_HOME/licenses下（ANDROID_HOME 就是sdk的位置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir &quot;$ANDROID_HOME/licenses&quot;</div><div class="line">echo -e &quot;\n8933bad161af4178b1185d1a37fbf41ea5269c55&quot; &gt; &quot;$ANDROID_HOME/licenses/android-sdk-license&quot;</div></pre></td></tr></table></figure></p>
<p> getSupportFragmentManager().getFragments() 抛出空指针异常</p>
<h2 id="http-blog-csdn-net-lintcgirl-article-details-50681373"><a href="#http-blog-csdn-net-lintcgirl-article-details-50681373" class="headerlink" title=" http://blog.csdn.net/lintcgirl/article/details/50681373"></a> <a href="http://blog.csdn.net/lintcgirl/article/details/50681373" target="_blank" rel="external">http://blog.csdn.net/lintcgirl/article/details/50681373</a></h2><p>删除chrome指定密码记录<br>chrome://settings/passwords</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/26/essay/" data-id="cj36o83ks0000txx368s32bsi" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-clean code" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/16/clean code/" class="article-date">
  <time datetime="2017-05-15T16:00:00.000Z" itemprop="datePublished">2017-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/16/clean code/">聊聊clean code</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="聊聊clean-code"><a href="#聊聊clean-code" class="headerlink" title="聊聊clean code"></a>聊聊clean code</h1><hr>
<p>clean code，顾名思义就是整洁的代码，或者说清晰、漂亮的代码，相信大多数工程师都希望自己能写出这样的代码。</p>
<p>也许这是个千人千面的话题，每个工程师都有自己的理解。比如我，从一个天天被骂代码写得烂的人，逐渐学习成长，到现在也能写的出“人模人样”的代码来了。这期间算是积累了一点经验心得，想和大家分享，抛砖引玉。</p>
<p>本文主要针对面向对象编程的clean code来阐述，面向过程代码的思路会比较不同，不在本文的讨论范畴。</p>
<h2 id="代码整洁的大前提"><a href="#代码整洁的大前提" class="headerlink" title="代码整洁的大前提"></a>代码整洁的大前提</h2><h3 id="代码大部分时候是用来维护的，而不是用来实现功能的"><a href="#代码大部分时候是用来维护的，而不是用来实现功能的" class="headerlink" title="代码大部分时候是用来维护的，而不是用来实现功能的"></a>代码大部分时候是用来维护的，而不是用来实现功能的</h3><p>这个原则适用于大部分的工程。我们的代码，一方面是编译好让机器执行，完成功能需求；另一方面，是写给身边的队友和自己看的，需要长期维护，而且大部分项目都不是朝生夕死的短命鬼。</p>
<p>大部分情况下，如果不能写出清晰好看的代码，可能自己一时爽快，后续维护付出的代价和成本将远高于你的想象。</p>
<p>对清晰好看代码的追求精神，比所有的技巧都要重要。</p>
<h3 id="优秀的代码大部分是可以自描述的，好于文档和注释"><a href="#优秀的代码大部分是可以自描述的，好于文档和注释" class="headerlink" title="优秀的代码大部分是可以自描述的，好于文档和注释"></a>优秀的代码大部分是可以自描述的，好于文档和注释</h3><p>当你翻看很多开源代码时，会发现注释甚至比我们自己写的项目都少，但是却能看的很舒服。当读完源码时，很多功能设计就都清晰明了了。通过仔细斟酌的方法命名、清晰的流程控制，代码本身就可以拿出来当作文档使用，而且它永远不会过期。</p>
<p>相反，注释不能让写的烂的代码变的更好。如果别人只能依靠注释读懂你的代码的时候，你一定要反思代码出现了什么问题（当然，这里不是说大家不要写注释了）。</p>
<p>说下比较适合写注释的两种场景：</p>
<ol>
<li>public interface，向别人明确发布你功能的语义，输入输出，且不需要关注实现。</li>
<li>功能容易有歧义的点，或者涉及比较深层专业知识的时候。比如，如果你写一个客户端，各种config参数的含义等。</li>
</ol>
<h3 id="设计模式只是手段，代码清晰才是目的"><a href="#设计模式只是手段，代码清晰才是目的" class="headerlink" title="设计模式只是手段，代码清晰才是目的"></a>设计模式只是手段，代码清晰才是目的</h3><p>之前见过一些所谓“高手”的代码都比较抽象，各种工厂、各种继承。想找到一个实现总是要山路十八弯，一个工程里大部分的类是抽象类或者接口，找不到一两句实现的代码，整个读起代码来很不顺畅。我跟他聊起来的时候，他的主要立场是：保留合适的扩展点，克服掉所有的硬编码。</p>
<p>其实在我看来，也许他的代码被“过度设计”了。首先必须要承认的是，在同一个公司工作的同事，水平是参差不齐的。无论你用了如何高大上的设计，如果大多数人都不能理解你的代码或者读起来很费劲的话，其实这是一个失败的设计。</p>
<p>当你的系统内大部分抽象只有一个实现的时候，要好好思考一下，是不是设计有点过度了，清晰永远是第一准则。</p>
<h2 id="代码整洁的常见手段"><a href="#代码整洁的常见手段" class="headerlink" title="代码整洁的常见手段"></a>代码整洁的常见手段</h2><p>记住原则后，我们开始进入实践环节，先来看下有哪些促成clean code的常见手段。</p>
<h3 id="code-review"><a href="#code-review" class="headerlink" title="code review"></a>code review</h3><p>很多大公司会用git的pull request机制来做code review。我们重点应该review什么？是代码的格式、业务逻辑还是代码风格？我想说的是，凡是能通过机器检查出来的事情，无需通过人。比如换行、注释、方法长度、代码重复等。除了基本功能需求的逻辑合理没有bug外，我们更应该关注代码的设计与风格。比如，一段功能是不是应该属于一个类、是不是有很多相似的功能可以抽取出来复用、代码太过冗长难懂等等。</p>
<p>我个人非常推崇集体code review，因为很多时候，组里相对高级的工程师能够一眼发现代码存在较大设计缺陷，提出改进意见或者重构方式。我们可以在整个小组内形成一个好的文化传承和风格统一，并且很大程度上培养了大家对clean code的热情。</p>
<h3 id="勤于重构"><a href="#勤于重构" class="headerlink" title="勤于重构"></a>勤于重构</h3><p>好的代码，一般都不是一撮而就的。即使一开始设计的代码非常优秀，随着业务的快速迭代，也可能被改的面目全非。</p>
<p>为了避免重构带来的负面影响（delay需求或者带来bug），我们需要做好以下的功课：<br>① 掌握一些常见的“无痛”重构技巧，这在下文会有具体讲解。<br>② 小步快跑，不要企图一口吃成个胖子。改一点，测试一点，一方面减少代码merge的痛苦，另一方面减少上线的风险。<br>③ 建立自动化测试机制，要做到即使代码改坏了，也能保证系统最小核心功能的可用，并且保证自己修改的部分被测试覆盖到。<br>④ 熟练掌握IDE的自动重构功能。这些会很大程度上减少我们的体力劳动，避免犯错。</p>
<h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><p>现在市面上有很多代码静态检查的工具，也是发现bug和风格不好的比较容易的方式。可以与发布系统做集成，强制把主要问题修复掉才可以上线。目前美团点评技术团队内部的研发流程中已经普遍接入了Sonar质量管理平台。</p>
<h3 id="多读开源代码和身边优秀同学的代码"><a href="#多读开源代码和身边优秀同学的代码" class="headerlink" title="多读开源代码和身边优秀同学的代码"></a>多读开源代码和身边优秀同学的代码</h3><p>感谢开源社区，为我们提供了这么好的学习机会。无论是JDK的源码，还是经典的Netty、Spring、Jetty，还是一些小工具如Guava等，都是clean code的典范。多多学习，多多反思和总结，必有收益。</p>
<h3 id="代码整洁的常见技巧"><a href="#代码整洁的常见技巧" class="headerlink" title="代码整洁的常见技巧"></a>代码整洁的常见技巧</h3><p>前面的内容都属于热身，让大家有个整体宏观的认识。下面终于进入干货环节了，我会分几个角度讲解编写整洁代码的常见技巧和误区。</p>
<h3 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h3><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><p>这是整洁代码的最重要也是最基本的原则了。简单来讲，大到一个module、一个package，小到一个class、一个method乃至一个属性，都应该承载一个明确的职责。要定义的东西，如果不能用一句话描述清楚职责，就把它拆掉。</p>
<p>我们平时写代码时，最容易犯的错误是：一个方法干了好几件事或者一个类承载了许多功能。</p>
<p>先来聊聊方法的问题。个人非常主张把方法拆细，这是复用的基础。如果方法干了两件事情，很有可能其中一个功能的其他业务有差别就不好重用了。另外语义也是不明确的。经常看到一个get()方法里面竟然修改了数据，这让使用你方法的人情何以堪？如果不点进去看看实现，可能就让程序陷入bug，让测试陷入麻烦。</p>
<p>再来聊聊类的问题。我们经常会看到“又臭又长”的service/biz层的代码，里面有几十个方法，干什么的都有：既有增删改查，又有业务逻辑的聚合。每次找到一个方法都费劲。不属于一个领域或者一个层次的功能，就不要放到一起。</p>
<p>我们team在code review中，最常被批评的问题，就是一个方法应该归属于哪个类。</p>
<h4 id="优先定义整体框架"><a href="#优先定义整体框架" class="headerlink" title="优先定义整体框架"></a>优先定义整体框架</h4><p>我写代码的时候，比较喜欢先去定义整体的框架，就是写很多空实现，来把整体的业务流程穿起来。良好的方法签名，用入参和出参来控制流程。这样能够避免陷入业务细节无法自拔。在脑海中先定义清楚流程的几个阶段，并为每个阶段找到合适的方法／类归属。</p>
<p>这样做的好处是，阅读你代码的人，无论读到什么深度，都可以清晰地了解每一层的职能，如果不care下一层的实现，完全可以跳过不看，并且方法的粒度也会恰到好处。</p>
<p>简而言之，我比较推崇写代码的时候“广度优先”而不是“深度优先”，这和我读代码的方式是一致的。当然，这件事情跟个人的思维习惯有一定的关系，可能对抽象思维能力要求会更高一些。如果开始写代码的时候这些不够清晰，起码要通过不断地重构，使代码达到这样的成色。</p>
<h4 id="清晰的命名"><a href="#清晰的命名" class="headerlink" title="清晰的命名"></a>清晰的命名</h4><p>老生常谈的话题，这里不展开讲了，但是必须要mark一下。有的时候，我思考一个方法命名的时间，比写一段代码的时间还长。原因还是那个逻辑：每当你写出一个类似于”temp”、”a”、”b”这样变量的时候，后面每一个维护代码的人，都需要用几倍的精力才能理顺。</p>
<p>并且这也是代码自描述最重要的基础。</p>
<h4 id="避免过长参数"><a href="#避免过长参数" class="headerlink" title="避免过长参数"></a>避免过长参数</h4><p>如果一个方法的参数长度超过4个，就需要警惕了。一方面，没有人能够记得清楚这些函数的语义；另一方面，代码的可读性会很差；最后，如果参数非常多，意味着一定有很多参数，在很多场景下，是没有用的，我们只能构造默认值的方式来传递。</p>
<p>解决这个问题的方法很简单，一般情况下我们会构造paramObject。用一个struct或者一个class来承载数据，一般这种对象是value object，不可变对象。这样，能极大程度提高代码的可复用性和可读性。在必要的时候，提供合适的build方法，来简化上层代码的开发成本。</p>
<h4 id="避免过长方法和类"><a href="#避免过长方法和类" class="headerlink" title="避免过长方法和类"></a>避免过长方法和类</h4><p>一个类或者方法过长的时候，读者总是很崩溃的。简单地把方法、类和职责拆细，往往会有立竿见影的成效。以类为例，拆分的维度有很多，常见的是横向／纵向。例如，如果一个service，处理的是跟一个库表对象相关的所有逻辑，横向拆分就是根据业务，把建立／更新／修改／通知等逻辑拆到不同的类里去；而纵向拆分，指的是<br>把数据库操作/MQ操作/Cache操作/对象校验等，拆到不同的对象里去，让主流程尽量简单可控，让同一个类，表达尽量同一个维度的东西。</p>
<h4 id="让相同长度的代码段表示相同粒度的逻辑"><a href="#让相同长度的代码段表示相同粒度的逻辑" class="headerlink" title="让相同长度的代码段表示相同粒度的逻辑"></a>让相同长度的代码段表示相同粒度的逻辑</h4><p>这里想表达的是，尽量多地去抽取private方法，让代码具有自描述的能力。举个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void doSomeThing(Map params1,Map params2)&#123;</div><div class="line">Do1 do1 = getDo1(params1);</div><div class="line">Do2 do2 = new Do2();</div><div class="line">do2.setA(params2.get(&quot;a&quot;));</div><div class="line">do2.setB(params2.get(&quot;b&quot;));</div><div class="line">do2.setC(params2.get(&quot;c&quot;));</div><div class="line">mergeDO(do1,do2);</div><div class="line">&#125;</div><div class="line">private void getDo1(Map params1);</div><div class="line">private void mergeDo(do1,do2)&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p>类似这种代码，在业务代码中随处可见。获取do1是一个方法，merge是一个方法，但获取do2的代码却在主流程里写了。这种代码，流程越长，读起来越累。很多人读代码的逻辑，是“广度优先”的。先读懂主流程，再去看细节。类似这种代码，如果能够把构造do2的代码，提取一个private 方法，就会舒服很多。</p>
<h3 id="面向对象设计技巧"><a href="#面向对象设计技巧" class="headerlink" title="面向对象设计技巧"></a>面向对象设计技巧</h3><h4 id="贫血与领域驱动"><a href="#贫血与领域驱动" class="headerlink" title="贫血与领域驱动"></a>贫血与领域驱动</h4><p>不得不承认，Spring已经成为企业级Java开发的事实标准。而大部分公司采用的三层/四层贫血模型，已经让我们的编码习惯，变成了面向DAO而不是面向对象。</p>
<p>缺少了必要的模型抽象和设计环节，使得代码冗长，复用程度比较差。每次撸代码的时候，从mapper撸起，好像已经成为不成文的规范。</p>
<p>好处是上手简单，学习成本低。但是每次都不能重用，然后面对两三千行的类看着眼花的时候，我的心是很痛的。关于领域驱动的设计模式，本文不会展开去讲。回归面向对象，还是跟大家share一些比较好的code技巧，能够在一个通用的框架下，尽量好的写出漂亮可重用的code。</p>
<p>个人认为，一个好的系统，一定离不开一套好的模型定义。梳理清楚系统中的核心模型，清楚的定义每个方法的类归属，无论对于代码的可读性、可交流性，还是和产品的沟通，都是有莫大好处的。</p>
<p>####为每个方法找到合适的类归属，数据和行为尽量要在一起<br>不得不承认，Spring已经成为企业级Java开发的事实标准。而大部分公司采用的三层/四层贫血模型，已经让我们的编码习惯，变成了面向DAO而不是面向对象。</p>
<p>缺少了必要的模型抽象和设计环节，使得代码冗长，复用程度比较差。每次撸代码的时候，从mapper撸起，好像已经成为不成文的规范。</p>
<p>好处是上手简单，学习成本低。但是每次都不能重用，然后面对两三千行的类看着眼花的时候，我的心是很痛的。关于领域驱动的设计模式，本文不会展开去讲。回归面向对象，还是跟大家share一些比较好的code技巧，能够在一个通用的框架下，尽量好的写出漂亮可重用的code。</p>
<p>个人认为，一个好的系统，一定离不开一套好的模型定义。梳理清楚系统中的核心模型，清楚的定义每个方法的类归属，无论对于代码的可读性、可交流性，还是和产品的沟通，都是有莫大好处的。</p>
<p>####为每个方法找到合适的类归属，数据和行为尽量要在一起<br>如果一个类的所有方法，都是在操作另一个类的对象。这时候就要仔细想一想类的设计是否合理了。理论上讲，面向对象的设计，主张数据和行为在一起。这样，对象之间的结构才是清晰的，也能减少很多不必要的参数传递。</p>
<p>不过这里面有一个要讨论的方法：service对象。如果操作一个对象数据的所有方法都建立在对象内部，可能使对象承载了很多并不属于它本身职能的方法。</p>
<p>例如，我定义一个类，叫做person，。这个类有很多行为，比如：吃饭、睡觉、上厕所、生孩子；也有很多字段，比如：姓名、年龄、性格。</p>
<p>很明显，字段从更大程度上来讲，是定义和描述我这个人的，但很多行为和我的字段并不相关。上厕所的时候是不会关心我是几岁的。如果把所有关于人的行为全部在person内部承载，这个类一定会膨胀的不行。</p>
<p>这时候就体现了service方法的价值，如果一个行为，无法明确属于哪个领域对象，牵强地融入领域对象里，会显得很不自然。这时候，无状态的service可以发挥出它的作用。但一定要把握好这个度，回归本质，我们要把属于每个模型的行为合理的去划定归属。</p>
<p>####警惕static<br>static方法，本质上来讲是面向过程的，无法清晰地反馈对象之间的关系。虽然有一些代码实例（自己实现单例或者Spring托管等）的无状态方法可以用static来表示，但这种抽象是浅层次的。说白了，如果我们所有调用static的地方，都写上import static，那么所有的功能就由类自己在承载了。</p>
<p>让我画一个类图？尴尬了……画不出来。</p>
<p>而单例的膨胀，很大程度上也是贫血模型带来的副作用。如果对象本身有血有肉，就不需要这么多无状态方法。</p>
<p>static真正适用的场景：工具方法，而不是业务方法。</p>
<p>####巧用method object<br>method object是大型重构的常用技巧。当一段逻辑特别复杂的代码，充斥着各种参数传递和是非因果判断的时候，我首先想到的重构手段是提取method object。所谓method object，是一个有数据有行为的对象。依赖的数据会成为这个对象的变量，所有的行为会成为这个对象的内部方法。利用成员变量代替参数传递，会让代码简洁清爽很多。并且，把一段过程式的代码转换成对象代码，为很多面向对象编程才可以使用的继承／封装／多态等提供了基础。</p>
<p>举个例子，上文引用的代码如果用method object表示大概会变成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class DoMerger&#123;</div><div class="line">    map params1;</div><div class="line">    map params2;</div><div class="line">    Do1 do1;</div><div class="line">    Do2 do2;</div><div class="line">    public DoMerger(Map params1,Map params2)&#123;</div><div class="line">       this.params1 = params1;</div><div class="line">       this.params2 = parmas2;</div><div class="line">    &#125;</div><div class="line">    public void invoke()&#123;</div><div class="line">        do1 = getDo1();</div><div class="line">        do2 = getDo2();</div><div class="line">       mergeDO(do1,do2);</div><div class="line">    &#125;</div><div class="line">    private Do1 getDo1();</div><div class="line">     private Do2 getDo2();</div><div class="line">     private void mergeDo()&#123;</div><div class="line">        print(do1+do2);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>####面向接口编程<br>面向接口编程是很多年来大家形成的共识和最佳实践。最早的理论是便于实现的替换，但现在更显而易见的好处是避免public方法的膨胀。一个对外publish的接口，一定有明确的职责。要判断每一个public方法是否应该属于同一个interface，是很容易的。</p>
<p>整个代码基于接口去组织，会很自然地变得非常清晰易读。关注实现的人才去看实现，不是嘛？</p>
<p>####正确使用继承和组合<br>这也是个在业界被讨论过很久的问题，也有很多论调。最新的观点是组合的使用一般情况下比继承更为灵活，尤其是单继承的体系里，所以倾向于使用组合<br>，否则会让子类承载很多不属于自己的职能。</p>
<p>个人对此观点持保留意见，在我经历过的代码中，有一个小规律，我分析一下。</p>
<p>protected abstract 这种是最值得使用继承的，父类保留扩展点，子类扩展，没什么好说的。</p>
<p>protected final 这种方法，子类是只能使用不能修改实现的。一般有两种情况：<br>① 抽象出主流程不能被修改的，然而一般情况下，public final更适合这个职能。如果只是流程的一部分，需要思考这个流程的类归属，大部分变成public组合到其他类里是更合适的。<br>② 父类是抽象类无法直接对外提供服务，又不希望子类修改它的行为，这种大多数情况下属于工具方法，比较适合用另一个领域对象来承载并用组合的方式来使用。</p>
<p>protected 这种是有争议的，是父类有默认实现但子类可以扩展的。凡是有扩展可能的，使用继承更理想一些。否则，定义成final并考虑成组合。</p>
<p>综上所述，个人认为继承更多的是为扩展提供便利，为复用而存在的方法最好使用组合的方式。当然，更为大的原则是明确每个方法的领域划分。</p>
<p>###代码复用技巧</p>
<p>####模板方法<br>这是我用得最多的设计模式了。每当有两个行为类似但又不完全相同的代码段时，我总是会想到模板方法。提取公共流程和可复用的方法到父类，保留不同的地方作为abstract方法，由不同的子类去实现。</p>
<p>并在合适的时机，pull method up（复用）或者 pull method down（特殊逻辑）。</p>
<p>最后，把不属于流程的、但可复用的方法，判断是不是属于基类的领域职责，再使用继承或者组合的方法，为这些方法找到合适的安家之处。</p>
<p>####extract method<br>很多复用的级别没有这么大，也许只是几行相同的逻辑被copy了好几次，何不尝试提取方法（private）。又能明确方法行为，又能做到代码复用，何乐不为？</p>
<p>####责任链<br>经常看到这样的代码，一连串类似的行为，只是数据或者行为不一样。如一堆校验器，如果成功怎么样、失败怎么样；或者一堆对象构建器，各去构造一部分数据。碰到这种场景，我总是喜欢定义一个通用接口，入参是完整的要校验／构造的参数，<br>出参是成功/失败的标示或者是void。然后有很多实现器分别实现这个接口，再用一个集合把这堆行为串起来。最后，遍历这个集合，串行或者并行的执行每一部分的逻辑。</p>
<p>这样做的好处是：<br>① 很多通用的代码可以在责任链原子对象的基类里实现；<br>② 代码清晰，开闭原则，每当有新的行为产生的时候，只需要定义行的实现类并添加到集合里即可；<br>③ 为并行提供了基础。</p>
<p>####为集合显式定义它的行为<br>集合是个有意思的东西，本质上它是个容器，但由于泛型的存在，它变成了可以承载所有对象的容器。很多非集合的类，我们可以定义清楚他们的边界和行为划分，但是装进集合里，它们却都变成了一个样子。不停地有代码，各种循环集合，做一些相似的操作。</p>
<p>其实很多时候，可以把对集合的操作显示地封装起来，让它变得更有血有肉。</p>
<p>例如一个Map，它可能表示一个配制、一个缓存等等。如果所有的操作都是直接操作Map，那么它的行为就没有任何语义。第一，读起来就必须要深入细节；第二，如果想从获取配置读取缓存的地方加个通用的逻辑，例如打个log什么的，你可以想象是多么的崩溃。</p>
<p>个人提倡的做法是，对于有明确语义的集合的一些操作，尤其是全局的集合或者被经常使用的集合，做一些封装和抽象，如把Map封装成一个Cache类或者一个config类，再提供GetFromCache这样的方法。</p>
<p>###总结<br>本文从clean code的几个大前提出发，然后提出了实践clean code的一些手段，重点放在促成clean code的一些常用编码和重构技巧。<br>当然，这些只代表笔者本人的一点点感悟。好的代码，最最需要的，还是大家不断追求卓越的精神。欢迎大家一起探索交流这个领域，为clean code提供更多好的思路与方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/16/clean code/" data-id="cj36nq2lt0002gvx3htu14w3s" class="article-share-link">Partager</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/代码及架构/">代码及架构</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Mot-clés</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android性能优化/">Android性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码及架构/">代码及架构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nuage de mot-clés</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android性能优化/" style="font-size: 10px;">Android性能优化</a> <a href="/tags/代码及架构/" style="font-size: 10px;">代码及架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/15/ARouter/">ARouter:Anroid组件化方案</a>
          </li>
        
          <li>
            <a href="/2017/06/06/perf-memory/">内存问题的解决</a>
          </li>
        
          <li>
            <a href="/2017/05/27/perf-overdraw/">过度绘制的解决</a>
          </li>
        
          <li>
            <a href="/2017/05/26/essay/">随笔记</a>
          </li>
        
          <li>
            <a href="/2017/05/16/clean code/">聊聊clean code</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>