<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Muse--D.D">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Muse--D.D">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Muse--D.D">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Muse--D.D</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Muse--D.D</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/30/ReactiveX3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/30/ReactiveX3/" itemprop="url">RxJava2 复杂异步场景之——Token前置请求</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-30T00:00:00+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542448088434&amp;di=32f275cf3a1f761431b6ed1c48bf6f85&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F2017-11-20%2F5a127cc5f2620.jpg" alt=""></p>
<h3 id="RxJava的用武之地"><a href="#RxJava的用武之地" class="headerlink" title="RxJava的用武之地"></a>RxJava的用武之地</h3><p>Rxjava这个库和其他常见库不太一样，一般的库例如Glide，ButterKnife都是为了解决实际问题出现的，一定程度上是刚需。Glide库如果不用他，那么应用自己就要处理图片下载、压缩、内存管理、多级缓存等等复杂的逻辑。这类问题复杂而常见，而像Glide这类的轮子，Api的设计都比较友好，一个简单的api调用就能完成一个原本很复杂的功能，简直不要太爽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Glide.with(context)</div><div class="line">    .load(url)//图片加载</div><div class="line">    .crossFade()//动画设置</div><div class="line">    .placeholder(R.drawable.place_image)//占位图</div><div class="line">    .error(R.drawable.error_image)//失败占位图</div><div class="line">    .override(width,height)//图片裁剪</div><div class="line">    .thumbnail(thumbnailRequest)//配置缩略图</div><div class="line">    .diskCacheStrategy(DiskCacheStrategy.SOURCE)//缓存策略</div><div class="line">    .into(imageView);</div></pre></td></tr></table></figure></p>
<p>而Rxjava，你刚开始看起来，都不知道他是干什么的。“异步处理”？不是一般都使用观察者模式吗？AsyncTask，Handler也可以，要rxjava干嘛？如果你有兴趣研究过一点rxjava，会发现网上的教程都会说：”zip map flatmap debounce等操作符把异步回调变得‘简洁’‘优雅’”，然后对比一下原来的代码和使用rxjava后的代码，最后感叹一下rxjava设计的鬼才和功能的强大。我自己在初次接触rxjava时也感觉，这些rxjava的优点描述比较空洞，这项技术的意义大于实用。<br>实际情况是这样么？在具体开发中，异步调用给我们的最大困扰是：异步回调的时间并不可控。当有多个异步回调时，这些调用相互联系和依赖，搞清楚每个回调何时返回是个重要的问题。在每个关键时间节点对‘分散的callback’做正确的事，有过类似编程经验的人都知道，是非常痛苦的事，如果还想代码容易看懂，简直是疯了。<br><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542204750068&amp;di=9b8b158cf28431c81169ea0b66c630fa&amp;imgtype=0&amp;src=http%3A%2F%2Fwx2.sinaimg.cn%2Fbmiddle%2F9e31678cgy1frlkvhvb74j206o06oaa3.jpg" alt=""><br>rxjava号称异步调用的终极解决方案，能否解决以上困扰？随着学习和应用的深入，体会会更明显。以下会用一个稍复杂的例子，实操一个复杂异步场景，看看rxjava处理的怎么样。</p>
<h3 id="典型复杂异步场景-–-Token的前置校验"><a href="#典型复杂异步场景-–-Token的前置校验" class="headerlink" title="典型复杂异步场景 – Token的前置校验"></a>典型复杂异步场景 – Token的前置校验</h3><p>经常遇到这种需求，接口的请求依赖token信息。一个请求需要先请求token（token如果存在缓存则使用缓存），依赖这个token才能进行正常网络请求。这个token有一定的时效性，在时效性内可以使用缓存，过期后需要重新请求token并重新发起一次请求。这个流程可以归纳如下图：<br><img src="https://upload-images.jianshu.io/upload_images/2432018-f715dadc4d40d252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="token前置请求.png"><br>光看这些需求，是不是觉得已经够你喝一壶了，别忙，还有些潜在的逻辑这个图没有表现出来：<br>1 高并发网络请求时，如果token正在请求，需要对请求阻塞（token请求过程中，不再接受新的token请求）<br>2 阻塞的同时，要把这些请求记录下来，token请求成功后，再‘依次’发送这些阻塞的请求。<br>3 token失效情况下，网络请求限制重试次数。（防止递归调用）<br>4 token请求本身，重试策略需单独配置。</p>
<h4 id="不使用rxjava，我们如何实现上述需求："><a href="#不使用rxjava，我们如何实现上述需求：" class="headerlink" title="不使用rxjava，我们如何实现上述需求："></a>不使用rxjava，我们如何实现上述需求：</h4><p>1、网络请求前，对token是否有缓存判断，如果没有先请求token，并把这个请求阻塞且缓存<br>2、token请求过程中，如果有新的token请求进来，加入阻塞队列<br>3、token请求后，通知阻塞的队列（广播等方式），依次进行阻塞的请求<br>4、对两种次数限制，分别做逻辑判断</p>
<p>以上就是传统实现方法，就不贴代码了，这样实现有以下特点：<br>1、要时刻维护一个阻塞队列 （注意其添加和清空的时机）<br>2、token请求结束后，有一个回调机制通知阻塞队列，（这个回调需要注册和反注册）<br>3、两处的次数限制，次数维护的变量，不好维护（一般动态秘钥为了便于使用会做成单例，单例内的变量类似static，维护较复杂）<br>4、请求重试的逻辑不好实现，</p>
<p>我们可以看到这里涉及到很多静态变量的维护，广播等异步回调的处理，这种情况一多，编程者会变得很被动。而且token的异步请求和真正的网络异步请求杂糅在一起，增大了问题的复杂性。</p>
<h4 id="我们来看下rxjava如何处理："><a href="#我们来看下rxjava如何处理：" class="headerlink" title="我们来看下rxjava如何处理："></a>我们来看下rxjava如何处理：</h4><p>一些代码网络请求部分与前一篇博客《基于RxJava Retrofit的网络框架》相关。</p>
<h5 id="先看看完整的请求过程"><a href="#先看看完整的请求过程" class="headerlink" title="先看看完整的请求过程"></a>先看看完整的请求过程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">public static &lt;R&gt; Observable send(final MapiHttpRequest request, final MapiTypeReference&lt;R&gt; t)&#123;</div><div class="line">    return Observable.defer(new Callable&lt;ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;String&gt; call() throws Exception &#123;</div><div class="line">                    //传入token缓存</div><div class="line">                    return Observable.just(Store.sToken);</div><div class="line">                &#125;</div><div class="line">            &#125;).flatMap(new Function&lt;String, ObservableSource&lt;R&gt;&gt;() &#123;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;R&gt; apply(String key) throws Exception &#123;</div><div class="line">                    if(TextUtils.isEmpty(key) &amp;&amp; !request.skipCheckKeyValid())&#123;</div><div class="line">                        //token没有缓存，需要请求Token</div><div class="line">                        return Observable.&lt;R&gt;error(new KeyNotValidThrowable());</div><div class="line">                    &#125; else &#123;</div><div class="line">                        //Token存在缓存，直接请求</div><div class="line">                        return sendRequestInternal(request,t);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            //进入失败重试流程</div><div class="line">            .retryWhen(new Function&lt;Observable&lt;? extends Throwable&gt;, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                private int retryCount = 0;</div><div class="line">                @Override</div><div class="line">                public ObservableSource&lt;String&gt; apply(Observable&lt;? extends Throwable&gt; throwableObservable) throws Exception &#123;</div><div class="line">                    return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;String&gt;&gt;() &#123;</div><div class="line">                        @Override</div><div class="line">                        public ObservableSource&lt;String&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">                            if (throwable instanceof KeyNotValidThrowable)&#123;</div><div class="line">                                //同一Request，有过一次KeyNotValidThrowable,则不再重试</div><div class="line">                                if (retryCount &gt; 0)&#123;</div><div class="line">                                    return Observable.error(throwable);</div><div class="line">                                &#125; else &#123;</div><div class="line">                                //token缓存不在，进入TokenLoader请求token</div><div class="line">                                    retryCount++;</div><div class="line">                                    return TokenLoader.getInstance().getNetTokenLocked();</div><div class="line">                                &#125;</div><div class="line">                            &#125; else if (throwable instanceof ApiException)&#123;</div><div class="line">                                  //token过期的情况，重新获取token，并重试</div><div class="line">                                  ApiException apiException = (ApiException)throwable;</div><div class="line">                                  if (apiException.getCode() == MapiResultCode.SECRETKEY_EXPIRED.value())&#123;</div><div class="line">                                      if (retryCount &gt; 0)&#123;</div><div class="line">                                          return Observable.error(throwable);</div><div class="line">                                      &#125; else &#123;</div><div class="line">                                          //token缓存失效，进入TokenLoader请求token</div><div class="line">                                          retryCount++;</div><div class="line">                                          return DynamicKeyLoader.getInstance().getNetTokenLocked();</div><div class="line">                                      &#125;</div><div class="line">                                  &#125;</div><div class="line">                            &#125;</div><div class="line">                            //其他类型错误，直接抛出，不再重试</div><div class="line">                            return Observable.error(throwable);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也许你第一次看也挺晕，别怕，你顺着注释捋捋逻辑，是不是感觉代码的实现好像画了一个时序图。<br>除了注释以外，几点说明：<br>1、defer操作符的作用是在retry时，会重新创建新的Observable，否则会使用上次的Observable，不会重新获取Store.sToken<br>2、retryWhen操作符，与sendRequestInternal内部统一配置的retryWhen并不冲突，相当于二次retry<br>3、retryWhen中如果抛出error ，则不再重试；<br>4、重试请求，通过返回getNetTokenLocked这个subject实现。（下面详述）</p>
<h5 id="阶段总结："><a href="#阶段总结：" class="headerlink" title="阶段总结："></a>阶段总结：</h5><p>整体的流程被压缩到了一个函数中，rxjava本身的retrywhen和subject机制，已经替我们完成了这么几点：<br>1、自动重试的注册和反注册，subject被回调完直接失效，再次请求要重新注册。<br>2、高并发request，维护队列，通过mTokenObservable的回调自动解决了这个问题<br>3、retry次数的维护，由于每次request的retry都是重新创建的内部类，所以变量的维护变的简单。<br>4、重试的逻辑被retry操作符自动实现了，只要重写retry的返回值就可以控制重试的策略。</p>
<h5 id="TokenLoader：Token的获取过程"><a href="#TokenLoader：Token的获取过程" class="headerlink" title="TokenLoader：Token的获取过程"></a>TokenLoader：Token的获取过程</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">public class TokenLoader &#123;</div><div class="line"></div><div class="line">    public static final String TAG = TokenLoader.class.getSimpleName();</div><div class="line"></div><div class="line">    private AtomicBoolean mRefreshing = new AtomicBoolean(false);</div><div class="line">    private PublishSubject&lt;String&gt; mPublishSubject;</div><div class="line">    private Observable&lt;String&gt; mTokenObservable;</div><div class="line"></div><div class="line">    private TokenLoader() &#123;</div><div class="line">        final TokenRequest request = new TokenRequest(CarOperateApplication.getInstance());</div><div class="line">        mTokenObservable = Observable</div><div class="line">                  .defer(new Callable&lt;ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;TokenRequest&gt; call() throws Exception &#123;</div><div class="line">                          return Observable.just(request);</div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">                  .flatMap(new Function&lt;TokenRequest, ObservableSource&lt;MapiHttpResponse&lt;Boolean&gt;&gt;&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;MapiHttpResponse&lt;Boolean&gt;&gt; apply(RefreshKeyRequest refreshKeyRequest) throws Exception &#123;</div><div class="line">                          //Token请求接口</div><div class="line">                          return ApiHelper.sendDynamicKey(refreshKeyRequest,new MapiTypeReference&lt;MapiHttpResponse&lt;Boolean&gt;&gt;()&#123;&#125;);</div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">                  .retryWhen(new Function&lt;Observable&lt;Throwable&gt;, ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                      private int retryCount = 0;</div><div class="line">                      @Override</div><div class="line">                      public ObservableSource&lt;TokenRequest&gt; apply(Observable&lt;Throwable&gt; throwableObservable) throws Exception &#123;</div><div class="line">                          return throwableObservable.flatMap(new Function&lt;Throwable, ObservableSource&lt;TokenRequest&gt;&gt;() &#123;</div><div class="line">                              @Override</div><div class="line">                              public ObservableSource&lt;RefreshKeyRequest&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">                                  retryCount++;</div><div class="line">                                  if (retryCount == 3)&#123;</div><div class="line">                                      //失败次数达到阈值，更改请求策略</div><div class="line">                                      request.setFlag(0);</div><div class="line">                                      return Observable.just(request);</div><div class="line">                                  &#125; else if (retryCount &gt; 3)&#123;</div><div class="line">                                      //失败次数超过阈值，抛出失败，放弃请求</div><div class="line">                                      mRefreshing.set(false);</div><div class="line">                                      return Observable.error(throwable);</div><div class="line">                                  &#125; else &#123;</div><div class="line">                                      //再次请求token</div><div class="line">                                      return Observable.just(request);</div><div class="line">                                  &#125;</div><div class="line">                              &#125;</div><div class="line">                          &#125;);</div><div class="line"></div><div class="line">                      &#125;</div><div class="line">                  &#125;)</div><div class="line">    //                      .delay(6000, TimeUnit.MILLISECONDS) //模拟token请求延迟</div><div class="line">                  .map(new Function&lt;MapiHttpResponse&lt;Boolean&gt;,String&gt;() &#123;</div><div class="line">                      @Override</div><div class="line">                      public String apply(MapiHttpResponse&lt;Boolean&gt; response) throws Exception &#123;</div><div class="line">                          //成功，保存token缓存</div><div class="line">                          if (response.getContent().booleanValue() == true)&#123;</div><div class="line">                              setCacheToken(response.getToken());</div><div class="line">                          &#125; else if (response.getContent().booleanValue() == false)&#123;</div><div class="line">                              setCacheToken(UcarK.getSign());</div><div class="line">                          &#125;</div><div class="line">                          //请求完成标识</div><div class="line">                          mRefreshing.set(false);</div><div class="line">                          return getCacheToken();</div><div class="line">                      &#125;</div><div class="line">                  &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static TokenLoader getInstance() &#123;</div><div class="line">        return Holder.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private static class Holder &#123;</div><div class="line">        private static final TokenLoader INSTANCE = new TokenLoader();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public String getCacheToken() &#123;</div><div class="line">        return Store.sToken;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setCacheToken(String key)&#123;</div><div class="line">        Store.sToken = key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    public Observable&lt;String&gt; getNetTokenLocked() &#123;</div><div class="line">        if (mRefreshing.compareAndSet(false, true)) &#123;</div><div class="line">            Log.d(TAG, &quot;没有请求，发起一次新的Token请求&quot;);</div><div class="line">            startTokenRequest();</div><div class="line">        &#125; else &#123;</div><div class="line">            Log.d(TAG, &quot;已经有请求，直接返回等待&quot;);</div><div class="line">        &#125;</div><div class="line">        return mPublishSubject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void startTokenRequest() &#123;</div><div class="line">        mPublishSubject = PublishSubject.create();</div><div class="line">        mTokenObservable.subscribe(mPublishSubject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是读注释，除了注释以外，几点说明：<br>1、mRefreshing的作用是在token请求过程中，不再允许新的token请求，<br>变量采用原子类，而非boolean；这样在多线程环境下，原子类的方法是线程安全的。<br>compareAndSet(boolean expect, boolean update)这个方法两个作用<br>    1）比较expect和mRefresh是否一致<br>    2）将mRefreshing置为update</p>
<p>2、startTokenRequest()方法开启token请求，注意Observable在subscribe时才正式开始</p>
<p>3、这里使用了PublishSubject较为关键，在rxjava中Subject既是observable，又是observer，在TokenLoader中，mPublishSubject是mTokenObservable的观察者，token请求的会由mPublishSubject响应，同时mPublishSubject也作为Observable返回给TokenLoader的调用者作为retryWhen的返回值返回。（所以这里PublishSubject的泛型与send（）方法中Observable的泛型应该是一致的）</p>
<p>4、对于mRefreshing是true的情况，直接返回mPublishSubject，这样每个阻塞的请求retryWhen都会等待mPublishSubject的返回值，回调通知的顺序与加入阻塞的顺序是队列关系（先请求的接口，先回调），满足我们的需求。</p>
<p>最后：<br>感觉怎么样，是豁然开朗还是越陷越深，不管那样都没有关系，你需要的是了解还存在另一种处理异步任务的方法。在你下一次遇到同样让你头疼的问题时，你可以把这篇文章拿起来再看看，也许你的头疼会好一点了。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/25/ReactiveX2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/ReactiveX2/" itemprop="url">基于RxJava Retrofit的网络框架（二）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-25T00:00:00+08:00">
                2018-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Observable网络框架的解耦和复用"><a href="#Observable网络框架的解耦和复用" class="headerlink" title="Observable网络框架的解耦和复用"></a>Observable网络框架的解耦和复用</h3><h4 id="Observer一端的解耦"><a href="#Observer一端的解耦" class="headerlink" title="Observer一端的解耦"></a>Observer一端的解耦</h4><p>我们可以看到BaseObserver实际做了errorcode响应，loading控制，对外接口的定义等工作。这几部分工作集中在一个类中有一定的耦合。我们设计的目标是业务使用自定义的Observer或者直接使用BaseObserver都很方便，但目前的设计业务要么使用BaseObserver全部功能，要么自己从头定义，扩展性不强。<br>我们可以如下优化：</p>
<h5 id="将callback接口化"><a href="#将callback接口化" class="headerlink" title="将callback接口化"></a>将callback接口化</h5><p>BaseObserver定义的onSuccess(T)和onFail（boolean isException ,Object object）两个抽象方法是完全面向业务使用者的。可将其抽象为接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface ObserverCallback &lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;&#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求成功</div><div class="line">     * @param t</div><div class="line">     */</div><div class="line">    void onSuccess(T t);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求失败</div><div class="line">     * @param isException true：返回Throwable false：返回String（ErrorMsg）</div><div class="line">     * @param object</div><div class="line">     */</div><div class="line">    void onFail(boolean isException ,Object object);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>化为接口有两个作用</p>
<ol>
<li>规范自定义的Observer的回调接口。</li>
<li>可以与其他的网络请求调用方式（callback方式，非observable方式），回调接口上统一，降低切换成本。</li>
</ol>
<h5 id="将loading逻辑和error响应逻辑分离"><a href="#将loading逻辑和error响应逻辑分离" class="headerlink" title="将loading逻辑和error响应逻辑分离"></a>将loading逻辑和error响应逻辑分离</h5><p>定义LoadingObserver，其实现ObserverCallback接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class LoadingObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        implements Observer&lt;T&gt; ,ObserverCallback&lt;T&gt;&#123;</div><div class="line"></div><div class="line">    protected BaseContext mBaseContext;</div><div class="line"></div><div class="line">    public LoadingObserver(BaseContext baseContext)&#123;</div><div class="line">        mBaseContext = baseContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onSubscribe(Disposable d) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNext(T t) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">        onSuccess(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onComplete() &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void showProgress(boolean isShow)&#123;</div><div class="line">        if (mBaseContext != null) &#123;</div><div class="line">            mBaseContext.showLoading(isShow);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求是否loading显示</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowProgress()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样做：<br>1、将更为通用的loading逻辑抽离，使其可以被独立使用或继承。<br>2、如果app存在不同业务线，可将error影响单独处理（不同业务线code定义可能不同），将loadingObserver类下沉，适配多业务线情况</p>
<h5 id="BaseObserver代码如下："><a href="#BaseObserver代码如下：" class="headerlink" title="BaseObserver代码如下："></a>BaseObserver代码如下：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class  MapiObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        extends LoadingObserver&lt;T&gt;&#123;</div><div class="line"></div><div class="line"></div><div class="line">    public MapiObserver(BaseContext baseContext)&#123;</div><div class="line">        super(baseContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        super.onError(e);</div><div class="line"></div><div class="line">        handleError(e);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleError(Throwable e)&#123;</div><div class="line">        //handle error code</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，Observer被分为了三层，原来BaseObserver这一层可以由多个更为具体的Observer来扩展。每一层都有自己的扩展功能。</p>
<h4 id="ObservableSource一端的解耦"><a href="#ObservableSource一端的解耦" class="headerlink" title="ObservableSource一端的解耦"></a>ObservableSource一端的解耦</h4><p>我们看下Observable一端做了哪些事情：</p>
<ol>
<li>对Request 参数做发送前处理：组合和加密处理</li>
<li>返回Response 解密处理，Java实体化</li>
<li>返回Response code码判断及分类</li>
</ol>
<p>Observable端解耦的目的</p>
<ol>
<li>耦合性降低后，方便后续的扩展和组合</li>
<li>将公共的，不易变化的逻辑下沉</li>
</ol>
<p>这是最终Observable生成的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）</div><div class="line">  &#123;</div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">              .map(new JavaBeanFunc(t))</div><div class="line">              .compose(ResponseTransformer.handleResult())</div><div class="line">              .subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="Request请求params参数组合加密处理放到何处？"><a href="#Request请求params参数组合加密处理放到何处？" class="headerlink" title="Request请求params参数组合加密处理放到何处？"></a>Request请求params参数组合加密处理放到何处？</h5><p>前面一章已经提到，params是通过HttpRequest类中的getURLParam()方法完成。<br>原因有2点<br>1、params定义在HttpRequest中，在Httprequest类中拿最方便。<br>2、组合和加密的过程如果需要定制，那么直接在HttpRequest子类中就可以，和框架不会有耦合。</p>
<h5 id="Response解密处理，Java实体化，在何处处理？"><a href="#Response解密处理，Java实体化，在何处处理？" class="headerlink" title="Response解密处理，Java实体化，在何处处理？"></a>Response解密处理，Java实体化，在何处处理？</h5><p>Response解密处理网上有两种处理方式，<br>1、在okhttp里使用interceptor拦截器解密 2、ResponseTransformer中处理。<br>这两种方式都有问题：<br>虽然app内部一般解密方式不变，但是要适应多业务线，或者作为适应性更广的框架来讲，这块解密逻辑放到框架中显然耦合性太高。<br>我们采用的方式是定义接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ResponseDecryptHandler &#123;</div><div class="line">    String decrypt(String var1) throws IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>HttpRequest类中定义实现接口，并将这种解密方式作为Convertor设置给Retrofit，这样将加密的逻辑耦合转移到了HttpRequest基类中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addConverterFactory(SecurityConvertFactory.create(request.responseDecryptHandler()))</div></pre></td></tr></table></figure></p>
<p>对于JavaBean实体化，一般都采用fastJson方式，这里我们通过map操作符完成，作为链式调用中的一环出现，替换方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.map(new JavaBeanFunc(t))</div></pre></td></tr></table></figure></p>
<h5 id="Response的code解析，在何处处理？"><a href="#Response的code解析，在何处处理？" class="headerlink" title="Response的code解析，在何处处理？"></a>Response的code解析，在何处处理？</h5><p>前面提到，response的code分为了解析和处理两个部分，分别放在observable和observer中完成。其中ResponseTransformer是用于解析response的返回值。<br>ErrorResumeFunction和ResponseFunction分别是网络错误和业务错误，网络错误不会变，业务错误的判断是可能扩展的。ResponseFunction的实现是可以多样的。<br></p>
<hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）</div><div class="line">  &#123;</div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">              .map(new JavaBeanFunc(t))</div><div class="line">              .compose(ResponseTransformer.handleResult())</div><div class="line">              .subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上可以看出Observable的生成过程中，除了一部分的逻辑放入的Request的接口中用于扩展，其他的功能在Observable的生成过程中以链式调用的方式存在，每个链式调用的功能由一个类承担。这也是rxjava的优势所在，在调用方式上天然地将各部分解耦了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/ReactiveX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/12/ReactiveX/" itemprop="url">基于RxJava Retrofit的网络框架（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T00:00:00+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基于RxJava-Retrofit网络框架的搭建"><a href="#基于RxJava-Retrofit网络框架的搭建" class="headerlink" title="基于RxJava Retrofit网络框架的搭建"></a>基于RxJava Retrofit网络框架的搭建</h2><h3 id="RxJava、Retrofit两个第三方库的优势"><a href="#RxJava、Retrofit两个第三方库的优势" class="headerlink" title="RxJava、Retrofit两个第三方库的优势"></a>RxJava、Retrofit两个第三方库的优势</h3><h4 id="RxJava的使用场景"><a href="#RxJava的使用场景" class="headerlink" title="RxJava的使用场景"></a>RxJava的使用场景</h4><p>本文讨论的如无特殊说明，均指代rxjava2 和 retrofit2。<br>我们先讨论一下rxJava引入的背景。有一些应用场景，特别是一些复杂的异步回调场景，如果使用传统的开发模式，会如何实现。<br>列举一些场景：</p>
<ol>
<li>EditText： 根据输入内容自动搜索时，只有当输入间隔大于某个duration时，才触发搜索。<br>同时要根据输入内容，实时判断其有效性。<br>对输入的内容，实时做出改变（比如不能输入数字，特殊字符等）<br>（<a href="https://www.jianshu.com/p/9aaccd7bb600）" target="_blank" rel="external">https://www.jianshu.com/p/9aaccd7bb600）</a></li>
<li>联合判断<br><a href="https://www.jianshu.com/p/88ce90240396" target="_blank" rel="external">https://www.jianshu.com/p/88ce90240396</a></li>
<li>注册–登录–获取用户信息（注册的一般流程） 获取权限–获取经纬度–鉴权–生成订单（生成订单一般流程） 这样一连串的网络请求。</li>
<li>结合多个接口的数据，再更新UI；或者历史记录、购物车记录等，需要合并本地缓存和网络请求返回的数据;</li>
<li>网络请求前置条件token的获取，token可以本地缓存，本地缓存拿不到要去网络获取。同时对于token拿不到时的网络请求先等待，token获取后将等待的请求一一发出。甚至token请求需要设置重试次数，超过次数才停止请求</li>
<li>防重复操作，倒计时</li>
<li>多重缓存处理：先读取缓存更新UI，在网络请求更新UI（<a href="https://www.jianshu.com/p/7474950af2df）" target="_blank" rel="external">https://www.jianshu.com/p/7474950af2df）</a></li>
<li>多处场景需要同一个监听事件，但是每个场景注册时间点不同，如何做到事件产生之后注册的监听者也能收到回调。</li>
</ol>
<p>这些应用场景几乎是每个app都会遇到的，传统的处理方式：层层递进（回调），各种标志位控制，嵌套的if else，各种异步调用分散在代码各处，要将各个回调结果汇总，并且综合处理回调的不同状态。而且由于异步回调的特点，代码处理方式不会像同步调用那样直接可控，异步回调导致的时序问题又将问题复杂度提高了几个level。我经常会想，这种callback的异步调用方式，为何会将代码变得丑陋不堪和难以维护？设计模式中只提供了观察者模式，但是对于观察者回调复杂后，没有提出更好的解决方案。RxJava（或者说响应式编程）主要解决了这类的问题。<br>关于RxJava是如何解决以上场景中遇到的问题，以及如何和retrofit一起联合使用，短短几行无法说不清，在基于RxJava Retrofit的网络框架（二）中会详解。</p>
<h4 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h4><p>Retrofit并不实现网络请求本身（网络请求由okhttp负责），他是一个框架，为网络请求本身提供可扩展，可配置，易使用的外部封装。okhttp负责提高网络请求的性能和兼容性，Retrofit负责更好的使用他。框架的重要性不言而喻，好的框架让使用者关注更少细节，轻易的扩展。okhttp好像汽车的发动机，对于汽车性能和稳定性起到决定性作用，框架就是除了发动机以外其他部分，除了对发送机功能的整合外，漂亮的外观，舒适易用的体验才是人们愿意开这台车的原因。<br>以下列举Retrofit相对于volley Android-Async-Http等框架的优势</p>
<ol>
<li>简洁易用：通过注解配置网络参数，大量设计模式（建造者模式，工厂）简化配置和使用。</li>
<li>功能强大：支持RxJava方式（也支持callback方式），支持同步&amp;异步，</li>
<li>耦合度低，扩展性好：模块高度封装，彻底解耦。</li>
</ol>
<p>由于Android-Async-Http的停更，Google对volley基本放弃的态度，这两套框架使用者和价值日渐减少。反观okhttp，Google官方应用则广泛使用。作为okhttp的黄金搭档（同为square公司出品），Retrofit可以说是目前Android app网络请求框架的不二选择，与okhttp搭配，是性能、稳定性、兼容性、易用性都达到很高水平的框架组合。</p>
<h3 id="Observable网络框架的抽象"><a href="#Observable网络框架的抽象" class="headerlink" title="Observable网络框架的抽象"></a>Observable网络框架的抽象</h3><h4 id="Observable网络框架建立的原因"><a href="#Observable网络框架建立的原因" class="headerlink" title="Observable网络框架建立的原因"></a>Observable网络框架建立的原因</h4><ol>
<li>Retrofit已经对网络请求做了封装，为什么还要封装?<br>网络请求中对于请求流程、配置、加解密、异常处理对于每个app都是固定不变的，如果业务每次请求都自己处理逻辑，会存在冗余代码，且质量不易保证。所以我们需要基于Retrofit对请求流程、配置、加解密、异常处理等操作做二次封装，并对调用方式进行统一。</li>
<li>框架封装方式Observable是什么？<br>对网络请求二次封装（一般为异步请求），传统使用callback方式异步回调网络请求结果。但是这种callback的方式，没有利用到Retrofit的一大优势–rxjava调用，所以我们要基于rxjava调用方式，封装一个基于Observable的网络请求框架。<br>以下所说网络框架，均指基于Observable的网络请求二次封装框架。</li>
</ol>
<h4 id="Observable网络框架要解决的问题"><a href="#Observable网络框架要解决的问题" class="headerlink" title="Observable网络框架要解决的问题"></a>Observable网络框架要解决的问题</h4><p>网络框架要帮助业务处理以下几个问题：</p>
<ol>
<li>支持Get Post请求，对Request的参数业务可轻松配置</li>
<li>对Request 参数做发送前处理：组合和加密处理</li>
<li>返回Response 解密处理，Java实体化</li>
<li>返回Response code码判断及处理</li>
<li>网络请求cancle机制 progressBar配置等通用处理<br>达到的目标：业务使用框架时，只需要关注业务相关（Request参数，Response返回值的配置和处理），其他都交给框架处理。同时对于网络请求的属性可配置（error是否提示，progressBar是否显示等）</li>
</ol>
<h4 id="Observable网络框架如何实现"><a href="#Observable网络框架如何实现" class="headerlink" title="Observable网络框架如何实现"></a>Observable网络框架如何实现</h4><p>设计原则：</p>
<ol>
<li>网络请求Api返回Observable对象，作为网络请求事件的生产者：<br>生产者负责请求的发起，和返回的所有预处理。</li>
<li>为业务提供BaseObserver类，使用者实现其子类作为消费者<br>消费者基类提供对response的一般处理，消费者业务也可以使用自己Observer处理</li>
</ol>
<hr>
<p>在Observable的创建过程中，框架如何封装？</p>
<p>首先我们需要一个Manager或Helper全局实例，通过他可以发起网络请求，一般设计为单例全局持有，有利于网络请求一些资源的共用。<br>我们暂定为NetHelper,其网络请求接口定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request, final TypeReference&lt;R&gt; t）</div></pre></td></tr></table></figure></p>
<p>sendRequest方法中，我们来看下Observable对象的生成过程：此处我们基于Retrofit本身Observable生成方式，我们先看下Retrofit最基础是如何创建Observable的。</p>
<p>第一步，定义Request，Request类的定义在Retrofit里通过注解的方式完成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Request &#123;</div><div class="line"></div><div class="line">    @POST(&quot;&#123;url&#125;&quot;)</div><div class="line">    Observable&lt;JSONObject&gt; postJSONResult(@Path(value=&quot;url&quot;,encoded =true) String url, @FieldMap Map&lt;String, String&gt; params);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到我们的定义方式是通用的（每个request都可以复用），每个request都是通过postJSONResult方法获取observable，传入自己的url和params即可完成不同的网络请求。</p>
<p>第二步，创建retrofit<br>NetHelper.java中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 初始化okhttp</div><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">        .build();</div><div class="line"></div><div class="line">// 初始化Retrofit</div><div class="line">retrofit = new Retrofit.Builder()</div><div class="line">        .client(client)</div><div class="line">        .baseUrl(Request.HOST)</div><div class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">        .addConverterFactory(MyConverterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure></p>
<p>OkHttpClient每次请求的时候都要创建，注意：OkHttpClient.Builder()中有ConnectionPool作为OkHttp的连接池要复用，否则请求过多时容易导致内存溢出。<br>创建Retrofit实例过程中，设置了okHttpClient，baseUrl，调用方式rxJava（通过addCallAdapterFactory）<br>GsonConverterFactory这些都是一般的写法，GsonConverterFactory作用是把Response通过GSon转为javaBean。App业务中一般是先解密后Gson转，所以此处使用MyConverterFactory实现解密功能。</p>
<p>第三步，生成Observable<br>这一步是生成observable的过程，与httpRequest本身有关（我们前面提到了Request类是一个支持Retrofit通用类，业务自定义的请求类HttpRequest实现了 getURLParam() getURLAction()等方法）,所以这个获取Observable的方法可以放到HttpRequest中进行（NetHelper.sendRequest方法是传入了HttpRequest对象的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Request request = retrofit.create(Request.class);</div><div class="line">return request.postJSONResult(getURLAction(),getURLParam());</div></pre></td></tr></table></figure></p>
<p>对于httpRequest中入参的组合和加密，实现在getURLParam()方法里。<br>备注：我们的网络post请求params是query形式的，如果是body表单，还需要另外的处理方式。</p>
<p>以上三步，已经初步将Observable返回。通过以上几步只是基于Retrofit自身的Observable创建方法做了一些封装。下面的处理是框架的重点和核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）&#123;</div><div class="line"></div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">                .compose(ResponseTransformer.handleResult())</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>注意：sendRequest方法一定要Observable所有的链式操作执行完后在返回。</p>
<hr>
<p>NetHelper.getApiObservable方法后，再加上网络请求的线程配置，这时候业务subscribe消费者，就可以直接得到解密后的JsonObject了。注意此时是string而不是Retrofit通常的JavaBean，这是因为我们要定义一个通用的Request类，将其接口返回值定义为了Observable<jsonobject>,所以我们还需要一步转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.map(new Function&lt;JSONObject,R&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public R apply(JSONObject jsonObject) throws Exception &#123;</div><div class="line">        if (jsonObject != null)&#123;</div><div class="line">            R response = jsonObject.toJavaObject(con);</div><div class="line">            if (orgRequest != null) &#123;</div><div class="line">                HttpHelper.printHttpLog(orgRequest, jsonObject.toString());</div><div class="line">            &#125;</div><div class="line">            return response;</div><div class="line">        &#125; else &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></jsonobject></p>
<p>response的异常处理，progressbar的显示等，也需要架构统一处理。我们引入了ResponseTransformer，你可以把他理解为map操作符，在交给消费者前对response结果做了处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Serializable&gt; ObservableTransformer&lt;T, T&gt; handleResult() &#123;</div><div class="line">    return upstream -&gt; upstream</div><div class="line">            .onErrorResumeNext(new ErrorResumeFunction&lt;T&gt;())</div><div class="line">            .flatMap(new ResponseFunction&lt;T&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ErrorResumeFunction&lt;T extends Serializable&gt; implements Function&lt;Throwable, ObservableSource&lt;? extends T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;? extends T&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">        return Observable.error(CustomException.handleException(throwable));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ResponseFunction&lt;T extends Serializable&gt; implements Function&lt;T, ObservableSource&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;T&gt; apply(T tResponse) throws Exception &#123;</div><div class="line">        int code = tResponse.getCode();</div><div class="line">        String message = tResponse.getMsg();</div><div class="line"></div><div class="line">        if (code == SUCCESS.value()) &#123;</div><div class="line">            return Observable.just(tResponse);</div><div class="line">        &#125; else &#123;</div><div class="line">            return Observable.error(new ApiException(code, message));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出对于事件流upstream，做了正常和异常的再分流，对于服务器错误（超时，404等）通过onErrorResumeFunction继续抛出Observable.error,<br>对于正常返回，根据response中code的定义，只有SUCCESS时才返回数据Observable.just(),其他情况（业务错误等）作为错误情况继续抛出。<br>你可能有两个疑问，一个是response中code的判定可以在observer中处理吗，另一个是服务器错误和业务错误为何都作为error抛出。</p>
<p>第一个问题：<br>code值的判定不可以在observer中处理，而必须在Observable一端处理。因为Observable形式的网络请求是作为数据流中的一环出现的，可能当前网络请求只是一连串异步调用（rxjava调用）的一环。<br>第二个问题：<br>response中code!=SUCCESS是业务错误的情况，必须向数据流中发出，让业务处理此异常。（那同时对于Response的定义也是，code!=SUCCESS必须是不需要业务处理的情况才行）<br>两种错误都抛出error（内部code不同），方便架构使用者在事件响应时，既能捕捉所有错误，又能区分错误的类型。</p>
<hr>
<p>哪些处理放到了BaseObserver中?</p>
<p>BaseObserver顾名思义，是架构使用者在rxjava流式调用最后一步所使用的观察者基类，他适合将网络请求的UI响应放入其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public  abstract class   BaseObserver&lt;T &gt; implements Observer&lt;T&gt;&#123;</div><div class="line">  /**</div><div class="line">    * 请求成功</div><div class="line">    * @param t</div><div class="line">    */</div><div class="line">   public abstract void onSuccess(T t);</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 请求失败</div><div class="line">    * @param</div><div class="line">    * @param object</div><div class="line">    */</div><div class="line">   public abstract void onFail(ApiException);</div><div class="line"></div><div class="line">   @Override</div><div class="line">    public void onSubscribe(Disposable d) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNext(T t) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">        onSuccess(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">      if (isShowProgress()) &#123;</div><div class="line">          showProgress(false);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (e instanceof ApiException)&#123;</div><div class="line">            ApiException apiException = (ApiException)e;</div><div class="line">            switch(apiException.getCode())&#123;</div><div class="line">              case:NOT_LOGIN</div><div class="line">                break;</div><div class="line">              case:TOKEN_ERROR</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求是否loading显示</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowProgress()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BaseObserver中，我们可以看到处理了showProgress，ApiException做了处理。同时可以对progressBar是否显示做配置。可以满足一般的网络请求架构使用，当然也可以自行subscribe自己的Observer。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/11/LRecycler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/11/LRecycler/" itemprop="url">下拉刷新分页加载控件</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-11T00:00:00+08:00">
                2018-09-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc07429ae2de?w=900&amp;h=588&amp;f=jpeg&amp;s=30221" alt=""></p>
<h2 id="一篇文章撸遍下拉刷新-分页加载控件"><a href="#一篇文章撸遍下拉刷新-分页加载控件" class="headerlink" title="一篇文章撸遍下拉刷新 分页加载控件"></a>一篇文章撸遍下拉刷新 分页加载控件</h2><p>本文的研究对象是，在实际开发中经常用到的下拉刷新和分页加载功能。这两个功能往往相伴相生，下拉刷新是基于交互体验上的功能，已经是普遍工人的移动端的数据刷新交互（不限于列表）；分页加载一般考虑到后台数据的分页请求，降低后台的压力和网络延迟。<br>有没有将二者结合的比较好的第三方控件呢，本文将针对主流github三方控件，带你一一解读。</p>
<hr>
<h3 id="主流下拉刷新控件横评"><a href="#主流下拉刷新控件横评" class="headerlink" title="主流下拉刷新控件横评"></a>主流下拉刷新控件横评</h3><p>备注：我将从实现原理、易用性、扩展性、稳定性四个方面比较<br>易用性：包括<br>1、使用是否方便，xml java均可配置使用<br>2、是否将常用的逻辑功能封装（分页计算、footer显示与否等），使用者不关心细节<br>3、对一些常用的扩展是否已支持可配置（如header的自定义样式等）<br>扩展性：包括<br>1、支持的下拉、分页的ViewGroup是否可方便扩展<br>2、header footer等是否扩展方便<br>稳定性：包括<br>1、github活跃性，issue是否及时处理<br>2、上线后控件内部crash</p>
<h4 id="一、最早的先行者：XListView"><a href="#一、最早的先行者：XListView" class="headerlink" title="一、最早的先行者：XListView"></a>一、最早的先行者：XListView</h4><p>（<a href="https://github.com/Maxwin-z/XListView-Android）" target="_blank" rel="external">https://github.com/Maxwin-z/XListView-Android）</a></p>
<h5 id="1、实现原理："><a href="#1、实现原理：" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>XListView直接extends ListView，使用也和Listview一样，header和footer也是采用ListView自带的功能，仅对二者的layout做了封装XListViewFooter和XListViewHeader。<br>从代码结构来看，非常简单。header和footer的显示与否，通过listview的onTouchEvent来判断。<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc075a657c56?w=445&amp;h=313&amp;f=png&amp;s=36152" alt=""></p>
<h5 id="2、易用性："><a href="#2、易用性：" class="headerlink" title="2、易用性："></a>2、易用性：</h5><p>与ListView同，但是下拉和分页的可配置性几乎没有，常用封装全无</p>
<h5 id="3、扩展性："><a href="#3、扩展性：" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5><p>很差，只能在使用ListView时使用，扩展需要改动代码，代码本身扩展性考虑很少。</p>
<h5 id="4、稳定性："><a href="#4、稳定性：" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5><p>github已停更，有些线上经典crash难于解决。</p>
<ul>
<li>作为最早Android下拉刷新功能的实践者，仅有有历史意义</li>
</ul>
<hr>
<h4 id="二、广泛应用者：PullToRefresh"><a href="#二、广泛应用者：PullToRefresh" class="headerlink" title="二、广泛应用者：PullToRefresh"></a>二、广泛应用者：PullToRefresh</h4><p>(<a href="https://github.com/chrisbanes/Android-PullToRefresh" target="_blank" rel="external">https://github.com/chrisbanes/Android-PullToRefresh</a>)</p>
<h5 id="1、实现原理：-1"><a href="#1、实现原理：-1" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>其类图可以较好的说明，其架构方式：<br><img src="https://user-gold-cdn.xitu.io/2018/11/26/1674fc075b86b5c8?w=1017&amp;h=606&amp;f=png&amp;s=85629" alt=""><br>PullToRefresh基本奠定了经典下拉刷新控件的架构形式：</p>
<ul>
<li>1）一部分是下拉和分页的骨架：核心content的加载和扩展、footer和header的加载、state的切换</li>
<li>2）一部分是footer和header的处理：footer header的交互、定制和扩展基于state。<br>依据以上两部分，基于IPullToRefresh和 ILoadingLayout两个接口开发。</li>
</ul>
<ol>
<li>核心骨架<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">private void init(Context context, AttributeSet attrs) &#123;</div><div class="line">	setGravity(Gravity.CENTER);</div><div class="line"></div><div class="line">	ViewConfiguration config = ViewConfiguration.get(context);</div><div class="line">	mTouchSlop = config.getScaledTouchSlop();</div><div class="line"></div><div class="line">	....//Parse styleable</div><div class="line"></div><div class="line">	// Refreshable View 用于扩展</div><div class="line">	// By passing the attrs, we can add ListView/GridView params via XML</div><div class="line">	mRefreshableView = createRefreshableView(context, attrs);</div><div class="line">	addRefreshableView(context, mRefreshableView);</div><div class="line"></div><div class="line">	// We need to create now layouts now</div><div class="line">   	//createLoadingLayout方法构造header 和 footer</div><div class="line">	mHeaderLayout = createLoadingLayout(context, Mode.PULL_FROM_START, a);</div><div class="line">	mFooterLayout = createLoadingLayout(context, Mode.PULL_FROM_END, a);</div><div class="line"></div><div class="line"></div><div class="line">	if (a.hasValue(R.styleable.PullToRefresh_ptrOverScroll)) &#123;</div><div class="line">		mOverScrollEnabled = 					  a.getBoolean(R.styleable.PullToRefresh_ptrOverScroll, true);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if 	(a.hasValue(R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled)) &#123;</div><div class="line">		mScrollingWhileRefreshingEnabled = a.getBoolean(</div><div class="line">				R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled, false);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	// Let the derivative classes have a go at handling attributes, then</div><div class="line">	// recycle them...</div><div class="line">	handleStyledAttributes(a);</div><div class="line">	a.recycle();</div><div class="line"></div><div class="line">	// Finally update the UI for the modes</div><div class="line">   	//updateUIForMode 用于添加footer和header到linearlayout中</div><div class="line">	updateUIForMode();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>PullToRefreshBase本身是LinearLayout，其支持横向和纵向的下拉刷新，把contentView（mRefreshableView）和footer header作为childView添加到其中。</p>
<ul>
<li>扩展方式：<br>abstract方法createRefreshableView（），在子类中实现用于扩展contentView<br>footer header的扩展通过createLoadingLayout()返回，只要继承自LoadingLayout即可扩展。当然控件本身提供了集中常用的Loadinglayout(FlipLoadingLayout RotateLoadingLayout)</li>
<li>交互处理：<br>如何从手势的变化决定header以及footer的state呢？是通过onInterceptTouchEvent和OnTouchEvent。<br>和其他的touch事件处理类似，onInterceptTouchEvent方法作为前置准备，onTouchEvent方法实际处理手势操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public final boolean onTouchEvent(MotionEvent event) &#123;</div><div class="line"></div><div class="line">  if (!isPullToRefreshEnabled()) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  // If we&apos;re refreshing, and the flag is set. Eat the event</div><div class="line">  if (!mScrollingWhileRefreshingEnabled &amp;&amp; isRefreshing()) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  if (event.getAction() == MotionEvent.ACTION_DOWN &amp;&amp; event.getEdgeFlags() != 0) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  switch (event.getAction()) &#123;</div><div class="line">    case MotionEvent.ACTION_MOVE: &#123;</div><div class="line">      if (mIsBeingDragged) &#123;</div><div class="line">        mLastMotionY = event.getY();</div><div class="line">        mLastMotionX = event.getX();</div><div class="line">        pullEvent();//处理拉动过程中，header footer状态的变化</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    case MotionEvent.ACTION_DOWN: &#123;</div><div class="line">      if (isReadyForPull()) &#123;</div><div class="line">        mLastMotionY = mInitialMotionY = event.getY();</div><div class="line">        mLastMotionX = mInitialMotionX = event.getX();</div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    case MotionEvent.ACTION_CANCEL:</div><div class="line">    case MotionEvent.ACTION_UP: &#123;</div><div class="line">      //ACTION_UP事件的处理，在不同state下松手，处理方式的不同</div><div class="line">      if (mIsBeingDragged) &#123;</div><div class="line">        mIsBeingDragged = false;</div><div class="line"></div><div class="line">        if (mState == State.RELEASE_TO_REFRESH</div><div class="line">            &amp;&amp; (null != mOnRefreshListener || null != mOnRefreshListener2)) &#123;</div><div class="line">          //拉动结束，在RELEASE_TO_REFRESH状态下松手，变为REFRESHING</div><div class="line">          setState(State.REFRESHING, true);</div><div class="line">          return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If we&apos;re already refreshing, just scroll back to the top</div><div class="line">        if (isRefreshing()) &#123;</div><div class="line">          //拉动结束，在REFRESHING状态下松手，回到原点</div><div class="line">          smoothScrollTo(0);</div><div class="line">          return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        // If we haven&apos;t returned by here, then we&apos;re not in a state</div><div class="line">        // to pull, so just reset</div><div class="line">        //拉动结束，在其他状态（PULL_TO_REFRESH）下松手，reset到初始状态</div><div class="line">        setState(State.RESET);</div><div class="line"></div><div class="line">        return true;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Actions a Pull Event</div><div class="line"> *</div><div class="line"> * @return true if the Event has been handled, false if there has been no</div><div class="line"> *         change</div><div class="line"> */</div><div class="line">private void pullEvent() &#123;</div><div class="line">  final int newScrollValue;</div><div class="line">  final int itemDimension;</div><div class="line">  final float initialMotionValue, lastMotionValue;</div><div class="line"></div><div class="line"></div><div class="line">  switch (mCurrentMode) &#123;</div><div class="line">    case PULL_FROM_END:</div><div class="line">      newScrollValue = Math.round(Math.max(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">      itemDimension = getFooterSize();</div><div class="line">      break;</div><div class="line">    case PULL_FROM_START:</div><div class="line">    default:</div><div class="line">      newScrollValue = Math.round(Math.min(initialMotionValue - lastMotionValue, 0) / FRICTION);</div><div class="line">      itemDimension = getHeaderSize();</div><div class="line">      break;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  setHeaderScroll(newScrollValue);</div><div class="line"></div><div class="line">  if (newScrollValue != 0 &amp;&amp; !isRefreshing()) &#123;</div><div class="line">    float scale = Math.abs(newScrollValue) / (float) itemDimension;</div><div class="line">    switch (mCurrentMode) &#123;</div><div class="line">      case PULL_FROM_END://上拉分页</div><div class="line">        mFooterLayout.onPull(scale);//根据滑动的位置更新footerLayout</div><div class="line">        break;</div><div class="line">      case PULL_FROM_START://下拉刷新</div><div class="line">      default:</div><div class="line">        mHeaderLayout.onPull(scale);//根据滑动的位置更新headerLayout</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //根据滑动的位置（是否超过阈值），决定状态PULL_TO_REFRESH or RELEASE_TO_REFRESH</div><div class="line">    if (mState != State.PULL_TO_REFRESH &amp;&amp; itemDimension &gt;= Math.abs(newScrollValue)) &#123;</div><div class="line">      setState(State.PULL_TO_REFRESH);</div><div class="line">    &#125; else if (mState == State.PULL_TO_REFRESH &amp;&amp; itemDimension &lt; Math.abs(newScrollValue)) &#123;</div><div class="line">      setState(State.RELEASE_TO_REFRESH);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上代码容易理解下拉刷新的逻辑脉络，但是上拉分页加载是怎么实现的呢?<br>PullToRefreshBase控件通过mCurrentMode来区分上拉和下拉，其实上拉和下拉的逻辑，从整体上是可以归一的，有几个关键点</p>
<ul>
<li>1、判断上拉 下拉的逻辑阈值：isReadyForPullStart（）isReadyForPullEnd（）分别是下拉 上拉的阈值方法，子类需要根据 mRefreshableView来实现</li>
<li>2、在不同的state下做不同的处理: 两者都有 reset PULL_TO_REFRESH RELEASE_TO_REFRESH REFRESHING等状态，上拉不需要区分PULL_TO_REFRESH RELEASE_TO_REFRESH两种state而已。所以既然都是基于一套state的处理方案，那么根据手势滑动方向决定当前mCurrentMode，进而交给header 或 footer来处理state就是可行的。</li>
</ul>
<ol>
<li>footer和header的扩展和处理</li>
</ol>
<p>刚才说到了footer和header是在同一套state状态下的处理机制，其回调也类似。所以两者继承同一接口和基类。PullToRefreshBase控件采用了Proxy的方式，实现了二者的统一调用。<br>也就是说LoadingLayoutProxy 、headerLoadingLayout、footerLoadingLayout均实现ILoadingLayout，LoadingLayoutProxy是headerLoadingLayout与footerLoadingLayout二者的代理，在state的流转过程中，通过LoadingLayoutProxy的调用，达到header 和footer两个loadingLayout的同步调用。<br>LoadingLayout基类已经实现了基本的layout，我们自己定制的子类（例如CustomLoadingLayout）,对里面的动画，文案等进行定制即可，基于ILoadingLayout接口完全重写一个新的,目前看不行，一方面PullToRefreshBase控件内部很多地方强转到LoadingLayout。而且LoadingLayout基类（abstract类）预留了stated的回调抽象方法，供子类实现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">protected abstract void onLoadingDrawableSet(Drawable imageDrawable);</div><div class="line"></div><div class="line">protected abstract void onPullImpl(float scaleOfLayout);</div><div class="line"></div><div class="line">protected abstract void pullToRefreshImpl();</div><div class="line"></div><div class="line">protected abstract void refreshingImpl();</div><div class="line"></div><div class="line">protected abstract void releaseToRefreshImpl();</div><div class="line"></div><div class="line">protected abstract void resetImpl();</div></pre></td></tr></table></figure></p>
<h5 id="2、易用性：-1"><a href="#2、易用性：-1" class="headerlink" title="2、易用性："></a>2、易用性：</h5><ul>
<li>1、使用是否方便，xml和java代码都可以初始化和配置控件，这是控件设计初期就考虑到的</li>
<li>2、我们知道为了保证扩展性，架构上的实现不能过于具体，否则灵活性降低。架构上基于接口和抽象类进行设计，能保证在整体架构内部方便扩展。同时也提供了一些常用的具体实现类，比如PullToRefreshListView FlipLoadingLayout。</li>
<li>3、一些业务上的常用逻辑：（分页计算、footer多个状态的显示等）没有集成，需要二次开发<h5 id="3、扩展性：-1"><a href="#3、扩展性：-1" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5></li>
<li>mRefreshableView的设计理念，可以说让控件理论上可以支持任何视图类（ViewGroup）的下拉刷新操作，比如后期扩展RecyclerView、ViewPager等。</li>
<li>从类图中可以看出 PullToRefreshBase的多层子类，设计合理，层次分明。二次开发中可以选择合适的基类进行扩展。</li>
<li>LoadingLayoutProxy机制的引入，为实现更多LoadingLayout的state流转提供了可能。</li>
<li>模板方法设计模式，基于接口开发，abstract基类，易于扩展和维护<h5 id="4、稳定性：-1"><a href="#4、稳定性：-1" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5>github star 8700多，多个工程中考验，类库内部崩溃率较低。</li>
</ul>
<hr>
<h4 id="三、官方控件：SwipeRefreshLayout"><a href="#三、官方控件：SwipeRefreshLayout" class="headerlink" title="三、官方控件：SwipeRefreshLayout"></a>三、官方控件：SwipeRefreshLayout</h4><h5 id="一两句就能说清："><a href="#一两句就能说清：" class="headerlink" title="一两句就能说清："></a>一两句就能说清：</h5><p>这个控件作为targetView（比如listview）的parentView出现，而且SwipeRefreshLayout只能有一个childView。<br>交互上比较单一，materialDesign风格，loading图标在targetView之上显示，targetView本身可以是任何view，扩展性没的说。</p>
<hr>
<h4 id="四、基于RecyclerView的控件：LRecyclerView"><a href="#四、基于RecyclerView的控件：LRecyclerView" class="headerlink" title="四、基于RecyclerView的控件：LRecyclerView"></a>四、基于RecyclerView的控件：LRecyclerView</h4><p>LRecyclerView是csdn大牛‘一叶飘舟’所著，设计的初衷是为了打造一个更为好用的RecyclerView,一切基于RecyclerView架构搭建。</p>
<ul>
<li>增加了header footer功能（不同于listview，为了扩展性，原生的RecyclerView并不支持header和footer）。</li>
<li>增加了下拉刷新和上拉分页加载功能（这个功能后来被更广泛使用，所以在已有架构上支持了PullScrollView、PullWebView）。最终达到了现有的面貌。</li>
<li>目前我们已经将RecyclerView作为开发的主力控件，那么基于RecyclerView的一个易用性、扩展性和稳定性各方面都均衡的控件，就是我们研究的目标。</li>
</ul>
<h5 id="1、实现原理：-2"><a href="#1、实现原理：-2" class="headerlink" title="1、实现原理："></a>1、实现原理：</h5><p>有了以上的背景，我们对LRecyclerView这个控件会有一个大概认识。我们看下代码分布：<br><img src="https://user-gold-cdn.xitu.io/2018/11/27/1675418224fa413a?w=872&amp;h=1304&amp;f=png&amp;s=316640" alt=""><br>从他的代码分布可以看出，基本是围绕LRecyclerview开展的。类之间的相互关系比较简单，就不用类图展开了。</p>
<p>以下我们将从两个方面分析实现原理 </p>
<ul>
<li>1、LRecyclerView是如何在RecyclerView基础上加上footer和header；</li>
<li>2、LRecyclerView是如何实现下拉刷新和上拉分页加载的。</li>
</ul>
<ol>
<li>LRecyclerView是如何在RecyclerView基础上加上footer和header的：<br>我们知道listview原生支持footer和header，如果我们看过listview的源码的话，就知道他们是在通过adapter实现的，listView在添加header时代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public void addHeaderView(View v, Object data, boolean isSelectable) &#123;</div><div class="line"></div><div class="line">  if (mAdapter != null) &#123;</div><div class="line">    //如果是设置header，那么通过HeaderViewListAdapter的代理wrapperadapter来包装真正的adapter</div><div class="line">      if (!(mAdapter instanceof HeaderViewListAdapter)) &#123;</div><div class="line">          wrapHeaderListAdapterInternal();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      // In the case of re-adding a header view, or adding one later on,</div><div class="line">      // we need to notify the observer.</div><div class="line">      if (mDataSetObserver != null) &#123;</div><div class="line">          mDataSetObserver.onChanged();</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>当添加header时，将mAdapter通过方法wrapHeaderListAdapterInternal()包装，HeaderViewListAdapter是mAdapter的代理类，可以看到类内部有成员变量mAdapter,就是ListView的使用者真实创建的adapter。<br>通过以下代码我们就一目了然他的实现原理了：实现原理请参考注释。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public View getView(int position, View convertView, ViewGroup parent) &#123;</div><div class="line">    // Header (negative positions will throw an IndexOutOfBoundsException)</div><div class="line">    int numHeaders = getHeadersCount();</div><div class="line">    //如果是position指向header，那么从mHeaderViewInfos返回对应view</div><div class="line">    if (position &lt; numHeaders) &#123;</div><div class="line">        return mHeaderViewInfos.get(position).view;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Adapter</div><div class="line">    final int adjPosition = position - numHeaders;</div><div class="line">    int adapterCount = 0;</div><div class="line">    if (mAdapter != null) &#123;</div><div class="line">        adapterCount = mAdapter.getCount();</div><div class="line">        //如果是position指向mAdapter实际列表数据，那么调用mAdapter.getView</div><div class="line">        if (adjPosition &lt; adapterCount) &#123;</div><div class="line">            return mAdapter.getView(adjPosition, convertView, parent);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //如果是position指向footer，那么从mFooterViewInfos返回对应view</div><div class="line">    // Footer (off-limits positions will throw an IndexOutOfBoundsException)</div><div class="line">    return mFooterViewInfos.get(adjPosition - adapterCount).view;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时getCount getItemType getItem等实现均对 footer和header进行了考虑，这样包装类封装了mAdapter本身和 footer header，将他们作为一个整体提供给listview。<br>本控件的作者借鉴了这个思路，设计了代理类LRecyclerViewAdapter，类里类似的也含有mInnerAdapter实际的adapter，mHeaderViews和mFooterViews则用于保存信息。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public RecyclerView.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</div><div class="line">    //分别RefreshHeader header footer三种类型返回不同的ViewHolder</div><div class="line">    //这里RefreshHeader没有像PullRefreshView一样作为listview之外的view存在，而是放入</div><div class="line">    //adapter内部让listview(RecyclerView)一起加载。</div><div class="line">    //如何虽手势控制RefreshHeader的Layout，后面详细说。</div><div class="line">    if (viewType == TYPE_REFRESH_HEADER) &#123;</div><div class="line">        return new ViewHolder(mRefreshHeader.getHeaderView());</div><div class="line">    &#125; else if (isHeaderType(viewType)) &#123;</div><div class="line">        return new ViewHolder(getHeaderViewByType(viewType));</div><div class="line">    &#125; else if (viewType == TYPE_FOOTER_VIEW) &#123;</div><div class="line">        return new ViewHolder(mFooterViews.get(0));</div><div class="line">    &#125;</div><div class="line">    return mInnerAdapter.onCreateViewHolder(parent, viewType);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和listview的HeaderViewListAdapter一样，LRecyclerViewAdapter也是类似的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public int getItemCount() &#123;</div><div class="line">    if (mInnerAdapter != null) &#123;</div><div class="line">        //此处+1，是考虑到RefreshHeader，就是说header和RefreshHeader是不同的功能，可能同时出现</div><div class="line">        //而footer作为一般的footer或者上拉加载的footer，只会出现一种</div><div class="line">        return getHeaderViewsCount() + getFooterViewsCount() + mInnerAdapter.getItemCount() + 1;</div><div class="line">    &#125; else &#123;</div><div class="line">        return getHeaderViewsCount() + getFooterViewsCount() + 1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在阅读以上代码时，大家不免会有个疑问，LRecyclerView的使用上并不像listview那样简练，LRecyclerView在设置adapter时，需要手动创建innerAdapter和wrapperadapter，将innerAdapter包裹进WrapperAdapter后设置给LRecyclerView；反观listview会根据header/footer使用情况自动创建wrapperadapter,使用者并不知道代理类的存在。此处的设计在文章的最后会阐述我的一些看法。</p>
<ol>
<li>LRecyclerView是如何实现下拉刷新和上拉分页的</li>
</ol>
<ul>
<li>如何下拉刷新：LRecyclerView下拉刷新也是是通过onInterceptTouchEvent和onTouchEvent来实现的，具体的实现和PullRefreshView类似，此处不单独分析了。通过接口IRefreshHeader来控制RefreshHeader的状态改变。刷新后通过OnRefreshListener接口通知业务刷新数据。</li>
<li>如何分页加载：利用RecyclerView的onScrolled回调，控件滑动过程中不断回调此方法，通过判断是否滑动到最底部来决定是否上拉加载，代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">if (mLoadMoreListener != null &amp;&amp; mLoadMoreEnabled) &#123;</div><div class="line">    int visibleItemCount = layoutManager.getChildCount();</div><div class="line">    int totalItemCount = layoutManager.getItemCount();</div><div class="line">    if (visibleItemCount &gt; 0</div><div class="line">            &amp;&amp; lastVisibleItemPosition &gt;= totalItemCount - 1</div><div class="line">            &amp;&amp; totalItemCount &gt; visibleItemCount</div><div class="line">            &amp;&amp; !isNoMore</div><div class="line">            &amp;&amp; !mRefreshing) &#123;</div><div class="line"></div><div class="line">        mFootView.setVisibility(View.VISIBLE);</div><div class="line">        if (!mLoadingData) &#123;</div><div class="line">            mLoadingData = true;</div><div class="line">            //更新footerView的状态</div><div class="line">            mLoadMoreFooter.onLoading();</div><div class="line">            if (mWrapAdapter != null) &#123;</div><div class="line">                //回调业务 分页加载更多</div><div class="line">                mWrapAdapter.loadMore(mLoadMoreListener);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="2、易用性：-2"><a href="#2、易用性：-2" class="headerlink" title="2、易用性："></a>2、易用性：</h5><p>此控件将IRefreshHeader和ILoadMoreFooter两个接口拆分，相比较PullRefreshView对于上拉footer的处理更加直接和便捷。两个不同接口更加适应于分页加载的不同状态。并且不同状态的文案是可以定制的：</p>
<p><code>public void setFooterViewHint(String loading, String noMore, String noNetWork)</code></p>
<p>这样对于上拉分页的情况，不需要业务再对控件做二次开发（PullRefreshView需要），是更加易用的。<br>但是业务上对于分页加载需求的逻辑负担还是比较大，集中在以下两点</p>
<ul>
<li>1）分页pageNumber pageSize等需要业务维护，而这些逻辑都是通用的。</li>
<li>2）判断是否需要加载更多，还是没有更多数据，的逻辑业务需要维护，这些逻辑也是通用的。</li>
</ul>
<p>基于此，我们针对LRecyclerView的分页加载功能做了二次封装。这两个问题都可以在wrapperAdapter中通过统一的逻辑来处理，只不过业务加载后要要通过接口ILoadCallback通知控件：</p>
<p>我们自定义的ILoadCallback接口，业务在onLoadMore处理完后，要根据返回的结果调用的接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public interface ILoadCallback &#123;</div><div class="line">    //业务loadMore的结果 success和failue都通知wrapperAdapter</div><div class="line">    </div><div class="line">    void onSuccess();</div><div class="line"></div><div class="line">    void onFailure();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>WrapperAdapter对接口调用的处理：维护pageNumber,和footer是否加载更多等状态<br>此前这些逻辑都需要重复写在业务代码中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">private ILoadCallback mLoadCallback = new ILoadCallback() &#123;</div><div class="line">  @Override</div><div class="line">  public void onSuccess() &#123;</div><div class="line">      notifyDataSetChanged();</div><div class="line">      if ((mInnerAdapter.getItemCount() % getItemNumInPage()) == 0)&#123;</div><div class="line">        //判断还需要加载下一页</div><div class="line">          mCurrentPage++;</div><div class="line">          if (mLRecyclerView != null) &#123;</div><div class="line">              mLRecyclerView.setNoMore(false);</div><div class="line">          &#125;</div><div class="line">      &#125; else &#123;</div><div class="line">        //判断没有更多数据，并将footerview设置为noMore</div><div class="line">          if (mLRecyclerView != null) &#123;</div><div class="line">              mLRecyclerView.setNoMore(true);</div><div class="line">          &#125;</div><div class="line">      &#125;</div><div class="line">      if (mLRecyclerView != null) &#123;</div><div class="line">          mLRecyclerView.refreshComplete(getItemNumInPage());</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override</div><div class="line">  public void onFailure() &#123;</div><div class="line">    //失败时统一提示，并集成再次点击，多加载一次的功能</div><div class="line">      mLRecyclerView.refreshComplete(getItemNumInPage());</div><div class="line">      mLRecyclerView.setOnNetWorkErrorListener(new OnNetWorkErrorListener() &#123;</div><div class="line">          @Override</div><div class="line">          public void reload() &#123;</div><div class="line">              if (mLoadMoreCallback != null) &#123;</div><div class="line">                  mLoadMoreCallback.onLoadMore(mCurrentPage, getItemNumInPage(), mLoadCallback);</div><div class="line">              &#125;</div><div class="line">          &#125;</div><div class="line">      &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>经过这样进一步的封装，LRecyclerView的使用易用性进一步提升了。可以说比PullRefreshView本身的易用性要强一些，尤其是在分页加载的逻辑封装方面</p>
<h5 id="3、扩展性：-2"><a href="#3、扩展性：-2" class="headerlink" title="3、扩展性："></a>3、扩展性：</h5><p>PullRefreshView自身支持所有ViewGroup的下拉刷新。我觉得LRecyclerView与PullRefreshView相比，在架构上牺牲了一些扩展性，但易用性有很大的提升，应用场景有较强的针对性。实际使用中，利用Recyclerview自身很强的扩展性，就可以应付大部分使用场景。</p>
<h5 id="4、稳定性：-2"><a href="#4、稳定性：-2" class="headerlink" title="4、稳定性："></a>4、稳定性：</h5><p>github star数在2000以上，issue修改及时，在二次开发的过程中，上拉分页的footer状态维护有些小bug，但是基本不影响稳定性，产品上线后控件的崩溃率一直很低。基本可以放心使用。</p>
<h5 id="5、其他的思考："><a href="#5、其他的思考：" class="headerlink" title="5、其他的思考："></a>5、其他的思考：</h5><p>wrapperAdapter的设置：<br>文中提及过的，WrapperAdapter和innerAdapter都需要在业务上新建有点鸡肋（因为可以在LRecyclerView setAdatper时，内部创建wrapperAdapter，和listview的做法一致），作者这么做的原因，我想可能是WrapperAdapter承载了很多框架业务的功能，那么业务持有此变量可以非常方便的调用WrapperAdapter的接口。在我看来，较为合理的方式还是将WrapperAdapter不对外暴露，将原来WrapperAdapter的对外接口改到LRecyclerView来实现。这样用户调用方便，同时对控件的封装性更好。<br>此封装方案我在demo project中试验过，没有太大问题，可能有些细节需要处理，后续我们的控件二次开发会采用这种方式。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在我们自己的项目演进过程中，经历从xlistview到PullRefreshView到LRecyclerView的转变，所以对各自控件的优点、劣势，适用范围都比较清楚。之所以最终将LRecyclerView最为主力控件，除了文中提到的原因以外，还有比较关键的一点：在分页加载的二次开发中，LRecyclerView给予了足够的扩展性，也为今后我们功能的拓展提供了足够的信心。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/JVM GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/JVM GC/" itemprop="url">JVM GC原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="对象的四种引用类型"><a href="#对象的四种引用类型" class="headerlink" title="对象的四种引用类型"></a>对象的四种引用类型</h3><h3 id="JVM-GC原理"><a href="#JVM-GC原理" class="headerlink" title="JVM GC原理"></a>JVM GC原理</h3><h3 id="LeakCanary开源库-对泄漏的分析原理（haha库）"><a href="#LeakCanary开源库-对泄漏的分析原理（haha库）" class="headerlink" title="LeakCanary开源库 对泄漏的分析原理（haha库）"></a>LeakCanary开源库 对泄漏的分析原理（haha库）</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/LNMP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/LNMP/" itemprop="url">LNMP环境搭建 及多端口访问</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="LNMP的搭建"><a href="#LNMP的搭建" class="headerlink" title="LNMP的搭建"></a>LNMP的搭建</h3><h3 id="多个端口的设定"><a href="#多个端口的设定" class="headerlink" title="多个端口的设定"></a>多个端口的设定</h3><h3 id="wordpress搭建"><a href="#wordpress搭建" class="headerlink" title="wordpress搭建"></a>wordpress搭建</h3><h3 id="shadowsocks搭建"><a href="#shadowsocks搭建" class="headerlink" title="shadowsocks搭建"></a>shadowsocks搭建</h3><h3 id="hbase搭建"><a href="#hbase搭建" class="headerlink" title="hbase搭建"></a>hbase搭建</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/IntelliJplugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/IntelliJplugin/" itemprop="url">SGsonFormat --- Android Studio插件二次开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542447863363&amp;di=6ed34059d7700c6c96b3249d88756933&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F8%2F59b891c6b6e0f.jpg" alt=""></p>
<h4 id="Studio主流插件"><a href="#Studio主流插件" class="headerlink" title="Studio主流插件"></a>Studio主流插件</h4><p>我们知道Android Studio是基于Intellij的一套IDE环境，Intellij本身为开发者提供了插件式的开发环境，大大提高了开发效率和IDE可配置化。目前studio的成熟插件已有很多。<br>我们这里先来看看目前已有的主流Studio插件有哪些，几乎已经涵盖了你所有的需求：<br><a href="https://juejin.im/entry/5998090ff265da248a7a6bde" target="_blank" rel="external">https://juejin.im/entry/5998090ff265da248a7a6bde</a></p>
<h5 id="基本可以把插件的功能分为以下几类："><a href="#基本可以把插件的功能分为以下几类：" class="headerlink" title="基本可以把插件的功能分为以下几类："></a>基本可以把插件的功能分为以下几类：</h5><h6 id="1、解决重复性工作："><a href="#1、解决重复性工作：" class="headerlink" title="1、解决重复性工作："></a>1、解决重复性工作：</h6><p>把studio工作中技术含量低，重复性高的工作，用插件形式代替。</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>插件功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>GsonFormat</td>
<td>（jsonString自动生成JavaBean类）</td>
</tr>
<tr>
<td>ButterKnife Zelezny</td>
<td>（xml自动生成butterknife的注解代码）</td>
</tr>
<tr>
<td>Code Generator</td>
<td>（xml自动生成activity fragment）</td>
</tr>
<tr>
<td>AndroidProguardPlugin</td>
<td>（根据依赖的第三方库，生成proguard文件）</td>
</tr>
<tr>
<td>Exynap</td>
<td>（更加扩展，把成型、固定的代码段，自动生成）</td>
</tr>
<tr>
<td>MVPHelper</td>
<td>（自动生成 M V P 到不同文件夹）</td>
</tr>
</tbody>
</table>
<h6 id="2、集成studio不包含的功能："><a href="#2、集成studio不包含的功能：" class="headerlink" title="2、集成studio不包含的功能："></a>2、集成studio不包含的功能：</h6><p>为了开发的方便，将studio本身不具备的功能引入，扩展IDE的功能，避免studio和第三方来回切换和数据传输的麻烦。</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>插件功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>EventBus3 Intellij</td>
<td>（辅助 索引eventbus 从subscribe到post，提高eventbus可读性）</td>
</tr>
<tr>
<td>GradleDependenciesHelperPlugin</td>
<td>（gradle依赖自动补全）</td>
</tr>
<tr>
<td>SQLScout</td>
<td>（调试sqlite）</td>
</tr>
<tr>
<td>FindBugs-IDEA</td>
<td>（findbugs插件）</td>
</tr>
<tr>
<td>Android Methods Count</td>
<td>（预览依赖库中方法数，提前判断方法数超限）</td>
</tr>
</tbody>
</table>
<p>各插件的开发和使用成熟度很高，大部分是免费并且开源的，活跃度也很高。因为studio的使用率极高，而且IntelliJ IDE本身的插件资源丰富，直接借鉴的插件也有很多，使得插件开发的门槛大大降低。<br>那么我们自己再遇到重复性高的工作，或者第三方功能需要嵌入时，也建议考虑插件的方式。</p>
<h5 id="插件的安装方法"><a href="#插件的安装方法" class="headerlink" title="插件的安装方法"></a>插件的安装方法</h5><p>1、Preferences - plugins - Browse repositories 查找jetBrains远程仓库上的插件<br>很多插件是免费且开源的（github），远程repositories上对应的plugins都是最新的release版本<br>我们可以使用beta版本，或者自己对开源插件进行二次开发，这时就需要安装本地插件：<br>2、Preferences - plugins - Install plugin from disk 查找本地plugin的jar包</p>
<p>本文会以一个我自己二次开发的plugin为例，记录下plugin开发的基本流程和值得注意的坑。</p>
<hr>
<h4 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h4><p>studio是基于IntelliJ的二次开发的IDE，所以plugins其实是IntelliJ的插件，IntelliJ这个IDE本身就可以开发plugins，IntelliJ下载免费版即可，官网下载，community版本够用。不再赘述。</p>
<h5 id="新建及import工程"><a href="#新建及import工程" class="headerlink" title="新建及import工程"></a>新建及import工程</h5><p>新建project很多文章都有讲，不赘述，可以参考:<a href="https://www.jianshu.com/p/336a07b9d98a" target="_blank" rel="external">https://www.jianshu.com/p/336a07b9d98a</a><br>基本是配置IntelliJ sdk、创建plugin project、然后在plugin.xml中配置此插件即可</p>
<p>重点说下import工程，如果你是二次开发一个插件，那么import一个github已有的工程是必须的。以GsonFormat为例（<a href="https://github.com/zzz40500/GsonFormat/）" target="_blank" rel="external">https://github.com/zzz40500/GsonFormat/）</a><br>github工程下，分为两个分支master和dev_1.2.2其中dev开发分支可以直接用于二次开发。（master分支直接import作为project，需要IDE配置很多东西）</p>
<p>dev分支工程配置步骤</p>
<ol>
<li>import project from existing code<br>注意我们的工程是plugin,选择的sdk不是jdk1.8（此处同new project），而是IntelliJ IDEA Community，一路‘下一步’这个过程中，有一步已经把src下代码作为module放入了project，生成了GsonFormat.iml,</li>
<li>只是此时GsonFormat.iml中module type是JAVA_MODULE,而不是PLUGIN_MODULE，需要修改。<br>（project的module设置很重要，决定了project是否可以正常编译）<br>此处配置成功的标志就是 IDE出现了run 和 debug两个按钮。如果还不正常，可以进入IDE右上角的按钮进入project structure进行配置<br><img src="https://i.imgur.com/bdMkQYx.png" alt="配置sdk"></li>
<li>如果想正常编译插件，还需要一步，在 Edit Configuration中配置project的属性，见图二，新建一个Plugin Configuration，在右侧的Use classpath of module中选择刚刚的GsonFormat（由于刚刚我们成功配置了GsonFormat为PLUGIN_MODULE,否则此处找不到哦）<br><img src="https://i.imgur.com/mxQYUfN.png" alt="配置plugin的Module"></li>
<li>到了这一步，无论是run  debug 还是Prepare Plugin Module For Deployment(产出本地plugin jar)都可以了。</li>
</ol>
<h5 id="分析plugin工程"><a href="#分析plugin工程" class="headerlink" title="分析plugin工程"></a>分析plugin工程</h5><p>import成功后，我们看一下plugin工程是怎样的？<br>plugin工程中常见以下三类文件，也是plugin工程较为特有的文件类型：</p>
<ol>
<li><p>Action<br>作为整个插件的入口类，其入口方式和name等定义在plugin.xml，Action中actionPerformed作为入口方法，初始化当前类，包，传入到dialog中</p>
</li>
<li><p>Dialog 类似于android中的activity，绑定了Form类，用于view的databinding和逻辑<br>JsonDialog是入口dialog，FieldsDialog是解析jsonstring后展示的dialog，SettingDialog是配置dialog</p>
</li>
<li><p>GUI Form 类似于android中xml布局文件，只不过此处是swing的拖拽控件，Form与Dialog是配对出现，其对应关系在Form配置。</p>
</li>
</ol>
<h5 id="GsonFormat代码架构"><a href="#GsonFormat代码架构" class="headerlink" title="GsonFormat代码架构"></a>GsonFormat代码架构</h5><p>以GsonFormat plugin为例，具体讲清楚plugin工程的组成和实现原理。<br>(GsonFormat插件是把jsonString转变为javaBean的前端插件，写业务代码的朋友们应该非常熟悉，这款插件的使用过程是这样子的：)<br>第一步：弹窗：输入你要转换的jsonString，此处也可以Setting进行配置<br><img src="https://i.imgur.com/RRbLTaH.png" alt=""><br>第二步：弹窗：展示转换成功的field class，你可以在此基础上自定义。<br><img src="https://i.imgur.com/pqxUAFr.png" alt=""><br>最后：我们得到了我们想要的javaBean<br><img src="https://i.imgur.com/htvBpGV.png" alt=""><br>这个插件的基本功能如上，下面我们简单分析下源码：</p>
<h6 id="代码（类）的组织方式"><a href="#代码（类）的组织方式" class="headerlink" title="代码（类）的组织方式"></a>代码（类）的组织方式</h6><p>主Action是MainAction，作为插件的入口可以看到他启动了弹窗JsonDialog。工程中维护了几个dialog（包括java文件和form表单文件），分别对应插件工作中所有的弹窗，被放入了ui文件夹。<br><img src="http://oqjv79a9c.bkt.clouddn.com/cc0a69bf3ed271bb7afd4ccd39a106c6.png" alt=""><br>再来看其他文件夹：<br><img src="http://oqjv79a9c.bkt.clouddn.com/f2b67dfa0384153da79c35c66cd79f19.png" alt=""></p>
<ol>
<li>DataWriter类负责GsonFormat最后一步写入class文件，</li>
<li>config文件夹中类维护了插件的settings属性（属性用户可以在SettingsDialog配置），</li>
<li>entity文件夹内是实体类，classEntity fieldEntity等类都是维护最终生成class中的field及innerclass的实体类。</li>
<li>process文件夹内是处理类，jsonstring的解析，javaBean封装等具体的操作都是在这些类中完成的，是插件的核心类。</li>
</ol>
<h6 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h6><p>处理流程的代码逻辑是流式的，从MainAction入口开始看起，在JsonDialog中点击确定后，开始解析jsonString。<br>类JsonUtilsDialog中，点击事件的响应函数作为入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">editTP.addKeyListener(new KeyAdapter() &#123;</div><div class="line">    @Override</div><div class="line">    public void keyReleased(KeyEvent keyEvent) &#123;</div><div class="line">        super.keyReleased(keyEvent);</div><div class="line">        if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER) &#123;</div><div class="line">            onOK();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>1.解析的过程，主要在ConvertBridge类完成，由run方法作入口，开始解析jsonSTR<br>onOK（）方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void onOK() &#123;</div><div class="line">    //省略部分：get PsiClass generateClass:</div><div class="line">    new ConvertBridge(</div><div class="line">            this, errorLB, jsonSTR, mFile, mProject, generateClass,</div><div class="line">            mClass, generateClassName).run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.ConvertBridge类中run方法，通过parseJson方法，开始解析jsonString，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void parseJson(JSONObject json) &#123;</div><div class="line">    if (Config.getInstant().isVirgoMode()) &#123;</div><div class="line">      //省略代码：装配mGenerateEntity对象</div><div class="line">      //createFields 解析jsonString核心方法</div><div class="line">      mGenerateEntity.setFields(createFields(json, fieldList, mGenerateEntity));</div><div class="line">      FieldsDialog fieldsDialog = new FieldsDialog(mJsonUtilsDialog, mGenerateEntity, mFactory,</div><div class="line">                mGeneratClass, currentClass, mFile, project, generateClassName);</div><div class="line">    &#125; else &#123;</div><div class="line">      mGenerateEntity.setFields(createFields(json, fieldList, mGenerateEntity));</div><div class="line">      WriterUtil writerUtil = new WriterUtil(null, null, mFile, project, mGeneratClass);</div><div class="line">      writerUtil.mInnerClassEntity = mGenerateEntity;</div><div class="line">      writerUtil.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分为Virgo模式和非Virgo模式（默认virgo模式）：virgo模式，就是启动FieldsDialog，就是我们见到的第二个窗口，用户自行修改fields的定义，非virgo比较简单，跳过dialog直接写入fields到class里。除非settings自己定义，否则我们一般都使用virgo模式。可以看到无论是否virgo模式与否，都会调用createFields方法，区别只是是否显示FieldsDialog。</p>
<p>3.详细看下createFields方法做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</div><div class="line">    String key = list.get(i);</div><div class="line">    Object type = json.get(key);</div><div class="line">    if (type instanceof JSONArray) &#123;</div><div class="line">        //将jsonArray放入listEntityList</div><div class="line">        listEntityList.add(key);</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">    FieldEntity fieldEntity = createFiled(parentClass, key, type);</div><div class="line">    fieldEntityList.add(fieldEntity);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; listEntityList.size(); i++) &#123;</div><div class="line">    //解析listEntityList中数据</div><div class="line">    String key = listEntityList.get(i);</div><div class="line">    Object type = json.get(key);</div><div class="line"></div><div class="line">    FieldEntity fieldEntity = createFiled(parentClass, key, type);</div><div class="line">    fieldEntityList.add(fieldEntity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过createFields方法把field放入FieldEntity，DataWriter再根据FieldEntity的内容写入class中，</p>
<p>4.以上的解析过程，只涉及了一层JavaBean的情况，JavaBean大部分情况下，是要嵌套Bean内部类的，就是JSONObject内部是嵌套jsonobject的，我们继续来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private FieldEntity typeByValue(InnerClassEntity parentClass, String key, Object type) &#123;</div><div class="line">        if (type instanceof JSONObject) &#123;</div><div class="line">            InnerClassEntity classEntity = checkInnerClass((JSONObject) type);</div><div class="line">            if (classEntity == null) &#123;</div><div class="line">                //省略代码</div><div class="line">            &#125; else &#123;</div><div class="line">                FieldEntity fieldEntity = new FieldEntity();</div><div class="line">                fieldEntity.setKey(key);</div><div class="line">                fieldEntity.setTargetClass(classEntity);</div><div class="line">                fieldEntity.setType(&quot;%s&quot;);</div><div class="line">                nodeBean = fieldEntity;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>createFields方法中对每个fieldEntity依次调用createField方法，createFiled方法中调用了typeByValue方法，在createInnnerClass中 对子json再次进行createFields方法，如此依次递归。完成了一层层javabean的解析工作。<br>可以说Class中包括FieldEntry，而FieldEntry本身也是包含多个子FieldEntry的。FieldEntry可以设置基本类型，也可以设置ClassEntity。</p>
<p>5.最终通过WriterUtil类将FieldEntry写入到class文件中，完成了整个的插件功能。</p>
<h4 id="二次开发的部分"><a href="#二次开发的部分" class="headerlink" title="二次开发的部分"></a>二次开发的部分</h4><h5 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h5><p>由于代码混淆的原因，开发中经常遇到debug下正常的代码，在release包情况下无法正常解析网路数据，因为javabean类中的field混淆后已经不是原来定义的名称了。而这个问题在提测关口最容易出现。想解决这个问题必须保证javaBean在打包中不被混淆。<br>如何不被混淆，不同厂商有不同的解决策略（规范）：</p>
<ol>
<li>统一放到一个文件夹里（或者含固定名称的文件夹），混淆时ignore 这些文件夹。<br>但是这办法操作起来不完美，一个是重构后文件夹容易变名字，还有团队开发时无法保证所有的人都遵守。处理代码时都要绷着文件夹名称这个弦。</li>
<li>所有JavaBean extends Serializable(统一基类)<br>这样proguard文件中保证所有Seriallizable的子类不被混淆即可。而且Bundle传递参数时javaBean可以直接被用。但是这个办法也有一个缺点：需要保证所有人遵守这个约定，无法规范这个步骤。</li>
</ol>
<h5 id="我们的解决方式："><a href="#我们的解决方式：" class="headerlink" title="我们的解决方式："></a>我们的解决方式：</h5><p>一般我们的接口管理系统中，都可以产生mock的jsonString，客户端开发会直接利用SGsonFormat插件将jsonString直接转为JavaBean，所以基于GsonFormat功能二次开发，让所有的JavaBean class统一继承Serializable，这样兼顾了易用性和统一性。</p>
<h6 id="GsonFormat的二次开发："><a href="#GsonFormat的二次开发：" class="headerlink" title="GsonFormat的二次开发："></a>GsonFormat的二次开发：</h6><p>统一继承Serializable的逻辑，应该放入DataWriter写入的流程中，分析可得：在ClassProcessor中process方法，实际上将classContent的String内容通过PsiElementFactory写入class文件中，所以修改String classContent既可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">protected void generateClass(PsiElementFactory factory, ClassEntity classEntity, PsiClass parentClass, IProcessor visitor) &#123;</div><div class="line"></div><div class="line">    onStartGenerateClass(factory, classEntity, parentClass, visitor);</div><div class="line">    PsiClass generateClass = null;</div><div class="line">    if (classEntity.isGenerate()) &#123;</div><div class="line">        if (Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">            try &#123;</div><div class="line">                generateClass = PsiClassUtil.getPsiClass(</div><div class="line">                        parentClass.getContainingFile(), parentClass.getProject(), classEntity.getQualifiedName());</div><div class="line">            &#125; catch (Throwable throwable) &#123;</div><div class="line">                throwable.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据classContent创建class</div><div class="line">            String classContent =</div><div class="line">                    &quot;public static class &quot; + classEntity.getClassName() + &quot; implements Serializable&quot; + &quot;&#123;&#125;&quot;;</div><div class="line">            generateClass = factory.createClassFromText(classContent, null).getInnerClasses()[0];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (generateClass != null) &#123;</div><div class="line">            //递归调用，创建内部类</div><div class="line">            for (ClassEntity innerClass : classEntity.getInnerClasss()) &#123;</div><div class="line">                generateClass(factory, innerClass, generateClass, visitor);</div><div class="line">            &#125;</div><div class="line">            if (!Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">                generateClass = (PsiClass) parentClass.add(generateClass);</div><div class="line">            &#125;</div><div class="line">            //创建内部变量</div><div class="line">            for (FieldEntity fieldEntity : classEntity.getFields()) &#123;</div><div class="line">                generateField(factory, fieldEntity, generateClass, classEntity);</div><div class="line">            &#125;</div><div class="line">            //创建内部变量getter setter方法</div><div class="line">            generateGetterAndSetter(factory, generateClass, classEntity);</div><div class="line">            generateConvertMethod(factory, generateClass, classEntity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    onEndGenerateClass(factory, classEntity, parentClass, generateClass, visitor);</div><div class="line">    if (Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">        formatJavCode(generateClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插件下载地址：（该插件已提交repository） <a href="https://plugins.jetbrains.com/plugin/11100-sgsonformat/update/49532" target="_blank" rel="external">https://plugins.jetbrains.com/plugin/11100-sgsonformat/update/49532</a><br>或者直接搜索SGsonFormat，install即可使用</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二次开发的改动并不大，但是把Studio的plugin开发环境和流程算是熟悉了一遍，plugin插件的开发可以说你会用java就能上手，只不过他自定义的文件类型和组织方式需要熟悉。如果有需要的话，做个新的plugin提高工作效率，是个很好的方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/Robust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/Robust/" itemprop="url">Robust原理及修复范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/ClassLoader/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/ClassLoader/" itemprop="url">ClassLoader原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/hybrid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/hybrid/" itemprop="url">Hybrid应用开发初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T00:00:00+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="Hybrid开发定义和使用范围"><a href="#Hybrid开发定义和使用范围" class="headerlink" title="Hybrid开发定义和使用范围"></a>Hybrid开发定义和使用范围</h2><h6 id="为什么要采用hybrid："><a href="#为什么要采用hybrid：" class="headerlink" title="为什么要采用hybrid："></a>为什么要采用hybrid：</h6><p>现阶段的应用开发，会遇到如下问题和挑战：<br>1 一些页面或业务，和运营强相关，无法native固定（例如电子商务 详情展示）<br>2 客户端发版周期长，一些需求想要很快上线，或变化非常频繁</p>
<p>现有3类主流APP，分别为：Web App、Hybrid App（混合模式应用，Hybrid有“混合的”意思）、 Native App；</p>
<p>Native App 和 Web App不作解释了，主要解释Hybrid App。<br>Hybrid App按网页语言与程序语言的混合，通常分为三种类型：多View混合型，单View混合型，Web主体型。</p>
<h6 id="单页混合型"><a href="#单页混合型" class="headerlink" title="单页混合型"></a>单页混合型</h6><p>即在同一个页面内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单页混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。一般如无特殊需求，不会采用此种方式。</p>
<h6 id="Web主体型"><a href="#Web主体型" class="headerlink" title="Web主体型"></a>Web主体型</h6><p>这种常见于市面上第三方hybrid框架实现。例如Wex5，AppCan和Rexsee都属于Web主体型移动应用中间件。基本可以实现跨平台，主要以网页语言编写，利用框架生成native的壳子。但是一般用户体验存在缺陷。常见于一些小型或功能单一app。</p>
<h6 id="多主体混合型"><a href="#多主体混合型" class="headerlink" title="多主体混合型"></a>多主体混合型</h6><p>即Native View和Web View独立展示，交替出现。这种应用混合逻辑相对简单。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。常见的Hybrid App是Native View与WebView交替的场景出现。</p>
<h6 id="与App内接入H5的区别："><a href="#与App内接入H5的区别：" class="headerlink" title="与App内接入H5的区别："></a>与App内接入H5的区别：</h6><p>hybrid的开发模式与我们之前一些运营页面采用h5的根本区别在于，后者只是在一些不重要的功能上实现可运营和便于分享，并不接入到应用的主要流程中，与native的交互较少，对应用的影响小，作为开发的一个小模块独立存在。hybrid开发则是将web页面作为native的重要补充，应用功能的重要组成部分，需要考虑上线节奏，web与native的通讯，优化web体验等问题，对于应用来讲，web与native的地位，被大大拉平了。</p>
<h5 id="如何区分Hybrid-APP中的原生页面和H5页面"><a href="#如何区分Hybrid-APP中的原生页面和H5页面" class="headerlink" title="如何区分Hybrid APP中的原生页面和H5页面"></a>如何区分Hybrid APP中的原生页面和H5页面</h5><p>很多人从页面的设计上来区分的。如：（1）顶部显示网页链接；（2）有加载的进度条；（3）没有底部tab导航栏；（4）顶部显示两个导航条；<br>但是现在app的h5页面做的可以以假乱真了，这些统统不管用。<br>以淘宝为例：<br><img src="http://upload-images.jianshu.io/upload_images/738531-b9c78c9eb6330834.png" alt=""></p>
<h5 id="设置-开发者选项-显示布局边界"><a href="#设置-开发者选项-显示布局边界" class="headerlink" title="设置-开发者选项-显示布局边界"></a>设置-开发者选项-显示布局边界</h5><p>H5中使用了webview控件，其作为一个控件，只有一个边界框，所以通过这一点，就比较容易区分出一个界面是webview实现的还是原生布局控件实现的<br>这次再来看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/738531-76cbd5f6bffafcbf.png" alt=""></p>
<p>几个主流HybridApp：淘宝、京东、大众点评等</p>
<h4 id="Hybrid中Native和H5的使用范围"><a href="#Hybrid中Native和H5的使用范围" class="headerlink" title="Hybrid中Native和H5的使用范围:"></a>Hybrid中Native和H5的使用范围:</h4><p>Native<br>1 应用核心逻辑：例如 下单、支付等<br>2 对手机native功能（如照相、定位）重度依赖的页面<br>3 用户体验要求强，运营要求弱的页面<br>H5：<br>1.功能开发不完善，试运营阶段（试错成本低）<br>2.强运营需求，在功能调整或内容的运营上很灵活<br>3.阶段性的营销活动，希望被分享出去</p>
<h2 id="Hybrid开发中要解决的几个问题"><a href="#Hybrid开发中要解决的几个问题" class="headerlink" title="Hybrid开发中要解决的几个问题"></a>Hybrid开发中要解决的几个问题</h2><p>一、H5 和 Native 上线时间不一致，如何衔接？<br>二、H5 和 Native 之间如何进行通信？<br>三、H5 页面如何接近 Native 的体验？<br>针对几个问题，参考了美团团队技术分享的解决方案，同时根据自己的理解做了适当的扩展：</p>
<h5 id="1-H5-和-Native-上线时间不一致，如何衔接？"><a href="#1-H5-和-Native-上线时间不一致，如何衔接？" class="headerlink" title="1. H5 和 Native 上线时间不一致，如何衔接？"></a>1. H5 和 Native 上线时间不一致，如何衔接？</h5><p>比如一个功能以H5形式作出，但H5的发布滞后于native，当H5上线之后，客户端需要给H5提供一些跳转的入口，这个跳转的入口提供的应该是在不发版的情况下去给出的。<br>这就需要对路由的跳转做到后台的可配置。<br>现阶段的跳转：（Native 到 Native）<br>这种组件化的全局统跳协议，利用ARouter、天猫统跳协议等其他路由机制，都可以实现。<br><img src="http://upload-images.jianshu.io/upload_images/2638203-a70659645a2243ed" alt=""><br>对这个跳转去做一些扩展：对路由协议扩展后，让他能支持跳转到H5里。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2638203-60f2c090a2eecfe1" alt=""><br>通过后台动态决定一个页面，究竟是native还是h5的展现形式。<br>举个例子：<br>在APP里一个购物下单的流程，用户需要访问列表页，商家的详情页，创建订单，最后购买成功。对一些新的产品，有新的产品详情和创建订单样式。可以通过h5上线的方式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2638203-d32af64ba8238c55" alt=""><br>可以看到流程的两端都是native，中间环节从native到h5可以动态切换<br>备注：这些路由配置，是实际需求的少数，作为主体方案的有效补充存在。</p>
<h5 id="2-H5-和-Native-如何进行通信？"><a href="#2-H5-和-Native-如何进行通信？" class="headerlink" title="2. H5 和 Native 如何进行通信？"></a>2. H5 和 Native 如何进行通信？</h5><h6 id="传统的JSInterface（兼容性）"><a href="#传统的JSInterface（兼容性）" class="headerlink" title="传统的JSInterface（兼容性）"></a>传统的JSInterface（兼容性）</h6><p>看一段html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;zh-CN&quot; dir=&quot;ltr&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        function showToast(toast) &#123;</div><div class="line">            javascript:control.showToast(toast);</div><div class="line">        &#125;</div><div class="line">        function log(msg)&#123;</div><div class="line">            console.log(msg);</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;input type=&quot;button&quot; value=&quot;toast&quot;</div><div class="line">       onClick=&quot;showToast(&apos;Hello world&apos;)&quot; /&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>对应的java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private WebView webView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        webView = (WebView)findViewById(R.id.webView);</div><div class="line"></div><div class="line">        WebSettings webSettings = webView.getSettings();</div><div class="line"></div><div class="line">        webSettings.setJavaScriptEnabled(true);</div><div class="line"></div><div class="line">        webView.addJavascriptInterface(new JsInterface(), &quot;control&quot;);</div><div class="line"></div><div class="line">        webView.loadUrl(&quot;file:///android_asset/interact.html&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class JsInterface &#123;</div><div class="line"></div><div class="line">        @JavascriptInterface</div><div class="line">        public void showToast(String toast) &#123;</div><div class="line">            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();</div><div class="line">            log(&quot;show toast success&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void log(final String msg)&#123;</div><div class="line">            webView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    webView.loadUrl(&quot;javascript: log(&quot; + &quot;&apos;&quot; + msg + &quot;&apos;&quot; + &quot;)&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过webView.addJavascriptInterface(new JsInterface(), “control”)，将js的control与native的JsInterface联系起来，实现了js向native的调用。反过来，webView.loadUrl(“javascript: log(“ + “‘“ + msg + “‘“ + “)”)，loadUrl调用到js中定义的log方法，实现了native到js的回调。</p>
<p>但是，，，<br>4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function execute(cmdArgs) &#123;</div><div class="line">    for (var obj in window) &#123;</div><div class="line">        if (&quot;getClass&quot; in window[obj]) &#123;</div><div class="line">            alert(obj);</div><div class="line">            return  window[obj].getClass().forName(&quot;java.lang.Runtime&quot;)  </div><div class="line">                 .getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(cmdArgs);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.2以后通过为可以被Js调用的方法添加@JavascriptInterface注解来解决，但是4.2之前的版本兼容性存在问题。而且这种类似于函数式的调用方式，扩展性和两端的兼容性都受限，所以他也就没法广泛采用了。</p>
<h6 id="UrlRouter"><a href="#UrlRouter" class="headerlink" title="UrlRouter"></a>UrlRouter</h6><p>严格的说，UrlRouter不算是js和java的通信，它只是一个通过url来让前端唤起native页面的框架。不过千万不要小看它的作用，如果协议定义的合理，它可以让前端，Android和iOS三端有一个高度的统一，十分方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class NavWebViewClient extends WebViewClient &#123;</div><div class="line"></div><div class="line">    private Context context;</div><div class="line"></div><div class="line">    public NavWebViewClient(Context context)&#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">        if( Nav.from(context).toUri(url))&#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        view.loadUrl(url);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法shouldOverrideUrlLoading中，拦截后交给Nav处理，如果返回true则成功拦截，返回false则交给webview去load url。Nav中的解析处理，可以根据业务特点，根据scheme host url地址解析出跳转路径和携带的参数。<br>关于携带参数，再多说两句：h5与native要约定传参的格式，比如json格式，那么在json字串里约定好字段的含义，就可以传参，比如要实现跳转到指定页面，并携带参数：</p>
<p><code>{&quot;p&quot;: &quot;orderlist&quot;,&quot;pa&quot;: {&quot;tp&quot;: &quot;per&quot;}}</code></p>
<p>字段p代码代码页面，字段pa代表参数，pa字段后面的json表示此页面需要的具体传参。要注意传参部分要进行加密处理。</p>
<p>######JSBridge<br>这种方式不算新，一些大公司都有自己的jsBridge封装方式，这里简要说明一下基本原理。<br>WebView中有一个WebChromeClient类，有三个监听函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</div><div class="line">    return super.onJsPrompt(view, url, message, defaultValue, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">    return super.onJsAlert(view, url, message, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">    return super.onJsConfirm(view, url, message, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在js中，alert和confirm本身的使用概率还是很高的，不建议使用这两个通道，onJsPrompt方法则可以用来js与java通信。通过在回调函数中message参数传递通讯协议，native根据协议解析决定自己的操作。</p>
<p>onJsPrompt方法中message参数：<code>hybrid://JSBridge:1538351/method?{“message”:”msg”}</code></p>
<p>sheme是hybrid://，host是JSBridge，方法名字是toast，传递的参数是以json格式传递的<br>java层的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class InjectedChromeClient extends WebChromeClient &#123;</div><div class="line">    private final String TAG = &quot;InjectedChromeClient&quot;;</div><div class="line"></div><div class="line">    private JsCallJava mJsCallJava;</div><div class="line"></div><div class="line">    public InjectedChromeClient() &#123;</div><div class="line">        mJsCallJava = new JsCallJava();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</div><div class="line">        result.confirm(mJsCallJava.call(view, message));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心的call方法做了哪些？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public String call(WebView webView, String jsonStr) &#123;</div><div class="line">    String methodName = &quot;&quot;;</div><div class="line">    String name = BRIDGE_NAME;</div><div class="line">    String param = &quot;&#123;&#125;&quot;;</div><div class="line">    String result = &quot;&quot;;</div><div class="line">    String sid=&quot;&quot;;</div><div class="line">    if (!TextUtils.isEmpty(jsonStr) &amp;&amp; jsonStr.startsWith(SCHEME)) &#123;</div><div class="line">        Uri uri = Uri.parse(jsonStr);</div><div class="line">        name = uri.getHost();</div><div class="line">        param = uri.getQuery();</div><div class="line">        sid = getPort(jsonStr);</div><div class="line">        String path = uri.getPath();</div><div class="line">        if (!TextUtils.isEmpty(path)) &#123;</div><div class="line">            methodName = path.replace(&quot;/&quot;, &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!TextUtils.isEmpty(jsonStr)) &#123;</div><div class="line">        try &#123;</div><div class="line">            ArrayMap&lt;String, Method&gt; methodMap = mInjectNameMethods.get(name);</div><div class="line"></div><div class="line">            Object[] values = new Object[3];</div><div class="line">            values[0] = webView;</div><div class="line">            values[1] = new JSONObject(param);</div><div class="line">            values[2]=new JsCallback(webView,sid);</div><div class="line">            Method currMethod = null;</div><div class="line">            if (null != methodMap &amp;&amp; !TextUtils.isEmpty(methodName)) &#123;</div><div class="line">                currMethod = methodMap.get(methodName);</div><div class="line">            &#125;</div><div class="line">            // 方法匹配失败</div><div class="line">            if (currMethod == null) &#123;</div><div class="line">                result = getReturn(jsonStr, RESULT_FAIL, &quot;not found method(&quot; + methodName + &quot;) with valid parameters&quot;);</div><div class="line">            &#125;else&#123;</div><div class="line">                result = getReturn(jsonStr, RESULT_SUCCESS, currMethod.invoke(null, values));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        result = getReturn(jsonStr, RESULT_FAIL, &quot;call data empty&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码的思路如下：<br>(1) 在js脚本中把对应的方法名，参数等写成一个符合协议的uri，并且通过window.prompt方法发送给java层。</p>
<p>(2) 在java层的onJsPrompt方法中接受到对应的message之后，通过JsCallJava类进行具体的解析。</p>
<p>(3) 在JsCallJava类中，我们解析得到对应的方法名，参数等信息，并且在map中查找出对应的类的方法。</p>
<p>思考：为什么不对message中的字段进行switch case的逻辑判断，而是要经过mInjectNameMethods的遍历呢?</p>
<p>在业务复杂，应用已经组件化的情况下，JSBridge一定是作为整体架构的一部分存在的，那么其定义和使用可能是分离的，通过mInjectNameMethods遍历的方法，JSBridge中定义方法的权利交给了业务部门，有效实现了解耦。</p>
<p><strong>可以这么说UrlRouter在页面跳转方面，JSBridge在方法调用方面，都具备各自的特点和优势，可以有效的结合起来。</strong></p>
<h5 id="3-H5-页面如何接近-Native-的体验？"><a href="#3-H5-页面如何接近-Native-的体验？" class="headerlink" title="3 . H5 页面如何接近 Native 的体验？"></a>3 . H5 页面如何接近 Native 的体验？</h5><h6 id="资源加载缓慢"><a href="#资源加载缓慢" class="headerlink" title="资源加载缓慢"></a>资源加载缓慢</h6><p>1.模块化你的 H5 页面/应用，引入模块加载器<br>2.资源预加载<br>第一种方式是说使用 WebView 自身的缓存机制<br>这种缓存，系统会自动把它清掉，我们没法进行控制<br>第二种方案是说，我们自己去构建，自己管理缓存<br>把这些需要预加载的资源放在 APP 里面，他可能是预制放进去的，也可能是后续下载的。<br>每当这个 WebView 发起资源请求的时候，我们会拦截到这些资源的请求，去本地检查一下我们的这些静态资源本地离线包有没有。针对本地的缓存文件我们有些策略能够及时的去更新它<br><img src="http://upload-images.jianshu.io/upload_images/2638203-321faacaeb38d7e6" alt=""><br>资源预加载效果：<br><img src="http://upload-images.jianshu.io/upload_images/2638203-43d00f93cffd7391" alt=""><br>每个页面在预加载后都有明显提升（4G下明显），同时横向比较，也可看出，在一系列的web加载过程中，平均时间再降低。也说明了webview自身的缓存机制。<br>腾讯开源的hybrid框架（实际只是webview首屏优化），实践了webview的优化，具体原理可以去github:<br><a href="https://github.com/Tencent/VasSonic" target="_blank" rel="external">https://github.com/Tencent/VasSonic</a></p>
<p>VasSonic有如下特点（缺点）:<br>1.VasSonic的技术实现上，需要服务端、客户端 同时修改配合；<br>2.目前sonic后台仅支持node.js和php版本，暂时还不支持其他后台；<br>3.iOS 只支持UIWebView，不支持WKWebView，主要是因为在WKWebView目前不支持NSURLProtocol拦截；<br>vassonic这套方案，对于现有项目还是有一定侵入性的，而且需要服务端配合。可以参考其思路，完全照搬对于大项目有风险。</p>
<p>最后放一张hybrid客户端架构图</p>
<p><img src="http://img1.tuicool.com/Zjiyyu.png!web" alt=""></p>
<p>H5Container是架构设计的重点和难点，其中nativeApi，HandwareApi都是对于手机对web提供功能的封装。Data Channel负责埋点;JSBridge是处于底层的通讯接口，JSBridges为各个模块的定制和扩展。<br>Synchronize Service 模块表示和服务器的长连接通信模块，用于接受服务器端各种推送，包括离线包等。 Source Merge Service 模块表示对解压后的H5资源进行更新，包括增加文件、以旧换新以及删除过期文件等。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>一般来说Hybrid的项目一般是用在一些快速迭代试错的地方。另外包括有一些非主流产品的页面，我们倾向于用 Hybrid 的形式做.<br>但是像前端购买一些交易环节，特别核心的流程的话，我们一般情况下会用 Native 的形式去写这些页面，去提升，达到一个极致的用户体验。不要为了hybrid而hybrid，一切都是根据需求的实际情况出发，同时hybrid的框架在设计时，协议方面要注意ios android两端的统一，android端自身尽量考虑扩展性和解耦，有利于后续开发迭代的稳定和迅速。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">bo.wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bo.wang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
