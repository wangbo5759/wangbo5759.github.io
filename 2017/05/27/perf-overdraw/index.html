<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>过度绘制的解决 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="背景：《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。本文关注渲染方向：

渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。">
<meta property="og:type" content="article">
<meta property="og:title" content="过度绘制的解决">
<meta property="og:url" content="http://yoursite.com/2017/05/27/perf-overdraw/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="背景：《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。本文关注渲染方向：

渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。">
<meta property="og:image" content="http://oqjv79a9c.bkt.clouddn.com/0518-unmodified.png">
<meta property="og:image" content="http://oqjv79a9c.bkt.clouddn.com/0516-modified.png">
<meta property="og:image" content="http://oqjv79a9c.bkt.clouddn.com/0518-didi.png">
<meta property="og:updated_time" content="2017-06-06T03:56:27.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="过度绘制的解决">
<meta name="twitter:description" content="背景：《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。本文关注渲染方向：

渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。">
<meta name="twitter:image" content="http://oqjv79a9c.bkt.clouddn.com/0518-unmodified.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Søk"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-perf-overdraw" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/27/perf-overdraw/" class="article-date">
  <time datetime="2017-05-26T16:00:00.000Z" itemprop="datePublished">2017-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      过度绘制的解决
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。<br>本文关注渲染方向：</p>
<hr>
<p>渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。<br>CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。</p>
<p>Overdraw 过度绘制：<br>定义：屏幕上的某个像素在同一帧的时间内被绘制了多次<br>例如UI是层叠的，看不见的UI也做绘制操作，就是多余的。当设计效果上更加华丽炫酷时，堆叠视图层级是常见的情况，但这很容易产生性能问题。</p>
<p>怎么过度绘制打开开关和如何看，不介绍了就。</p>
<hr>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>1.写合理而高效的布局<br>Android的布局可以通过xml来实现，这使得开发者布局时较为随意，只以实现功能为目的，忽略性能问题的累积效应。<br>在开发设计之初，就应该考虑布局的效率问题，以免出现后期修改的高成本。<br>降低Layout层级，有很多方法 不列举了。</p>
<p>2.移除非必须的background: Activity的DecorView有默认的背景色，可以改为透明<br><code>getWindow().getDecorView().setBackgroundColor(getResources().getColor(R.color.transparent));</code><br>这个颜色从ActivityTheme设置，被decorView所持有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Theme&quot;&gt;</div><div class="line">    ...</div><div class="line">    &lt;!-- Window attributes --&gt;</div><div class="line">    &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_dark&lt;/item&gt;</div><div class="line">    ...</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>screen_background_selector_dark在sdk中定义为纯黑色<br>所以也可以<code>android:windowbackground=&quot;null&quot;</code>方法来修改</p>
<p>后续会在Theme自定义，或BaseActivity 统一优化</p>
<p>3.View BackGround 优化：<br>1) 所有的View都可以设置Background，ImageView除了可以设置BackGround外，还可以设置imageResource<br>在使用ImageView时，尤其是ListView ViewHolder中，可能imageView设置默认bitmap给background，然后<br>真正的bitmap给imageResource，导致了重复绘制。解决方法是都通过imageResource设置<br>2) 有时采用selector背景，可以normal状态设置为transparent</p>
<p>4.移除不必要的背景色<br>比如Activity中含Fragment,如果Fragment有背景色而且是全屏的，Activity就不必要。<br>又比如ViewPager中含fragment ViewPager的背景色是不必要的</p>
<p>5.ClipRect<br>在ViewGroup的drawChild方法中，<br><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime)</code><br>在ViewGroup的Canvas上绘制子child，不同的child都在同一个canvas绘制，如果view相互遮盖，则重复绘制难免。<br>Canvas的clipRect方法，提供了限定绘制区域的功能，在某个child 绘制时，可以限定绘制区域为自己的显示区域，解决了这个问题。<br>v4包中的DrawerLayout，就专门做了ClipRect优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</div><div class="line">        final int height = getHeight();</div><div class="line">        final boolean drawingContent = isContentView(child);//是否mainContent</div><div class="line">        int clipLeft = 0, clipRight = getWidth();</div><div class="line"></div><div class="line">		//如果是绘制mainContent，则先canvas.save 再 canvas.restore</div><div class="line">        //并拿到drawerContent的right作为自己绘制的left，通过canvas.clipRect限定绘制区域</div><div class="line">        final int restoreCount = canvas.save();</div><div class="line">        if (drawingContent) &#123;</div><div class="line">            final int childCount = getChildCount();</div><div class="line">            //此for循环找到drawerCotnent，</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                final View v = getChildAt(i);</div><div class="line">                //注意此处对于drawerContent的筛选条件：</div><div class="line">                //visible，背景非透明!hasOpaqueBackground(v)</div><div class="line">                //如果drawerContent无背景色，此优化直接continue,因为mainContent要全显示</div><div class="line">                if (v == child || v.getVisibility() != VISIBLE ||</div><div class="line">                        !hasOpaqueBackground(v) || !isDrawerView(v) ||</div><div class="line">                        v.getHeight() &lt; height) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) &#123;</div><div class="line">                    final int vright = v.getRight();</div><div class="line">                    if (vright &gt; clipLeft) clipLeft = vright;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final int vleft = v.getLeft();</div><div class="line">                    if (vleft &lt; clipRight) clipRight = vleft;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.clipRect(clipLeft, 0, clipRight, getHeight());</div><div class="line">        &#125;</div><div class="line">        final boolean result = super.drawChild(canvas, child, drawingTime);</div><div class="line">        canvas.restoreToCount(restoreCount);</div></pre></td></tr></table></figure></p>
<p>pilot端的问题就在于DrawerContent没有背景，而是把背景设置在了里面的Fragment，导致DrawerLayout优化没有生效<br>此优化一般用于自定义view中，而且控件交互存在View之间重叠的情况</p>
<p>Android中每个Window对应一个Canvas，window下所有view绘制公用一个canvas，viewtree的父节点在调用child.draw之前都会根据child的layout边界对canvas进行裁剪，这也是为什么超过view边界的内容不会被显示的原因。<br>但是对于各child大部分重叠的控件，会产生过度绘制，就需要clipRect优化。大部分容易重叠的控件FrameLayout RelativeLayout本身没有优化，需要开发者根据实际情况对自定义控件进行优化。</p>
<p>优化前：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-unmodified.png" width="160" height="300">优化后：<img src="http://oqjv79a9c.bkt.clouddn.com/0516-modified.png" width="160" height="300">滴滴：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-didi.png" width="160" height="300"></p>
<p>6.善用9patch，背景图如果只显示边框，选用9patch，中间的透明会被2D渲染器优化overdraw</p>
<hr>
<p>过度绘制的原因无外乎：复杂的Layout层级、重叠的背景、重叠的View几种。开发人员在设计之初就要充分考虑过度绘制等性能敏感地带，要知道等到功能实现之后再去改Layout层级，onDraw方法等，成本和风险都会指数型提高。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/27/perf-overdraw/" data-id="cj3mfe3xj0000c4x35a0dr2x7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android性能优化/">Android性能优化</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/06/06/perf-memory/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          内存问题的解决
        
      </div>
    </a>
  
  
    <a href="/2017/05/26/essay/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">随笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android性能优化/">Android性能优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/代码及架构/">代码及架构</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android性能优化/" style="font-size: 20px;">Android性能优化</a> <a href="/tags/代码及架构/" style="font-size: 10px;">代码及架构</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Arkiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Siste innlegg</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/15/ARouter/">(no title)</a>
          </li>
        
          <li>
            <a href="/2017/06/06/perf-memory/">内存问题的解决</a>
          </li>
        
          <li>
            <a href="/2017/05/27/perf-overdraw/">过度绘制的解决</a>
          </li>
        
          <li>
            <a href="/2017/05/26/essay/">随笔记</a>
          </li>
        
          <li>
            <a href="/2017/05/16/clean code/">聊聊clean code</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>