<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Muse--D.D">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Muse--D.D">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Muse--D.D">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Muse--D.D</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Muse--D.D</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/IntelliJplugin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/IntelliJplugin/" itemprop="url">SGsonFormat --- Android Studio插件二次开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-06T00:00:00+08:00">
                2018-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1542447863363&amp;di=6ed34059d7700c6c96b3249d88756933&amp;imgtype=0&amp;src=http%3A%2F%2Fpic1.win4000.com%2Fwallpaper%2F8%2F59b891c6b6e0f.jpg" alt=""></p>
<h4 id="Studio主流插件"><a href="#Studio主流插件" class="headerlink" title="Studio主流插件"></a>Studio主流插件</h4><p>我们知道Android Studio是基于Intellij的一套IDE环境，Intellij本身为开发者提供了插件式的开发环境，大大提高了开发效率和IDE可配置化。目前studio的成熟插件已有很多。<br>我们这里先来看看目前已有的主流Studio插件有哪些，几乎已经涵盖了你所有的需求：<br><a href="https://juejin.im/entry/5998090ff265da248a7a6bde" target="_blank" rel="external">https://juejin.im/entry/5998090ff265da248a7a6bde</a></p>
<h5 id="基本可以把插件的功能分为以下几类："><a href="#基本可以把插件的功能分为以下几类：" class="headerlink" title="基本可以把插件的功能分为以下几类："></a>基本可以把插件的功能分为以下几类：</h5><h6 id="1、解决重复性工作："><a href="#1、解决重复性工作：" class="headerlink" title="1、解决重复性工作："></a>1、解决重复性工作：</h6><p>把studio工作中技术含量低，重复性高的工作，用插件形式代替。</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>插件功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>GsonFormat</td>
<td>（jsonString自动生成JavaBean类）</td>
</tr>
<tr>
<td>ButterKnife Zelezny</td>
<td>（xml自动生成butterknife的注解代码）</td>
</tr>
<tr>
<td>Code Generator</td>
<td>（xml自动生成activity fragment）</td>
</tr>
<tr>
<td>AndroidProguardPlugin</td>
<td>（根据依赖的第三方库，生成proguard文件）</td>
</tr>
<tr>
<td>Exynap</td>
<td>（更加扩展，把成型、固定的代码段，自动生成）</td>
</tr>
<tr>
<td>MVPHelper</td>
<td>（自动生成 M V P 到不同文件夹）</td>
</tr>
</tbody>
</table>
<h6 id="2、集成studio不包含的功能："><a href="#2、集成studio不包含的功能：" class="headerlink" title="2、集成studio不包含的功能："></a>2、集成studio不包含的功能：</h6><p>为了开发的方便，将studio本身不具备的功能引入，扩展IDE的功能，避免studio和第三方来回切换和数据传输的麻烦。</p>
<table>
<thead>
<tr>
<th>插件名称</th>
<th>插件功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>EventBus3 Intellij</td>
<td>（辅助 索引eventbus 从subscribe到post，提高eventbus可读性）</td>
</tr>
<tr>
<td>GradleDependenciesHelperPlugin</td>
<td>（gradle依赖自动补全）</td>
</tr>
<tr>
<td>SQLScout</td>
<td>（调试sqlite）</td>
</tr>
<tr>
<td>FindBugs-IDEA</td>
<td>（findbugs插件）</td>
</tr>
<tr>
<td>Android Methods Count</td>
<td>（预览依赖库中方法数，提前判断方法数超限）</td>
</tr>
</tbody>
</table>
<p>各插件的开发和使用成熟度很高，大部分是免费并且开源的，活跃度也很高。因为studio的使用率极高，而且IntelliJ IDE本身的插件资源丰富，直接借鉴的插件也有很多，使得插件开发的门槛大大降低。<br>那么我们自己再遇到重复性高的工作，或者第三方功能需要嵌入时，也建议考虑插件的方式。</p>
<h5 id="插件的安装方法"><a href="#插件的安装方法" class="headerlink" title="插件的安装方法"></a>插件的安装方法</h5><p>1、Preferences - plugins - Browse repositories 查找jetBrains远程仓库上的插件<br>很多插件是免费且开源的（github），远程repositories上对应的plugins都是最新的release版本<br>我们可以使用beta版本，或者自己对开源插件进行二次开发，这时就需要安装本地插件：<br>2、Preferences - plugins - Install plugin from disk 查找本地plugin的jar包</p>
<p>本文会以一个我自己二次开发的plugin为例，记录下plugin开发的基本流程和值得注意的坑。</p>
<hr>
<h4 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h4><p>studio是基于IntelliJ的二次开发的IDE，所以plugins其实是IntelliJ的插件，IntelliJ这个IDE本身就可以开发plugins，IntelliJ下载免费版即可，官网下载，community版本够用。不再赘述。</p>
<h5 id="新建及import工程"><a href="#新建及import工程" class="headerlink" title="新建及import工程"></a>新建及import工程</h5><p>新建project很多文章都有讲，不赘述，可以参考:<a href="https://www.jianshu.com/p/336a07b9d98a" target="_blank" rel="external">https://www.jianshu.com/p/336a07b9d98a</a><br>基本是配置IntelliJ sdk、创建plugin project、然后在plugin.xml中配置此插件即可</p>
<p>重点说下import工程，如果你是二次开发一个插件，那么import一个github已有的工程是必须的。以GsonFormat为例（<a href="https://github.com/zzz40500/GsonFormat/）" target="_blank" rel="external">https://github.com/zzz40500/GsonFormat/）</a><br>github工程下，分为两个分支master和dev_1.2.2其中dev开发分支可以直接用于二次开发。（master分支直接import作为project，需要IDE配置很多东西）</p>
<p>dev分支工程配置步骤</p>
<ol>
<li>import project from existing code<br>注意我们的工程是plugin,选择的sdk不是jdk1.8（此处同new project），而是IntelliJ IDEA Community，一路‘下一步’这个过程中，有一步已经把src下代码作为module放入了project，生成了GsonFormat.iml,</li>
<li>只是此时GsonFormat.iml中module type是JAVA_MODULE,而不是PLUGIN_MODULE，需要修改。<br>（project的module设置很重要，决定了project是否可以正常编译）<br>此处配置成功的标志就是 IDE出现了run 和 debug两个按钮。如果还不正常，可以进入IDE右上角的按钮进入project structure进行配置<br><img src="https://i.imgur.com/bdMkQYx.png" alt="配置sdk"></li>
<li>如果想正常编译插件，还需要一步，在 Edit Configuration中配置project的属性，见图二，新建一个Plugin Configuration，在右侧的Use classpath of module中选择刚刚的GsonFormat（由于刚刚我们成功配置了GsonFormat为PLUGIN_MODULE,否则此处找不到哦）<br><img src="https://i.imgur.com/mxQYUfN.png" alt="配置plugin的Module"></li>
<li>到了这一步，无论是run  debug 还是Prepare Plugin Module For Deployment(产出本地plugin jar)都可以了。</li>
</ol>
<h5 id="分析plugin工程"><a href="#分析plugin工程" class="headerlink" title="分析plugin工程"></a>分析plugin工程</h5><p>import成功后，我们看一下plugin工程是怎样的？<br>plugin工程中常见以下三类文件，也是plugin工程较为特有的文件类型：</p>
<ol>
<li><p>Action<br>作为整个插件的入口类，其入口方式和name等定义在plugin.xml，Action中actionPerformed作为入口方法，初始化当前类，包，传入到dialog中</p>
</li>
<li><p>Dialog 类似于android中的activity，绑定了Form类，用于view的databinding和逻辑<br>JsonDialog是入口dialog，FieldsDialog是解析jsonstring后展示的dialog，SettingDialog是配置dialog</p>
</li>
<li><p>GUI Form 类似于android中xml布局文件，只不过此处是swing的拖拽控件，Form与Dialog是配对出现，其对应关系在Form配置。</p>
</li>
</ol>
<h5 id="GsonFormat代码架构"><a href="#GsonFormat代码架构" class="headerlink" title="GsonFormat代码架构"></a>GsonFormat代码架构</h5><p>以GsonFormat plugin为例，具体讲清楚plugin工程的组成和实现原理。<br>(GsonFormat插件是把jsonString转变为javaBean的前端插件，写业务代码的朋友们应该非常熟悉，这款插件的使用过程是这样子的：)<br>第一步：弹窗：输入你要转换的jsonString，此处也可以Setting进行配置<br><img src="https://i.imgur.com/RRbLTaH.png" alt=""><br>第二步：弹窗：展示转换成功的field class，你可以在此基础上自定义。<br><img src="https://i.imgur.com/pqxUAFr.png" alt=""><br>最后：我们得到了我们想要的javaBean<br><img src="https://i.imgur.com/htvBpGV.png" alt=""><br>这个插件的基本功能如上，下面我们简单分析下源码：</p>
<h6 id="代码（类）的组织方式"><a href="#代码（类）的组织方式" class="headerlink" title="代码（类）的组织方式"></a>代码（类）的组织方式</h6><p>主Action是MainAction，作为插件的入口可以看到他启动了弹窗JsonDialog。工程中维护了几个dialog（包括java文件和form表单文件），分别对应插件工作中所有的弹窗，被放入了ui文件夹。<br><img src="http://oqjv79a9c.bkt.clouddn.com/cc0a69bf3ed271bb7afd4ccd39a106c6.png" alt=""><br>再来看其他文件夹：<br><img src="http://oqjv79a9c.bkt.clouddn.com/f2b67dfa0384153da79c35c66cd79f19.png" alt=""></p>
<ol>
<li>DataWriter类负责GsonFormat最后一步写入class文件，</li>
<li>config文件夹中类维护了插件的settings属性（属性用户可以在SettingsDialog配置），</li>
<li>entity文件夹内是实体类，classEntity fieldEntity等类都是维护最终生成class中的field及innerclass的实体类。</li>
<li>process文件夹内是处理类，jsonstring的解析，javaBean封装等具体的操作都是在这些类中完成的，是插件的核心类。</li>
</ol>
<h6 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h6><p>处理流程的代码逻辑是流式的，从MainAction入口开始看起，在JsonDialog中点击确定后，开始解析jsonString。<br>类JsonUtilsDialog中，点击事件的响应函数作为入口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">editTP.addKeyListener(new KeyAdapter() &#123;</div><div class="line">    @Override</div><div class="line">    public void keyReleased(KeyEvent keyEvent) &#123;</div><div class="line">        super.keyReleased(keyEvent);</div><div class="line">        if (keyEvent.getKeyCode() == KeyEvent.VK_ENTER) &#123;</div><div class="line">            onOK();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>1.解析的过程，主要在ConvertBridge类完成，由run方法作入口，开始解析jsonSTR<br>onOK（）方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">private void onOK() &#123;</div><div class="line">    //省略部分：get PsiClass generateClass:</div><div class="line">    new ConvertBridge(</div><div class="line">            this, errorLB, jsonSTR, mFile, mProject, generateClass,</div><div class="line">            mClass, generateClassName).run();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.ConvertBridge类中run方法，通过parseJson方法，开始解析jsonString，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">public void parseJson(JSONObject json) &#123;</div><div class="line">    if (Config.getInstant().isVirgoMode()) &#123;</div><div class="line">      //省略代码：装配mGenerateEntity对象</div><div class="line">      //createFields 解析jsonString核心方法</div><div class="line">      mGenerateEntity.setFields(createFields(json, fieldList, mGenerateEntity));</div><div class="line">      FieldsDialog fieldsDialog = new FieldsDialog(mJsonUtilsDialog, mGenerateEntity, mFactory,</div><div class="line">                mGeneratClass, currentClass, mFile, project, generateClassName);</div><div class="line">    &#125; else &#123;</div><div class="line">      mGenerateEntity.setFields(createFields(json, fieldList, mGenerateEntity));</div><div class="line">      WriterUtil writerUtil = new WriterUtil(null, null, mFile, project, mGeneratClass);</div><div class="line">      writerUtil.mInnerClassEntity = mGenerateEntity;</div><div class="line">      writerUtil.execute();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分为Virgo模式和非Virgo模式（默认virgo模式）：virgo模式，就是启动FieldsDialog，就是我们见到的第二个窗口，用户自行修改fields的定义，非virgo比较简单，跳过dialog直接写入fields到class里。除非settings自己定义，否则我们一般都使用virgo模式。可以看到无论是否virgo模式与否，都会调用createFields方法，区别只是是否显示FieldsDialog。</p>
<p>3.详细看下createFields方法做了什么。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">for (int i = 0; i &lt; list.size(); i++) &#123;</div><div class="line">    String key = list.get(i);</div><div class="line">    Object type = json.get(key);</div><div class="line">    if (type instanceof JSONArray) &#123;</div><div class="line">        //将jsonArray放入listEntityList</div><div class="line">        listEntityList.add(key);</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line">    FieldEntity fieldEntity = createFiled(parentClass, key, type);</div><div class="line">    fieldEntityList.add(fieldEntity);</div><div class="line">&#125;</div><div class="line">for (int i = 0; i &lt; listEntityList.size(); i++) &#123;</div><div class="line">    //解析listEntityList中数据</div><div class="line">    String key = listEntityList.get(i);</div><div class="line">    Object type = json.get(key);</div><div class="line"></div><div class="line">    FieldEntity fieldEntity = createFiled(parentClass, key, type);</div><div class="line">    fieldEntityList.add(fieldEntity);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过createFields方法把field放入FieldEntity，DataWriter再根据FieldEntity的内容写入class中，</p>
<p>4.以上的解析过程，只涉及了一层JavaBean的情况，JavaBean大部分情况下，是要嵌套Bean内部类的，就是JSONObject内部是嵌套jsonobject的，我们继续来看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">private FieldEntity typeByValue(InnerClassEntity parentClass, String key, Object type) &#123;</div><div class="line">        if (type instanceof JSONObject) &#123;</div><div class="line">            InnerClassEntity classEntity = checkInnerClass((JSONObject) type);</div><div class="line">            if (classEntity == null) &#123;</div><div class="line">                //省略代码</div><div class="line">            &#125; else &#123;</div><div class="line">                FieldEntity fieldEntity = new FieldEntity();</div><div class="line">                fieldEntity.setKey(key);</div><div class="line">                fieldEntity.setTargetClass(classEntity);</div><div class="line">                fieldEntity.setType(&quot;%s&quot;);</div><div class="line">                nodeBean = fieldEntity;</div><div class="line">            &#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>createFields方法中对每个fieldEntity依次调用createField方法，createFiled方法中调用了typeByValue方法，在createInnnerClass中 对子json再次进行createFields方法，如此依次递归。完成了一层层javabean的解析工作。<br>可以说Class中包括FieldEntry，而FieldEntry本身也是包含多个子FieldEntry的。FieldEntry可以设置基本类型，也可以设置ClassEntity。</p>
<p>5.最终通过WriterUtil类将FieldEntry写入到class文件中，完成了整个的插件功能。</p>
<h4 id="二次开发的部分"><a href="#二次开发的部分" class="headerlink" title="二次开发的部分"></a>二次开发的部分</h4><h5 id="开发中遇到的问题"><a href="#开发中遇到的问题" class="headerlink" title="开发中遇到的问题"></a>开发中遇到的问题</h5><p>由于代码混淆的原因，开发中经常遇到debug下正常的代码，在release包情况下无法正常解析网路数据，因为javabean类中的field混淆后已经不是原来定义的名称了。而这个问题在提测关口最容易出现。想解决这个问题必须保证javaBean在打包中不被混淆。<br>如何不被混淆，不同厂商有不同的解决策略（规范）：</p>
<ol>
<li>统一放到一个文件夹里（或者含固定名称的文件夹），混淆时ignore 这些文件夹。<br>但是这办法操作起来不完美，一个是重构后文件夹容易变名字，还有团队开发时无法保证所有的人都遵守。处理代码时都要绷着文件夹名称这个弦。</li>
<li>所有JavaBean extends Serializable(统一基类)<br>这样proguard文件中保证所有Seriallizable的子类不被混淆即可。而且Bundle传递参数时javaBean可以直接被用。但是这个办法也有一个缺点：需要保证所有人遵守这个约定，无法规范这个步骤。</li>
</ol>
<h5 id="我们的解决方式："><a href="#我们的解决方式：" class="headerlink" title="我们的解决方式："></a>我们的解决方式：</h5><p>一般我们的接口管理系统中，都可以产生mock的jsonString，客户端开发会直接利用SGsonFormat插件将jsonString直接转为JavaBean，所以基于GsonFormat功能二次开发，让所有的JavaBean class统一继承Serializable，这样兼顾了易用性和统一性。</p>
<h6 id="GsonFormat的二次开发："><a href="#GsonFormat的二次开发：" class="headerlink" title="GsonFormat的二次开发："></a>GsonFormat的二次开发：</h6><p>统一继承Serializable的逻辑，应该放入DataWriter写入的流程中，分析可得：在ClassProcessor中process方法，实际上将classContent的String内容通过PsiElementFactory写入class文件中，所以修改String classContent既可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">protected void generateClass(PsiElementFactory factory, ClassEntity classEntity, PsiClass parentClass, IProcessor visitor) &#123;</div><div class="line"></div><div class="line">    onStartGenerateClass(factory, classEntity, parentClass, visitor);</div><div class="line">    PsiClass generateClass = null;</div><div class="line">    if (classEntity.isGenerate()) &#123;</div><div class="line">        if (Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">            try &#123;</div><div class="line">                generateClass = PsiClassUtil.getPsiClass(</div><div class="line">                        parentClass.getContainingFile(), parentClass.getProject(), classEntity.getQualifiedName());</div><div class="line">            &#125; catch (Throwable throwable) &#123;</div><div class="line">                throwable.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            //根据classContent创建class</div><div class="line">            String classContent =</div><div class="line">                    &quot;public static class &quot; + classEntity.getClassName() + &quot; implements Serializable&quot; + &quot;&#123;&#125;&quot;;</div><div class="line">            generateClass = factory.createClassFromText(classContent, null).getInnerClasses()[0];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (generateClass != null) &#123;</div><div class="line">            //递归调用，创建内部类</div><div class="line">            for (ClassEntity innerClass : classEntity.getInnerClasss()) &#123;</div><div class="line">                generateClass(factory, innerClass, generateClass, visitor);</div><div class="line">            &#125;</div><div class="line">            if (!Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">                generateClass = (PsiClass) parentClass.add(generateClass);</div><div class="line">            &#125;</div><div class="line">            //创建内部变量</div><div class="line">            for (FieldEntity fieldEntity : classEntity.getFields()) &#123;</div><div class="line">                generateField(factory, fieldEntity, generateClass, classEntity);</div><div class="line">            &#125;</div><div class="line">            //创建内部变量getter setter方法</div><div class="line">            generateGetterAndSetter(factory, generateClass, classEntity);</div><div class="line">            generateConvertMethod(factory, generateClass, classEntity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    onEndGenerateClass(factory, classEntity, parentClass, generateClass, visitor);</div><div class="line">    if (Config.getInstant().isSplitGenerate()) &#123;</div><div class="line">        formatJavCode(generateClass);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插件下载地址：（该插件已提交repository） <a href="https://plugins.jetbrains.com/plugin/11100-sgsonformat/update/49532" target="_blank" rel="external">https://plugins.jetbrains.com/plugin/11100-sgsonformat/update/49532</a><br>或者直接搜索SGsonFormat，install即可使用</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>二次开发的改动并不大，但是把Studio的plugin开发环境和流程算是熟悉了一遍，plugin插件的开发可以说你会用java就能上手，只不过他自定义的文件类型和组织方式需要熟悉。如果有需要的话，做个新的plugin提高工作效率，是个很好的方式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/hybrid/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/07/hybrid/" itemprop="url">Hybrid应用开发初探</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T00:00:00+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="Hybrid开发定义和使用范围"><a href="#Hybrid开发定义和使用范围" class="headerlink" title="Hybrid开发定义和使用范围"></a>Hybrid开发定义和使用范围</h2><h6 id="为什么要采用hybrid："><a href="#为什么要采用hybrid：" class="headerlink" title="为什么要采用hybrid："></a>为什么要采用hybrid：</h6><p>现阶段的应用开发，会遇到如下问题和挑战：<br>1 一些页面或业务，和运营强相关，无法native固定（例如电子商务 详情展示）<br>2 客户端发版周期长，一些需求想要很快上线，或变化非常频繁</p>
<p>现有3类主流APP，分别为：Web App、Hybrid App（混合模式应用，Hybrid有“混合的”意思）、 Native App；</p>
<p>Native App 和 Web App不作解释了，主要解释Hybrid App。<br>Hybrid App按网页语言与程序语言的混合，通常分为三种类型：多View混合型，单View混合型，Web主体型。</p>
<h6 id="单页混合型"><a href="#单页混合型" class="headerlink" title="单页混合型"></a>单页混合型</h6><p>即在同一个页面内，同时包括Native View和Web View。互相之间是覆盖（层叠）的关系。这种Hybrid App的开发成本较高，开发难度较大，但是体验较好。如百度搜索为代表的单页混合型移动应用，既可以实现充分的灵活性，又能实现较好的用户体验。一般如无特殊需求，不会采用此种方式。</p>
<h6 id="Web主体型"><a href="#Web主体型" class="headerlink" title="Web主体型"></a>Web主体型</h6><p>这种常见于市面上第三方hybrid框架实现。例如Wex5，AppCan和Rexsee都属于Web主体型移动应用中间件。基本可以实现跨平台，主要以网页语言编写，利用框架生成native的壳子。但是一般用户体验存在缺陷。常见于一些小型或功能单一app。</p>
<h6 id="多主体混合型"><a href="#多主体混合型" class="headerlink" title="多主体混合型"></a>多主体混合型</h6><p>即Native View和Web View独立展示，交替出现。这种应用混合逻辑相对简单。这种移动应用主体通常是Native App，Web技术只是起到补充作用。开发难度和Native App基本相当。常见的Hybrid App是Native View与WebView交替的场景出现。</p>
<h6 id="与App内接入H5的区别："><a href="#与App内接入H5的区别：" class="headerlink" title="与App内接入H5的区别："></a>与App内接入H5的区别：</h6><p>hybrid的开发模式与我们之前一些运营页面采用h5的根本区别在于，后者只是在一些不重要的功能上实现可运营和便于分享，并不接入到应用的主要流程中，与native的交互较少，对应用的影响小，作为开发的一个小模块独立存在。hybrid开发则是将web页面作为native的重要补充，应用功能的重要组成部分，需要考虑上线节奏，web与native的通讯，优化web体验等问题，对于应用来讲，web与native的地位，被大大拉平了。</p>
<h5 id="如何区分Hybrid-APP中的原生页面和H5页面"><a href="#如何区分Hybrid-APP中的原生页面和H5页面" class="headerlink" title="如何区分Hybrid APP中的原生页面和H5页面"></a>如何区分Hybrid APP中的原生页面和H5页面</h5><p>很多人从页面的设计上来区分的。如：（1）顶部显示网页链接；（2）有加载的进度条；（3）没有底部tab导航栏；（4）顶部显示两个导航条；<br>但是现在app的h5页面做的可以以假乱真了，这些统统不管用。<br>以淘宝为例：<br><img src="http://upload-images.jianshu.io/upload_images/738531-b9c78c9eb6330834.png" alt=""></p>
<h5 id="设置-开发者选项-显示布局边界"><a href="#设置-开发者选项-显示布局边界" class="headerlink" title="设置-开发者选项-显示布局边界"></a>设置-开发者选项-显示布局边界</h5><p>H5中使用了webview控件，其作为一个控件，只有一个边界框，所以通过这一点，就比较容易区分出一个界面是webview实现的还是原生布局控件实现的<br>这次再来看看：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/738531-76cbd5f6bffafcbf.png" alt=""></p>
<p>几个主流HybridApp：淘宝、京东、大众点评等</p>
<h4 id="Hybrid中Native和H5的使用范围"><a href="#Hybrid中Native和H5的使用范围" class="headerlink" title="Hybrid中Native和H5的使用范围:"></a>Hybrid中Native和H5的使用范围:</h4><p>Native<br>1 应用核心逻辑：例如 下单、支付等<br>2 对手机native功能（如照相、定位）重度依赖的页面<br>3 用户体验要求强，运营要求弱的页面<br>H5：<br>1.功能开发不完善，试运营阶段（试错成本低）<br>2.强运营需求，在功能调整或内容的运营上很灵活<br>3.阶段性的营销活动，希望被分享出去</p>
<h2 id="Hybrid开发中要解决的几个问题"><a href="#Hybrid开发中要解决的几个问题" class="headerlink" title="Hybrid开发中要解决的几个问题"></a>Hybrid开发中要解决的几个问题</h2><p>一、H5 和 Native 上线时间不一致，如何衔接？<br>二、H5 和 Native 之间如何进行通信？<br>三、H5 页面如何接近 Native 的体验？<br>针对几个问题，参考了美团团队技术分享的解决方案，同时根据自己的理解做了适当的扩展：</p>
<h5 id="1-H5-和-Native-上线时间不一致，如何衔接？"><a href="#1-H5-和-Native-上线时间不一致，如何衔接？" class="headerlink" title="1. H5 和 Native 上线时间不一致，如何衔接？"></a>1. H5 和 Native 上线时间不一致，如何衔接？</h5><p>比如一个功能以H5形式作出，但H5的发布滞后于native，当H5上线之后，客户端需要给H5提供一些跳转的入口，这个跳转的入口提供的应该是在不发版的情况下去给出的。<br>这就需要对路由的跳转做到后台的可配置。<br>现阶段的跳转：（Native 到 Native）<br>这种组件化的全局统跳协议，利用ARouter、天猫统跳协议等其他路由机制，都可以实现。<br><img src="http://upload-images.jianshu.io/upload_images/2638203-a70659645a2243ed" alt=""><br>对这个跳转去做一些扩展：对路由协议扩展后，让他能支持跳转到H5里。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/2638203-60f2c090a2eecfe1" alt=""><br>通过后台动态决定一个页面，究竟是native还是h5的展现形式。<br>举个例子：<br>在APP里一个购物下单的流程，用户需要访问列表页，商家的详情页，创建订单，最后购买成功。对一些新的产品，有新的产品详情和创建订单样式。可以通过h5上线的方式：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2638203-d32af64ba8238c55" alt=""><br>可以看到流程的两端都是native，中间环节从native到h5可以动态切换<br>备注：这些路由配置，是实际需求的少数，作为主体方案的有效补充存在。</p>
<h5 id="2-H5-和-Native-如何进行通信？"><a href="#2-H5-和-Native-如何进行通信？" class="headerlink" title="2. H5 和 Native 如何进行通信？"></a>2. H5 和 Native 如何进行通信？</h5><h6 id="传统的JSInterface（兼容性）"><a href="#传统的JSInterface（兼容性）" class="headerlink" title="传统的JSInterface（兼容性）"></a>传统的JSInterface（兼容性）</h6><p>看一段html代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;zh-CN&quot; dir=&quot;ltr&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;</div><div class="line"></div><div class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">        function showToast(toast) &#123;</div><div class="line">            javascript:control.showToast(toast);</div><div class="line">        &#125;</div><div class="line">        function log(msg)&#123;</div><div class="line">            console.log(msg);</div><div class="line">        &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line"></div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;input type=&quot;button&quot; value=&quot;toast&quot;</div><div class="line">       onClick=&quot;showToast(&apos;Hello world&apos;)&quot; /&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>对应的java代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line"></div><div class="line">    private WebView webView;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        webView = (WebView)findViewById(R.id.webView);</div><div class="line"></div><div class="line">        WebSettings webSettings = webView.getSettings();</div><div class="line"></div><div class="line">        webSettings.setJavaScriptEnabled(true);</div><div class="line"></div><div class="line">        webView.addJavascriptInterface(new JsInterface(), &quot;control&quot;);</div><div class="line"></div><div class="line">        webView.loadUrl(&quot;file:///android_asset/interact.html&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class JsInterface &#123;</div><div class="line"></div><div class="line">        @JavascriptInterface</div><div class="line">        public void showToast(String toast) &#123;</div><div class="line">            Toast.makeText(MainActivity.this, toast, Toast.LENGTH_SHORT).show();</div><div class="line">            log(&quot;show toast success&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public void log(final String msg)&#123;</div><div class="line">            webView.post(new Runnable() &#123;</div><div class="line">                @Override</div><div class="line">                public void run() &#123;</div><div class="line">                    webView.loadUrl(&quot;javascript: log(&quot; + &quot;&apos;&quot; + msg + &quot;&apos;&quot; + &quot;)&quot;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过webView.addJavascriptInterface(new JsInterface(), “control”)，将js的control与native的JsInterface联系起来，实现了js向native的调用。反过来，webView.loadUrl(“javascript: log(“ + “‘“ + msg + “‘“ + “)”)，loadUrl调用到js中定义的log方法，实现了native到js的回调。</p>
<p>但是，，，<br>4.2版本之前的addjavascriptInterface接口引起的漏洞，可能导致恶意网页通过Js方法遍历刚刚通过addjavascriptInterface注入进来的类的所有方法从中获取到getClass方法，然后通过反射获取到Runtime对象，进而调用Runtime对象的exec方法执行一些操作，恶意的Js代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function execute(cmdArgs) &#123;</div><div class="line">    for (var obj in window) &#123;</div><div class="line">        if (&quot;getClass&quot; in window[obj]) &#123;</div><div class="line">            alert(obj);</div><div class="line">            return  window[obj].getClass().forName(&quot;java.lang.Runtime&quot;)  </div><div class="line">                 .getMethod(&quot;getRuntime&quot;,null).invoke(null,null).exec(cmdArgs);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.2以后通过为可以被Js调用的方法添加@JavascriptInterface注解来解决，但是4.2之前的版本兼容性存在问题。而且这种类似于函数式的调用方式，扩展性和两端的兼容性都受限，所以他也就没法广泛采用了。</p>
<h6 id="UrlRouter"><a href="#UrlRouter" class="headerlink" title="UrlRouter"></a>UrlRouter</h6><p>严格的说，UrlRouter不算是js和java的通信，它只是一个通过url来让前端唤起native页面的框架。不过千万不要小看它的作用，如果协议定义的合理，它可以让前端，Android和iOS三端有一个高度的统一，十分方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">public class NavWebViewClient extends WebViewClient &#123;</div><div class="line"></div><div class="line">    private Context context;</div><div class="line"></div><div class="line">    public NavWebViewClient(Context context)&#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">        if( Nav.from(context).toUri(url))&#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        view.loadUrl(url);</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在方法shouldOverrideUrlLoading中，拦截后交给Nav处理，如果返回true则成功拦截，返回false则交给webview去load url。Nav中的解析处理，可以根据业务特点，根据scheme host url地址解析出跳转路径和携带的参数。<br>关于携带参数，再多说两句：h5与native要约定传参的格式，比如json格式，那么在json字串里约定好字段的含义，就可以传参，比如要实现跳转到指定页面，并携带参数：</p>
<p><code>{&quot;p&quot;: &quot;orderlist&quot;,&quot;pa&quot;: {&quot;tp&quot;: &quot;per&quot;}}</code></p>
<p>字段p代码代码页面，字段pa代表参数，pa字段后面的json表示此页面需要的具体传参。要注意传参部分要进行加密处理。</p>
<p>######JSBridge<br>这种方式不算新，一些大公司都有自己的jsBridge封装方式，这里简要说明一下基本原理。<br>WebView中有一个WebChromeClient类，有三个监听函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</div><div class="line">    return super.onJsPrompt(view, url, message, defaultValue, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onJsAlert(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">    return super.onJsAlert(view, url, message, result);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@Override</div><div class="line">public boolean onJsConfirm(WebView view, String url, String message, JsResult result) &#123;</div><div class="line">    return super.onJsConfirm(view, url, message, result);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在js中，alert和confirm本身的使用概率还是很高的，不建议使用这两个通道，onJsPrompt方法则可以用来js与java通信。通过在回调函数中message参数传递通讯协议，native根据协议解析决定自己的操作。</p>
<p>onJsPrompt方法中message参数：<code>hybrid://JSBridge:1538351/method?{“message”:”msg”}</code></p>
<p>sheme是hybrid://，host是JSBridge，方法名字是toast，传递的参数是以json格式传递的<br>java层的处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class InjectedChromeClient extends WebChromeClient &#123;</div><div class="line">    private final String TAG = &quot;InjectedChromeClient&quot;;</div><div class="line"></div><div class="line">    private JsCallJava mJsCallJava;</div><div class="line"></div><div class="line">    public InjectedChromeClient() &#123;</div><div class="line">        mJsCallJava = new JsCallJava();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public boolean onJsPrompt(WebView view, String url, String message, String defaultValue, JsPromptResult result) &#123;</div><div class="line">        result.confirm(mJsCallJava.call(view, message));</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>核心的call方法做了哪些？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">public String call(WebView webView, String jsonStr) &#123;</div><div class="line">    String methodName = &quot;&quot;;</div><div class="line">    String name = BRIDGE_NAME;</div><div class="line">    String param = &quot;&#123;&#125;&quot;;</div><div class="line">    String result = &quot;&quot;;</div><div class="line">    String sid=&quot;&quot;;</div><div class="line">    if (!TextUtils.isEmpty(jsonStr) &amp;&amp; jsonStr.startsWith(SCHEME)) &#123;</div><div class="line">        Uri uri = Uri.parse(jsonStr);</div><div class="line">        name = uri.getHost();</div><div class="line">        param = uri.getQuery();</div><div class="line">        sid = getPort(jsonStr);</div><div class="line">        String path = uri.getPath();</div><div class="line">        if (!TextUtils.isEmpty(path)) &#123;</div><div class="line">            methodName = path.replace(&quot;/&quot;, &quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    if (!TextUtils.isEmpty(jsonStr)) &#123;</div><div class="line">        try &#123;</div><div class="line">            ArrayMap&lt;String, Method&gt; methodMap = mInjectNameMethods.get(name);</div><div class="line"></div><div class="line">            Object[] values = new Object[3];</div><div class="line">            values[0] = webView;</div><div class="line">            values[1] = new JSONObject(param);</div><div class="line">            values[2]=new JsCallback(webView,sid);</div><div class="line">            Method currMethod = null;</div><div class="line">            if (null != methodMap &amp;&amp; !TextUtils.isEmpty(methodName)) &#123;</div><div class="line">                currMethod = methodMap.get(methodName);</div><div class="line">            &#125;</div><div class="line">            // 方法匹配失败</div><div class="line">            if (currMethod == null) &#123;</div><div class="line">                result = getReturn(jsonStr, RESULT_FAIL, &quot;not found method(&quot; + methodName + &quot;) with valid parameters&quot;);</div><div class="line">            &#125;else&#123;</div><div class="line">                result = getReturn(jsonStr, RESULT_SUCCESS, currMethod.invoke(null, values));</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        result = getReturn(jsonStr, RESULT_FAIL, &quot;call data empty&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>代码的思路如下：<br>(1) 在js脚本中把对应的方法名，参数等写成一个符合协议的uri，并且通过window.prompt方法发送给java层。</p>
<p>(2) 在java层的onJsPrompt方法中接受到对应的message之后，通过JsCallJava类进行具体的解析。</p>
<p>(3) 在JsCallJava类中，我们解析得到对应的方法名，参数等信息，并且在map中查找出对应的类的方法。</p>
<p>思考：为什么不对message中的字段进行switch case的逻辑判断，而是要经过mInjectNameMethods的遍历呢?</p>
<p>在业务复杂，应用已经组件化的情况下，JSBridge一定是作为整体架构的一部分存在的，那么其定义和使用可能是分离的，通过mInjectNameMethods遍历的方法，JSBridge中定义方法的权利交给了业务部门，有效实现了解耦。</p>
<p><strong>可以这么说UrlRouter在页面跳转方面，JSBridge在方法调用方面，都具备各自的特点和优势，可以有效的结合起来。</strong></p>
<h5 id="3-H5-页面如何接近-Native-的体验？"><a href="#3-H5-页面如何接近-Native-的体验？" class="headerlink" title="3 . H5 页面如何接近 Native 的体验？"></a>3 . H5 页面如何接近 Native 的体验？</h5><h6 id="资源加载缓慢"><a href="#资源加载缓慢" class="headerlink" title="资源加载缓慢"></a>资源加载缓慢</h6><p>1.模块化你的 H5 页面/应用，引入模块加载器<br>2.资源预加载<br>第一种方式是说使用 WebView 自身的缓存机制<br>这种缓存，系统会自动把它清掉，我们没法进行控制<br>第二种方案是说，我们自己去构建，自己管理缓存<br>把这些需要预加载的资源放在 APP 里面，他可能是预制放进去的，也可能是后续下载的。<br>每当这个 WebView 发起资源请求的时候，我们会拦截到这些资源的请求，去本地检查一下我们的这些静态资源本地离线包有没有。针对本地的缓存文件我们有些策略能够及时的去更新它<br><img src="http://upload-images.jianshu.io/upload_images/2638203-321faacaeb38d7e6" alt=""><br>资源预加载效果：<br><img src="http://upload-images.jianshu.io/upload_images/2638203-43d00f93cffd7391" alt=""><br>每个页面在预加载后都有明显提升（4G下明显），同时横向比较，也可看出，在一系列的web加载过程中，平均时间再降低。也说明了webview自身的缓存机制。<br>腾讯开源的hybrid框架（实际只是webview首屏优化），实践了webview的优化，具体原理可以去github:<br><a href="https://github.com/Tencent/VasSonic" target="_blank" rel="external">https://github.com/Tencent/VasSonic</a></p>
<p>VasSonic有如下特点（缺点）:<br>1.VasSonic的技术实现上，需要服务端、客户端 同时修改配合；<br>2.目前sonic后台仅支持node.js和php版本，暂时还不支持其他后台；<br>3.iOS 只支持UIWebView，不支持WKWebView，主要是因为在WKWebView目前不支持NSURLProtocol拦截；<br>vassonic这套方案，对于现有项目还是有一定侵入性的，而且需要服务端配合。可以参考其思路，完全照搬对于大项目有风险。</p>
<p>最后放一张hybrid客户端架构图</p>
<p><img src="http://img1.tuicool.com/Zjiyyu.png!web" alt=""></p>
<p>H5Container是架构设计的重点和难点，其中nativeApi，HandwareApi都是对于手机对web提供功能的封装。Data Channel负责埋点;JSBridge是处于底层的通讯接口，JSBridges为各个模块的定制和扩展。<br>Synchronize Service 模块表示和服务器的长连接通信模块，用于接受服务器端各种推送，包括离线包等。 Source Merge Service 模块表示对解压后的H5资源进行更新，包括增加文件、以旧换新以及删除过期文件等。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>一般来说Hybrid的项目一般是用在一些快速迭代试错的地方。另外包括有一些非主流产品的页面，我们倾向于用 Hybrid 的形式做.<br>但是像前端购买一些交易环节，特别核心的流程的话，我们一般情况下会用 Native 的形式去写这些页面，去提升，达到一个极致的用户体验。不要为了hybrid而hybrid，一切都是根据需求的实际情况出发，同时hybrid的框架在设计时，协议方面要注意ios android两端的统一，android端自身尽量考虑扩展性和解耦，有利于后续开发迭代的稳定和迅速。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/24/webserver/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/24/webserver/" itemprop="url">mac上web服务器配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-24T00:00:00+08:00">
                2017-11-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="自己的Web服务器：mac本地"><a href="#自己的Web服务器：mac本地" class="headerlink" title="自己的Web服务器：mac本地"></a>自己的Web服务器：mac本地</h2><h3 id="web服务器的用途"><a href="#web服务器的用途" class="headerlink" title="web服务器的用途"></a>web服务器的用途</h3><p>本地的web服务器使用上，当然受限。只能在局域网内使用。在android native的开发中，一些测试用的前端页面，就可以借助web服务器部署来完成了。</p>
<h3 id="web服务器mac上的配置"><a href="#web服务器mac上的配置" class="headerlink" title="web服务器mac上的配置"></a>web服务器mac上的配置</h3><p>mac上自带Apache和PHP环境，我们只要启动并配置就ok了。</p>
<h4 id="启动-Apache"><a href="#启动-Apache" class="headerlink" title="启动 Apache"></a>启动 Apache</h4><p>sudo apachectl -k start 启动Apache服务器<br>sudo apachectl -k stop  停止Apache服务器<br>启动后，在浏览器中输入 <a href="http://127.0.0.1" target="_blank" rel="external">http://127.0.0.1</a> 或 <a href="http://localhost" target="_blank" rel="external">http://localhost</a> 如果看到It Works!就是启动成功了。实际启动的是/Library/WebServer/Documents/index.html.en;</p>
<p>那么可以推论了，如果我们自己写一个html，替换上面地址的html就可以了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/ARouter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/ARouter/" itemprop="url">ARouter:Anroid组件化方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="ARouter-Anroid组件化方案"><a href="#ARouter-Anroid组件化方案" class="headerlink" title="ARouter:Anroid组件化方案"></a>ARouter:Anroid组件化方案</h2><h3 id="组件化的引入"><a href="#组件化的引入" class="headerlink" title="组件化的引入"></a>组件化的引入</h3><p>一般认为组件化是业务和人员庞大后，团队协作的基础。也是业务庞大后代码架构的必经之路。</p>
<h4 id="组件化可以带来"><a href="#组件化可以带来" class="headerlink" title="组件化可以带来"></a>组件化可以带来</h4><ol>
<li>降低代码耦合度</li>
</ol>
<p>高耦合的代码随着项目的复杂性不断增加，最后会变成一团浆糊，功能A改动会导致功能B、C也要改动，牵一发动全身。辛苦写的功能A耦合着其他功能的代码，新的需求没办法直接复用。</p>
<ol>
<li>架构更清晰</li>
</ol>
<p>整个工程像是功能的堆砌，没有合理的层次、结构。工程模块越来越大，开发中解决冲突花费大量时间，替换方案实现困难，程序难以扩展。</p>
<h4 id="组件化中要解决的问题"><a href="#组件化中要解决的问题" class="headerlink" title="组件化中要解决的问题"></a>组件化中要解决的问题</h4><ol>
<li>依赖关系</li>
</ol>
<p>依赖倒置，面向接口编程</p>
<ol>
<li>调用方式</li>
</ol>
<p>扩展性，易于管理</p>
<h4 id="组件化模块间调用的场景包括"><a href="#组件化模块间调用的场景包括" class="headerlink" title="组件化模块间调用的场景包括"></a>组件化模块间调用的场景包括</h4><ol>
<li>Activity的页面跳转</li>
<li>接口服务调用</li>
<li>Fragment获得实例<h4 id="以前的解决方案对比"><a href="#以前的解决方案对比" class="headerlink" title="以前的解决方案对比"></a>以前的解决方案对比</h4></li>
<li>Activity跳转</li>
</ol>
<p>Intent显式调用：模块会有依赖</p>
<p>Intent隐式调用：Manifest 扩展性差，管理不方便</p>
<ol>
<li>EventBus 容易被滥用</li>
</ol>
<p>不清楚谁调用，也不清楚请求被谁接受，复杂后调用链条不容易定位；注册管理困难；</p>
<p>所以我们需要一类组件解决模块间依赖问题，满足模块间调用需求；同时这个组件要有一定的扩展性，最好不会有EventBus这样的问题。</p>
<hr>
<h3 id="业内Route方案比较"><a href="#业内Route方案比较" class="headerlink" title="业内Route方案比较"></a>业内Route方案比较</h3><table>
<thead>
<tr>
<th>方案对比</th>
<th>DeepLinkDispatch</th>
<th>ARouter</th>
<th>天猫统跳协议</th>
<th>ActivityRouter</th>
</tr>
</thead>
<tbody>
<tr>
<td>路由注册</td>
<td>Module手动注册</td>
<td>注解自动注册</td>
<td>Manifest配置</td>
<td>注解自动注册</td>
</tr>
<tr>
<td>路由查找</td>
<td>路由表</td>
<td>路由表</td>
<td>系统Intent</td>
<td>路由表</td>
</tr>
<tr>
<td>动态拦截</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>服务接口</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>结果返回</td>
<td>onActivityResult</td>
<td>onActivityResult</td>
<td>onActivityResult</td>
<td>onActivityResult</td>
</tr>
<tr>
<td>InstantRun</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<p>业内比较完善的Route协议，如上表所示，综合来看ARouter各方面都比较均衡，而且大厂使用的比较多，比分领先的还是比较多的，看来没理由不选他了。本文将以ARouter为例，讲述组件化中ARouter的最佳实践和基本原理。</p>
<hr>
<h3 id="ARouter最佳实践"><a href="#ARouter最佳实践" class="headerlink" title="ARouter最佳实践"></a>ARouter最佳实践</h3><p>ARouter的配置和初始化，见ARouter的github官方网站<br>在专车、租车app中，典型的应用场景为<br>1.从外部URL映射到内部页面，以及参数传递和解析<br>2.跨模块页面跳转，模块间解耦<br>3.拦截跳转过程，处理登录、埋点等逻辑<br>4.跨模块API调用，通过控制反转来做组件间解耦<br>我们分别将各个使用场景一一讲述：</p>
<h4 id="应用内页面跳转"><a href="#应用内页面跳转" class="headerlink" title="应用内页面跳转"></a>应用内页面跳转</h4><p>调用方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//  跳转并携带参数</div><div class="line">ARouter.getInstance().build(&quot;/test/activity1&quot;)</div><div class="line">			.withInt(&quot;key1&quot;, 666L)</div><div class="line">			.withString(&quot;girl&quot;, &quot;888&quot;)</div><div class="line">			.withObject(&quot;key4&quot;, new TestObj(&quot;Jack&quot;, &quot;Rose&quot;))</div><div class="line">			.navigation();</div></pre></td></tr></table></figure></p>
<p>注册方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">// 为每一个参数声明一个字段，并使用 @Autowired 标注</div><div class="line">// URL中不能传递Parcelable类型数据，通过ARouter api可以传递Parcelable对象</div><div class="line">@Route(path = &quot;/test/activity1&quot;)</div><div class="line">public class Test1Activity extends Activity &#123;</div><div class="line">    @Autowired</div><div class="line">    public String name;</div><div class="line">    @Autowired</div><div class="line">    int age;</div><div class="line">    @Autowired(name = &quot;girl&quot;) // 通过name来映射URL中的不同参数</div><div class="line">    String boy;</div><div class="line">    @Autowired</div><div class="line">    TestObj obj;    // 支持解析自定义对象，URL中使用json传递</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	super.onCreate(savedInstanceState);</div><div class="line">	ARouter.getInstance().inject(this);</div><div class="line"></div><div class="line">	// ARouter会自动对字段进行赋值，无需主动获取</div><div class="line">	Log.d(&quot;param&quot;, name + age + boy);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>为了简化使用，ARouter也借鉴了注解的方式，方便使用者声明参数和调用对象。但是如果所有的页面都使用ARouter的页面path跳转，可能出现调用方不知道跳到哪里，被调用方不知道是谁调起的情况，这也是完全解耦带来的弊端（类似于EventBus的过度使用），而且对于编译时间的影响也很大。<br>所以建议：<br>1 模块内部跳转采用原生方式，模块对外采用path跳转，模块维护对外(path,target） MAP<br>2 采用代码糖方式（所有跳转都由ARouter管理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">@Route(Path=&quot;/message/center&quot;,name=&quot;消息中心&quot;)</div><div class="line">public class MessageCenterActivity&#123;</div><div class="line">	public static void launch(Activity c)&#123;</div><div class="line">    	ARouter.getInstance().build(&quot;/message/center&quot;).navigation(c);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="通过URI跳转（解析web、第三方应用跳转）"><a href="#通过URI跳转（解析web、第三方应用跳转）" class="headerlink" title="通过URI跳转（解析web、第三方应用跳转）"></a>通过URI跳转（解析web、第三方应用跳转）</h4><p>SchemeFilterActivity接受URI后，ARouter统一解析跳转协议，此协议与应用内部native跳转相同，保证协议的统一。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 新建一个Activity用于监听Schame事件,之后直接把url传递给ARouter即可</div><div class="line">public class SchameFilterActivity extends Activity &#123;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">	super.onCreate(savedInstanceState);</div><div class="line"></div><div class="line">	Uri uri = getIntent().getData();</div><div class="line">	ARouter.getInstance().build(uri).navigation();</div><div class="line">	finish();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>SchemeFilterActivity的注册：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;activity android:name=&quot;.activity.SchameFilterActivity&quot;&gt;</div><div class="line">	&lt;!-- Schame --&gt;</div><div class="line">	&lt;intent-filter&gt;</div><div class="line">	    &lt;data</div><div class="line">		android:host=&quot;host&quot;</div><div class="line">		android:scheme=&quot;ucar2015&quot;/&gt;</div><div class="line"></div><div class="line">	    &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt;</div><div class="line"></div><div class="line">	    &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;</div><div class="line">	    &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt;</div><div class="line">	&lt;/intent-filter&gt;</div><div class="line">&lt;/activity&gt;</div></pre></td></tr></table></figure></p>
<p>举例：<br>外部Url跳转链接：<br>ucar2015://host/test/activity1?name=alex&amp;age=18&amp;boy=true</p>
<h4 id="模块间通讯解耦：控制反转"><a href="#模块间通讯解耦：控制反转" class="headerlink" title="模块间通讯解耦：控制反转"></a>模块间通讯解耦：控制反转</h4><p>除了模块间页面跳转，模块之间的调用通信也很常见。比如一些反向依赖，底层的逻辑抛到上层处理，或者模块A需要调用模块B的服务。</p>
<p>以往的处理方式只能是模块都耦合在一起，相互调用方便但是也互相耦合。我们也可以利用依赖反转，将各个模块都依赖于IoC容器，这样模块之间的耦合被解开了。ARouter本身就是一个IoC容器，IProvider提供的是一种Service，此处的Service类似于服务端的Service，提供的是一种服务，而不是Android的Service。有点类似于AIDL的调用方式。<br>优势：<br>1 模块间解耦<br>2 模块可独立打包<br><img src="http://oqjv79a9c.bkt.clouddn.com/%E5%9B%BE%E7%89%87%201.png" alt=""><br>Ioc容器定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 声明接口,其他组件通过接口来调用服务</div><div class="line">public interface HelloService extends IProvider &#123;</div><div class="line">    String sayHello(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接口实现层：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// 实现接口</div><div class="line">@Route(path = &quot;/service/hello&quot;, name = &quot;测试服务&quot;)</div><div class="line">public class HelloServiceImpl implements HelloService &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String sayHello(String name) &#123;</div><div class="line">	return &quot;hello, &quot; + name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void init(Context context) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>服务调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    @Autowired</div><div class="line">    HelloService helloService;</div><div class="line"></div><div class="line">    @Autowired(name = &quot;/service/hello&quot;)</div><div class="line">    HelloService helloService2;</div><div class="line"></div><div class="line">    HelloService helloService3;</div><div class="line"></div><div class="line">    HelloService helloService4;</div><div class="line"></div><div class="line">    public Test() &#123;</div><div class="line">	ARouter.getInstance().inject(this);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void testService() &#123;</div><div class="line">	 // 1. (推荐)使用依赖注入的方式发现服务,通过注解标注字段,即可使用，无需主动获取</div><div class="line">	 // Autowired注解中标注name之后，将会使用byName的方式注入对应的字段，不设置name属性，会默认使用byType的方式发现服务(当同一接口有多个实现的时候，必须使用byName的方式发现服务)</div><div class="line">	helloService.sayHello(&quot;Vergil&quot;);</div><div class="line">	helloService2.sayHello(&quot;Vergil&quot;);</div><div class="line"></div><div class="line">	// 2. 使用依赖查找的方式发现服务，主动去发现服务并使用，下面两种方式分别是byName和byType</div><div class="line">	helloService3 = ARouter.getInstance().navigation(HelloService.class);</div><div class="line">	helloService4 = (HelloService) ARouter.getInstance().build(&quot;/service/hello&quot;).navigation();</div><div class="line">	helloService3.sayHello(&quot;Vergil&quot;);</div><div class="line">	helloService4.sayHello(&quot;Vergil&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ARouter源码分析"><a href="#ARouter源码分析" class="headerlink" title="ARouter源码分析"></a>ARouter源码分析</h3><p>定义：ARouter是Android平台中对页面、服务提供路由功能的中间件。<br>优势：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%201.png" alt=""><br>代码结构：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%202.png" alt=""><br>ARouter的依赖工程分为Annotation compiler Api三部分，Annotation保存自定义注解，Compiler 保证在编译期，按照注解、规则生成帮助代码。Api是客户端实际调用。</p>
<p>下面从编译、运行时初始化、调用三方面分析ARouter的实现方案。</p>
<h5 id="编译阶段："><a href="#编译阶段：" class="headerlink" title="编译阶段："></a>编译阶段：</h5><p>compiler自动生成的代码（路由清单的生成）<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%203.png" alt=""><br>ARouter$$Group$$service和ARouter$$Group$$test分别是分组service和test的组内清单，可以想象成1班和2班的学生名单。<br>ARouter$$Root$$app是组别的清单列表，可以想象成班级清单，1班和2班。</p>
<p>这也体现了分组归类、按需加载的原则，初始化只加载ARouter$$Root$$app，首次调用时把该group内所有内容加载，并内存缓存。</p>
<p>注：PROVIDER在Providers类别里有一份，在Group里也有一份，provider的启动也有两种。</p>
<p>看一下：BlankFragment$$ARouter$$Autowired，了解入参自动注入如何完成。</p>
<p>通过这些编译产物，我们可以看到以下几点：<br>1 ARouter的自动注册，是通过初始化时加载这些路由清单完成的。<br>2 我们可以通过两种方式找到PROVIDER的节点。<br>3 页面自动赋值功能，在页面被打开时，调用了ISyringe接口的inject方法</p>
<h5 id="ARouter初始化过程-Init"><a href="#ARouter初始化过程-Init" class="headerlink" title="ARouter初始化过程 Init"></a>ARouter初始化过程 Init</h5><p><img src="http://oqjv79a9c.bkt.clouddn.com/pic%204.png" alt=""><br>在LogisticsCenter.init()完成了初始化，可以看到初始化时对红框内的路由表加载并缓存在wareHouse里，wareHouse类如下：<br><img src="http://oqjv79a9c.bkt.clouddn.com/pic%205.png" alt=""><br>在wareHouse里，不仅帮我们保存了路由清单，还给我们提供了缓存。也就是说同一个目标（RouteMeta、IProvider、IInterceptor）仅会在第一次使用的时候创建一次。</p>
<h5 id="API调用过程"><a href="#API调用过程" class="headerlink" title="API调用过程"></a>API调用过程</h5><p>举例：ARouter.getInstance().build(“/test/activity”).navigation()</p>
<p>走到_ARouter.getInstance().navigation()方法，核心调用：<br>1）    找到并填充PostCard：<br>LogisticsCenter.completion(postCard) 分组按需找到path对应的Postcard并填充携带信息，对于Provider类型则懒加载其对象，并缓存。<br>2）核心跳转：<br>跳转逻辑真正在_navigation()，支持三种：<br>1 Activity跳转，调用原生intent跳转<br>2 Provider调用，返回Service实例<br>3 Fragment，返回新建的Fragment实例</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/泛型<T>/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/泛型<T>/" itemprop="url">java类型及泛型的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/06/perf-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/06/perf-memory/" itemprop="url">内存问题的解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-06T00:00:00+08:00">
                2017-06-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="内存可以引发的问题"><a href="#内存可以引发的问题" class="headerlink" title="内存可以引发的问题"></a>内存可以引发的问题</h4><ol>
<li>程序卡顿，响应速度慢（JVM频繁调用GC，造成主线程卡顿）</li>
<li>崩溃率上升（OOM问题，此类问题各场景都可能出现，难于定位和复现）</li>
<li>后台被kill概率升高</li>
<li>图片加载失败（图片多的场景， oom往往被loader catch）</li>
</ol>
<h5 id="通过如下的5R方法来对ANDROID内存进行优化："><a href="#通过如下的5R方法来对ANDROID内存进行优化：" class="headerlink" title="通过如下的5R方法来对ANDROID内存进行优化："></a>通过如下的5R方法来对ANDROID内存进行优化：</h5><p>1.Reckon（计算）<br>首先需要知道你的app所消耗内存的情况，<br>2.Reduce（减少）<br>消耗更少的资源<br>3.Reuse（重用）<br>Cache的使用<br>4.Recycle（回收）<br>资源利用后的释放，回收；防止内存泄露<br>5.Review（检查）<br>回顾检查你的程序，看看设计或代码有什么不合理的地方。</p>
<h5 id="Reckon-（计算）"><a href="#Reckon-（计算）" class="headerlink" title="Reckon （计算）"></a>Reckon （计算）</h5><h6 id="内存的监控：我们监控的内存究竟是分配的哪部分？"><a href="#内存的监控：我们监控的内存究竟是分配的哪部分？" class="headerlink" title="内存的监控：我们监控的内存究竟是分配的哪部分？"></a>内存的监控：我们监控的内存究竟是分配的哪部分？</h6><p>一般Java在内存分配时会涉及到以下区域：<br>寄存器（Registers）：速度最快的存储场所，因为寄存器位于处理器内部，我们在程序中无法控制<br>栈（Stack）：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中；栈的大小和个数是受限制的。方法的调用顺序按照先进后出的顺序存入栈中，程序的运行由栈维护<br>堆（Heap）：堆内存用来存放由new创建的对象和数组。在堆中分配的内存，由Java虚拟机的自动垃圾回收器（GC）来管理。<br>静态域（static field）： Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量<br>常量池（constant pool）：虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和floating point常量）和对其他类型，字段和方法的符号引用。</p>
<p>Java数据类型的分类如图：<br><img src="http://images.cnitblog.com/blog/488573/201309/15165530-8a570626bf3741a1b4937759a89a5a93.png" width="660" height="300"><br>图一<br><strong>内存的监控就是对堆内存的监控，不仅因为其大小最大，还考虑到GC的回收情况影响整体内存的大小</strong></p>
<h6 id="监控方法："><a href="#监控方法：" class="headerlink" title="监控方法："></a>监控方法：</h6><p>Android Studio之前，通过adb shell dumpsys meminfo com.szzc.ucar.pilot 打印app内存信息<br><img src="http://oqjv79a9c.bkt.clouddn.com/1.png" width="460" height="300"><br>图二<br>通过不断的打印，监控内存的走势。<br>或者Android Device Monitor中的Update Heap，也是监控allocated和free的内存，但是缺点都是无法实时监控，可视化不够。</p>
<p>现有的监控：<br>1 性能监控系统<br>app轮询，获得指定进程的内存值，并上传dreport，同时上传页面、点击事件等信息<br>dreport统计数据后通过内存曲线展示，该监控方式做到可视化和结果固化，方便分析不同场景下的内存表现趋势，可以多版本比较，用于日常和线上监控。<br>2 Android Monitor监控<br><img src="http://oqjv79a9c.bkt.clouddn.com/2.png" width="460" height="300"><br>图三<br>图中free和allocated 内存大小，一一对应于图二meminfo的红框内的内存信息。只是更加直观<br>这种监控方式，一般是在开发过程中，或oom复现debug 等一些有目的性的内存监控，用来观察，比如：<br>1）实时查看App的内存分配情况、走势情况<br>2）发现大内存对象分配的场景<br>3）快速判断App是否由GC造成卡顿<br>4）发现内存不断增长的场景 初步判断泄漏</p>
<h5 id="Reduce（减少）"><a href="#Reduce（减少）" class="headerlink" title="Reduce（减少）"></a>Reduce（减少）</h5><h6 id="知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？"><a href="#知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？" class="headerlink" title="知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？"></a>知道了如何监控内存的大小，那么该如何判定app的内存水平处于合理位置？</h6><p>先看几个概念<br><code>Runtime rt=Runtime.getRuntime();
        long maxMemory=rt.maxMemory();</code><br>maxMemory指系统能分配给app的最大内存，不同系统不一样，且与<code>android:largeHeap=&quot;true&quot;</code>有关，代表app能使用的最大内存；<br>而app启动后需要多少，申请多少（totalMemory），所以totalMemory一直在增长或波动，但totalMemory &lt; maxMemory<br>totalMemory包含哪些呢？看到图二中最后一行，TOTAL就表示totalMemory, 其中包含 Native Heap以及  Dalvik Heap<br>关系如下：<br><code>Max &gt; Total = (Native free + allocated) + (Dalvik free + allocated)</code><br>（其中free代表申请的totalMemory中未被分配的内存，申请时的预留和GC回收导致的剩余都是free的来源）<br>如果图二的手机max = 128M，当 Total 临界 Max 时，再次申请heap内存时，OOM发生了。</p>
<p>从上述公式可以看出，评判allocated内存的合理范围，不仅要考虑maxMemory的大小，还要给native heap留出余量。<br>根据经验来讲，如果dalvik层的内存超过maxMemory的2/3时，OOM的概率就很高了。而在启动后和使用中，dalvik层的内存处于maxMemory的1/3左右较为合理。</p>
<h6 id="如何分析大内存？"><a href="#如何分析大内存？" class="headerlink" title="如何分析大内存？"></a>如何分析大内存？</h6><p>有了判断的标准，我们需要在app启动、使用过程中各场景，监控内存的大小。如果发现内存过大，直接通过内存快照分析。<br>Studio –&gt; Android Monitor –&gt; Dump Java Heap可以直接导出prof文件（导出前主动GC），通过hprof-conv转换，在MAT中分析<br>MAT有很多的分析工具，我总结了我认为的较为实用几个<br><img src="http://oqjv79a9c.bkt.clouddn.com/MAT%20Histogram.png" width="460" height="300"><br>在Overview页面，可以直观看到app的内存占用值和比例；</p>
<p>在Histograme页面直接按照Retained Heap排序，从最大开始逐个分析</p>
<p>也可以通过Dominator Tree看到不同class的内存占用比例，按照优先级分析，例如最高Bitmap；<br>接下来在Histograme柱状图列表中，搜索Bitmap，结果为class列表，右键list objects –&gt; with incomming references,可以看到相关类的对象列表，通过Path To GCRoot 查找到bitmap究竟是什么对象，存在是否合理。<br><img src="http://oqjv79a9c.bkt.clouddn.com/MAT%20GcRoot.png" width="400" height="300"><br>不合理的Bitmap有以下特征：<br>1）上个页面的大背景图<br>2）bitmap大小明显大于其容器的大小<br>3）浮窗、蒙版、背景等代码可以实现的效果</p>
<p>对于这三种情况，<br>1）是否有页面泄漏，imageView.setImageDrawable(null)<br>2) imageLoader 或其他加载器，要传入view容器宽高，以便bitmap裁剪<br>3）BackgroundColor 自定义View  9patch 等方式实现，避免整张bitmap图</p>
<p>以上只是拿Bitmap举了例子，除了bitmap之外，内存快照里还会有其他内存大户，需要用类似的方法进行分析。</p>
<h5 id="Reuse（重用）"><a href="#Reuse（重用）" class="headerlink" title="Reuse（重用）"></a>Reuse（重用）</h5><p>如果一些内存大户必须存在，那考虑是否可以缓存或重用<br>1 Bitmap重用 使用第三方库加载bitmap，第三方库一般采用二级或三级缓存，可以对不再使用的bitmap及时释放，重用已有的内存<br>2 使用AdapterView、viewHolder复用<br>3 一些全局使用的大数据，如果可以全局公用，不采用每次获取。</p>
<h5 id="Recycle（回收）"><a href="#Recycle（回收）" class="headerlink" title="Recycle（回收）"></a>Recycle（回收）</h5><p>除了必须的内存足够小之外，不需要的内存及时释放也非常重要，<br>JVM的heap回收依赖GC，app无法控制GC的时机和频率，能做的就是保证在系统GC时自身不再使用的内存，可以顺利被释放。<br>无法被释放，就是内存泄漏，查找泄漏目前最有效的方法是MAT，如何使用在reduce一节有描述。这里重点说说泄漏的分析：</p>
<h6 id="什么时候分析泄漏？"><a href="#什么时候分析泄漏？" class="headerlink" title="什么时候分析泄漏？"></a>什么时候分析泄漏？</h6><p>1）对疑似泄漏的地方反复操作  2）内存曲线持续异常上涨 3）重度使用app后 4）Monkey测试 自动化测试之后<br>这些方式可以发现最基本、最明显的内存泄漏，对用户价值极大，性价比高。</p>
<h6 id="拿到内存快照后如何分析泄漏？"><a href="#拿到内存快照后如何分析泄漏？" class="headerlink" title="拿到内存快照后如何分析泄漏？"></a>拿到内存快照后如何分析泄漏？</h6><p>MAT对于泄漏分析的支持还是全面的，功能复杂而繁多，以我的经验来说，一般从几方面检查泄漏：<br>1）基于class<br>MAT支持sql查询，app的泄漏大多发生在Activity上<br><code>select * from instanceof android.app.Activity</code><br><img src="http://oqjv79a9c.bkt.clouddn.com/activity%20leak.png" width="560" height="300"><br>SplashActivity是上一个页面，但是还存在于内存中，说明泄漏了。然后根据Path To GCRoot –&gt; exclude weak/soft references 找到泄漏原因 — 引用持有链<br><code>select * from instanceof com.ucar.base.fragment.BaseFragment</code>可以找到Fragment的泄漏<br>这种查法基于以前的经验，效率高，但覆盖程度不够。<br>2）基于内存块<br>MAT中Leak suspects具有一定参考性，但通过Dominator Tree 对内存占用排序后，更有针对性的进行泄漏排查。<br><img src="http://oqjv79a9c.bkt.clouddn.com/dominator%20tree.png" width="660" height="350"><br>3）基于prof对比<br>需要两个Dump结果作对比，打开 Navigator History面板，将两个表的 Histogram结果都添加到 Compare Basket中去<br>步骤如下：<br>a.打开第一个hprof，打开histogram view<br>b.在NavigationHistory view里 (如果看不到就从Window &gt;show view&gt;MAT- Navigation History ), 右击histogram然后选择Add to Compare Basket<br>c.打开第二个prof，重复步骤b 点击右上角红色‘！’<br>快速定位内存增量，那么泄漏的部分显而易见。</p>
<p><em>对于内存泄漏问题，亡羊补牢当然犹未为晚，但是防微杜渐更为可取。优秀的代码实践，会大大降低内存泄漏的概率。在设计、开发过程中，始终关注app的性能表现，是一名合格app工程师的基本素质。</em></p>
<p>几条大的原则：</p>
<ol>
<li>保存对象前要三思（static）<br>I. 对象本身有无隐含的引用<br>II. 保存后何时能够回收</li>
<li>要了解常见的隐含引用<br>I. anonymous class outer class<br>II. View to context</li>
<li>创建大对象时，要检查它的生命周期</li>
</ol>
<p>Android常见的内存泄漏汇总</p>
<ol>
<li>单例造成的泄漏<br>单例模式广受程序员喜爱，是最早接触的设计模式之一。单例的生命周期与app相同，要慎用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class AppManager &#123;</div><div class="line">    private static AppManager instance;</div><div class="line">    private Context context;</div><div class="line">    private AppManager(Context context) &#123;</div><div class="line">        this.context = context;</div><div class="line">    &#125;</div><div class="line">    public static AppManager getInstance(Context context) &#123;</div><div class="line">        if (instance != null) &#123;</div><div class="line">            instance = new AppManager(context);</div><div class="line">        &#125;</div><div class="line">        return instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果传入Context instanceof Activity, 那么在Activity被destroy之后，仍然被AppManager所持有，无法释放。如果传入context instanceof Application则没问题。<br>哪些情况可以直接使用Application Context<br><img src="http://img.blog.csdn.net/20151123144226349" width="760" height="350"><br>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">com.ucar.basecommon.pay.recharge.ui.RechargeActivity @ 0x4543ae98 | 408 | 3,872</div><div class="line">|- this$0 com.ucar.basecommon.pay.recharge.ui.RechargeActivity$5 @ 0x4313c498 | 16 | 16</div><div class="line">| &apos;- stateChangedListener com.ucar.basecommon.pay.utils.KeyboardUtil @ 0x44fad8c8 | 32 | 280</div><div class="line">| &apos;- keyboardUtil class com.ucar.basecommon.pay.utils.KeyboardUtil @ 0x43b442c0 System Class| 8 | 328</div></pre></td></tr></table></figure></p>
<ol>
<li>Android组件或特殊集合对象的使用<br>BraodcastReceiver，ContentObserver，FileObserver，Cursor，Callback，都是系统的回调，在Activity onDestroy 或者某类生命周期结束之后一定要 unregister 或者 close 掉，否则Activity会一直被system强引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">com.szzc.ucar.rollorder.activity.DispatchActivity @ 0x4545bcf0 | 344 | 4,688</div><div class="line">&apos;- val$listener com.ucar.base.mapic.amap.AMapWrapper$1 @ 0x453a71c8 | 16 | 16</div><div class="line">&apos;- aa com.amap.api.mapcore.AMapDelegateImp @ 0x449ab330 | 432 | 23,616</div><div class="line">&apos;- a com.amap.api.mapcore.AMapDelegateImp$TimeChangedReceiver @ 0x4537e510 | 24 | 24</div><div class="line">&apos;- [16] java.lang.Object[24] @ 0x45394208 | 112 | 112</div><div class="line">&apos;- mArray android.util.ArrayMap @ 0x432cbc70 | 24 | 200</div><div class="line">&apos;- [1] java.lang.Object[8] @ 0x432cbcb8 | 48 | 352</div><div class="line">&apos;- mArray android.util.ArrayMap @ 0x42d95ab8 | 24 | 408</div><div class="line">&apos;- mReceivers android.app.LoadedApk @ 0x42d95a40 | 88 | 2,296</div></pre></td></tr></table></figure>
<p>地图的初始化会注册系统一个TimeChangedReceiver，地图的api规范里说明在页面销毁时调用map.onDestroy,此处会解注册系统回调。如果不调用，会造成内存泄漏。</p>
<ol>
<li><p>Handler Thread 使用不当<br>Handler 发送的 Message 尚未被处理，当线程的 run 函数耗时较长没有结束时，Handler和Thread都不会被销毁；二者都是异步调用，生命周期与Activity并不同步，同时匿名内部的Handler Thread类会持有外部Activity的对象，导致泄漏。<br>解决的办法就是使用静态内部类，并在Activity销毁时移除内部回调。<br>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private MyHandler mHandler = new MyHandler(this);</div><div class="line">    private TextView mTextView ;</div><div class="line">    private static class MyHandler extends Handler &#123;</div><div class="line">        private WeakReference&lt;Context&gt; reference;</div><div class="line">        public MyHandler(Context context) &#123;</div><div class="line">            reference = new WeakReference&lt;&gt;(context);</div><div class="line">        &#125;</div><div class="line">        @Override</div><div class="line">        public void handleMessage(Message msg) &#123;</div><div class="line">            MainActivity activity = (MainActivity) reference.get();</div><div class="line">            if(activity != null)&#123;</div><div class="line">                activity.mTextView.setText(&quot;&quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void onDestroy() &#123;</div><div class="line">        super.onDestroy();</div><div class="line">        mHandler.removeCallbacksAndMessages(null);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>静态变量的不当使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private static TestResource mResource = null;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        if(mManager == null)&#123;</div><div class="line">            mManager = new TestResource();</div><div class="line">        &#125;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">    class TestResource &#123;</div><div class="line">        //...</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>静态mResource被MainActivity类本身引用，但mResource由于是内部类，内部含有MainActivity.this，发生泄漏<br>静态变量的使用要比单例更为慎重，如果要使用也要注意主动释放。<br>5.集合类<br>集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">com.szzc.tcar.book.fragment.TCarPickFragment @ 0x4703ce28 | 296 | 57,032</div><div class="line">&apos;- [16] java.lang.Object[27] @ 0x466775b0 | 120 | 1,004,992</div><div class="line">&apos;- array java.util.ArrayList @ 0x444dbd00 | 24 | 1,005,016</div><div class="line">&apos;- mFragmentList com.ucar.base.fragmentation.Fragmentation @ 0x444dbcc8 | 24 | 1,005,056</div><div class="line">&apos;- mFragmentation com.szzc.home.activity.MainActivity @ 0x444d9340 | 352 | 6,176</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/27/perf-overdraw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/27/perf-overdraw/" itemprop="url">过度绘制的解决</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-27T00:00:00+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h4 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h4><p>《Google的性能优化典范》一文是Android程序内存优化的指导，分别从渲染、电量、运算和内存几个方面阐述了优化方向。<br>本文关注渲染方向：</p>
<hr>
<p>渲染其实是指GPU渲染，是App计算–绘制–渲染 过程中的最后一步。CPU负责Measure Layout，Execute GPU负责Rasterization（栅格化）。<br>CPU通常存在的问题是 非必需的视图组件、视图层级；GPU的问题是过度绘制。</p>
<p>Overdraw 过度绘制：<br>定义：屏幕上的某个像素在同一帧的时间内被绘制了多次<br>例如UI是层叠的，看不见的UI也做绘制操作，就是多余的。当设计效果上更加华丽炫酷时，堆叠视图层级是常见的情况，但这很容易产生性能问题。</p>
<p>怎么过度绘制打开开关和如何看，不介绍了就。</p>
<hr>
<h4 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h4><p>1.写合理而高效的布局<br>Android的布局可以通过xml来实现，这使得开发者布局时较为随意，只以实现功能为目的，忽略性能问题的累积效应。<br>在开发设计之初，就应该考虑布局的效率问题，以免出现后期修改的高成本。<br>降低Layout层级，有很多方法 不列举了。</p>
<p>2.移除非必须的background: Activity的DecorView有默认的背景色，可以改为透明<br><code>getWindow().getDecorView().setBackgroundColor(getResources().getColor(R.color.transparent));</code><br>这个颜色从ActivityTheme设置，被decorView所持有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;style name=&quot;Theme&quot;&gt;</div><div class="line">    ...</div><div class="line">    &lt;!-- Window attributes --&gt;</div><div class="line">    &lt;item name=&quot;windowBackground&quot;&gt;@drawable/screen_background_selector_dark&lt;/item&gt;</div><div class="line">    ...</div><div class="line">&lt;/style&gt;</div></pre></td></tr></table></figure></p>
<p>screen_background_selector_dark在sdk中定义为纯黑色<br>所以也可以<code>android:windowbackground=&quot;null&quot;</code>方法来修改</p>
<p>后续会在Theme自定义，或BaseActivity 统一优化</p>
<p>3.View BackGround 优化：<br>1) 所有的View都可以设置Background，ImageView除了可以设置BackGround外，还可以设置imageResource<br>在使用ImageView时，尤其是ListView ViewHolder中，可能imageView设置默认bitmap给background，然后<br>真正的bitmap给imageResource，导致了重复绘制。解决方法是都通过imageResource设置<br>2) 有时采用selector背景，可以normal状态设置为transparent</p>
<p>4.移除不必要的背景色<br>比如Activity中含Fragment,如果Fragment有背景色而且是全屏的，Activity就不必要。<br>又比如ViewPager中含fragment ViewPager的背景色是不必要的</p>
<p>5.ClipRect<br>在ViewGroup的drawChild方法中，<br><code>protected boolean drawChild(Canvas canvas, View child, long drawingTime)</code><br>在ViewGroup的Canvas上绘制子child，不同的child都在同一个canvas绘制，如果view相互遮盖，则重复绘制难免。<br>Canvas的clipRect方法，提供了限定绘制区域的功能，在某个child 绘制时，可以限定绘制区域为自己的显示区域，解决了这个问题。<br>v4包中的DrawerLayout，就专门做了ClipRect优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">    protected boolean drawChild(Canvas canvas, View child, long drawingTime) &#123;</div><div class="line">        final int height = getHeight();</div><div class="line">        final boolean drawingContent = isContentView(child);//是否mainContent</div><div class="line">        int clipLeft = 0, clipRight = getWidth();</div><div class="line"></div><div class="line">		//如果是绘制mainContent，则先canvas.save 再 canvas.restore</div><div class="line">        //并拿到drawerContent的right作为自己绘制的left，通过canvas.clipRect限定绘制区域</div><div class="line">        final int restoreCount = canvas.save();</div><div class="line">        if (drawingContent) &#123;</div><div class="line">            final int childCount = getChildCount();</div><div class="line">            //此for循环找到drawerCotnent，</div><div class="line">            for (int i = 0; i &lt; childCount; i++) &#123;</div><div class="line">                final View v = getChildAt(i);</div><div class="line">                //注意此处对于drawerContent的筛选条件：</div><div class="line">                //visible，背景非透明!hasOpaqueBackground(v)</div><div class="line">                //如果drawerContent无背景色，此优化直接continue,因为mainContent要全显示</div><div class="line">                if (v == child || v.getVisibility() != VISIBLE ||</div><div class="line">                        !hasOpaqueBackground(v) || !isDrawerView(v) ||</div><div class="line">                        v.getHeight() &lt; height) &#123;</div><div class="line">                    continue;</div><div class="line">                &#125;</div><div class="line">                if (checkDrawerViewAbsoluteGravity(v, Gravity.LEFT)) &#123;</div><div class="line">                    final int vright = v.getRight();</div><div class="line">                    if (vright &gt; clipLeft) clipLeft = vright;</div><div class="line">                &#125; else &#123;</div><div class="line">                    final int vleft = v.getLeft();</div><div class="line">                    if (vleft &lt; clipRight) clipRight = vleft;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            canvas.clipRect(clipLeft, 0, clipRight, getHeight());</div><div class="line">        &#125;</div><div class="line">        final boolean result = super.drawChild(canvas, child, drawingTime);</div><div class="line">        canvas.restoreToCount(restoreCount);</div></pre></td></tr></table></figure></p>
<p>pilot端的问题就在于DrawerContent没有背景，而是把背景设置在了里面的Fragment，导致DrawerLayout优化没有生效<br>此优化一般用于自定义view中，而且控件交互存在View之间重叠的情况</p>
<p>Android中每个Window对应一个Canvas，window下所有view绘制公用一个canvas，viewtree的父节点在调用child.draw之前都会根据child的layout边界对canvas进行裁剪，这也是为什么超过view边界的内容不会被显示的原因。<br>但是对于各child大部分重叠的控件，会产生过度绘制，就需要clipRect优化。大部分容易重叠的控件FrameLayout RelativeLayout本身没有优化，需要开发者根据实际情况对自定义控件进行优化。</p>
<p>优化前：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-unmodified.png" width="160" height="300">优化后：<img src="http://oqjv79a9c.bkt.clouddn.com/0516-modified.png" width="160" height="300">滴滴：<img src="http://oqjv79a9c.bkt.clouddn.com/0518-didi.png" width="160" height="300"></p>
<p>6.善用9patch，背景图如果只显示边框，选用9patch，中间的透明会被2D渲染器优化overdraw</p>
<hr>
<p>过度绘制的原因无外乎：复杂的Layout层级、重叠的背景、重叠的View几种。开发人员在设计之初就要充分考虑过度绘制等性能敏感地带，要知道等到功能实现之后再去改Layout层级，onDraw方法等，成本和风险都会指数型提高。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/26/essay/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/26/essay/" itemprop="url">随笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-26T00:00:00+08:00">
                2017-05-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="Android-getResources-getColor-Deprecated"><a href="#Android-getResources-getColor-Deprecated" class="headerlink" title="Android getResources().getColor() Deprecated"></a>Android getResources().getColor() Deprecated</h5><p>getColor方法在Android 6.0即API 23中 已经过时，替代方法为：</p>
<p>ContextCompat.getColor(context, R.color.black)<br>ContextCompat 在v4包。</p>
<hr>
<h5 id="Gradle-配置异常"><a href="#Gradle-配置异常" class="headerlink" title="Gradle 配置异常"></a>Gradle 配置异常</h5><ol>
<li>You have not accepted the license agreements of the following SDK components: [Android SDK Build-Tools 24.0.2]</li>
</ol>
<p>从Android Gradle plugin 2.2.0开始，gradle会自动加载需要的SDK, build-tools，但是因为没有接受license，导致加载依赖终止<br>例如依赖了google gms服务的依赖，gradle会下载sdk对应的包，此时会报这个错误。<br>问题解决：</p>
<p>license存放在$ANDROID_HOME/licenses下（ANDROID_HOME 就是sdk的位置）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir &quot;$ANDROID_HOME/licenses&quot;</div><div class="line">echo -e &quot;\n8933bad161af4178b1185d1a37fbf41ea5269c55&quot; &gt; &quot;$ANDROID_HOME/licenses/android-sdk-license&quot;</div></pre></td></tr></table></figure></p>
<p> getSupportFragmentManager().getFragments() 抛出空指针异常</p>
<h2 id="http-blog-csdn-net-lintcgirl-article-details-50681373"><a href="#http-blog-csdn-net-lintcgirl-article-details-50681373" class="headerlink" title=" http://blog.csdn.net/lintcgirl/article/details/50681373"></a> <a href="http://blog.csdn.net/lintcgirl/article/details/50681373" target="_blank" rel="external">http://blog.csdn.net/lintcgirl/article/details/50681373</a></h2><p>删除chrome指定密码记录<br>chrome://settings/passwords</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/16/clean code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/16/clean code/" itemprop="url">聊聊clean code</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-16T00:00:00+08:00">
                2017-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="聊聊clean-code"><a href="#聊聊clean-code" class="headerlink" title="聊聊clean code"></a>聊聊clean code</h1><hr>
<p>clean code，顾名思义就是整洁的代码，或者说清晰、漂亮的代码，相信大多数工程师都希望自己能写出这样的代码。</p>
<p>也许这是个千人千面的话题，每个工程师都有自己的理解。比如我，从一个天天被骂代码写得烂的人，逐渐学习成长，到现在也能写的出“人模人样”的代码来了。这期间算是积累了一点经验心得，想和大家分享，抛砖引玉。</p>
<p>本文主要针对面向对象编程的clean code来阐述，面向过程代码的思路会比较不同，不在本文的讨论范畴。</p>
<h2 id="代码整洁的大前提"><a href="#代码整洁的大前提" class="headerlink" title="代码整洁的大前提"></a>代码整洁的大前提</h2><h3 id="代码大部分时候是用来维护的，而不是用来实现功能的"><a href="#代码大部分时候是用来维护的，而不是用来实现功能的" class="headerlink" title="代码大部分时候是用来维护的，而不是用来实现功能的"></a>代码大部分时候是用来维护的，而不是用来实现功能的</h3><p>这个原则适用于大部分的工程。我们的代码，一方面是编译好让机器执行，完成功能需求；另一方面，是写给身边的队友和自己看的，需要长期维护，而且大部分项目都不是朝生夕死的短命鬼。</p>
<p>大部分情况下，如果不能写出清晰好看的代码，可能自己一时爽快，后续维护付出的代价和成本将远高于你的想象。</p>
<p>对清晰好看代码的追求精神，比所有的技巧都要重要。</p>
<h3 id="优秀的代码大部分是可以自描述的，好于文档和注释"><a href="#优秀的代码大部分是可以自描述的，好于文档和注释" class="headerlink" title="优秀的代码大部分是可以自描述的，好于文档和注释"></a>优秀的代码大部分是可以自描述的，好于文档和注释</h3><p>当你翻看很多开源代码时，会发现注释甚至比我们自己写的项目都少，但是却能看的很舒服。当读完源码时，很多功能设计就都清晰明了了。通过仔细斟酌的方法命名、清晰的流程控制，代码本身就可以拿出来当作文档使用，而且它永远不会过期。</p>
<p>相反，注释不能让写的烂的代码变的更好。如果别人只能依靠注释读懂你的代码的时候，你一定要反思代码出现了什么问题（当然，这里不是说大家不要写注释了）。</p>
<p>说下比较适合写注释的两种场景：</p>
<ol>
<li>public interface，向别人明确发布你功能的语义，输入输出，且不需要关注实现。</li>
<li>功能容易有歧义的点，或者涉及比较深层专业知识的时候。比如，如果你写一个客户端，各种config参数的含义等。</li>
</ol>
<h3 id="设计模式只是手段，代码清晰才是目的"><a href="#设计模式只是手段，代码清晰才是目的" class="headerlink" title="设计模式只是手段，代码清晰才是目的"></a>设计模式只是手段，代码清晰才是目的</h3><p>之前见过一些所谓“高手”的代码都比较抽象，各种工厂、各种继承。想找到一个实现总是要山路十八弯，一个工程里大部分的类是抽象类或者接口，找不到一两句实现的代码，整个读起代码来很不顺畅。我跟他聊起来的时候，他的主要立场是：保留合适的扩展点，克服掉所有的硬编码。</p>
<p>其实在我看来，也许他的代码被“过度设计”了。首先必须要承认的是，在同一个公司工作的同事，水平是参差不齐的。无论你用了如何高大上的设计，如果大多数人都不能理解你的代码或者读起来很费劲的话，其实这是一个失败的设计。</p>
<p>当你的系统内大部分抽象只有一个实现的时候，要好好思考一下，是不是设计有点过度了，清晰永远是第一准则。</p>
<h2 id="代码整洁的常见手段"><a href="#代码整洁的常见手段" class="headerlink" title="代码整洁的常见手段"></a>代码整洁的常见手段</h2><p>记住原则后，我们开始进入实践环节，先来看下有哪些促成clean code的常见手段。</p>
<h3 id="code-review"><a href="#code-review" class="headerlink" title="code review"></a>code review</h3><p>很多大公司会用git的pull request机制来做code review。我们重点应该review什么？是代码的格式、业务逻辑还是代码风格？我想说的是，凡是能通过机器检查出来的事情，无需通过人。比如换行、注释、方法长度、代码重复等。除了基本功能需求的逻辑合理没有bug外，我们更应该关注代码的设计与风格。比如，一段功能是不是应该属于一个类、是不是有很多相似的功能可以抽取出来复用、代码太过冗长难懂等等。</p>
<p>我个人非常推崇集体code review，因为很多时候，组里相对高级的工程师能够一眼发现代码存在较大设计缺陷，提出改进意见或者重构方式。我们可以在整个小组内形成一个好的文化传承和风格统一，并且很大程度上培养了大家对clean code的热情。</p>
<h3 id="勤于重构"><a href="#勤于重构" class="headerlink" title="勤于重构"></a>勤于重构</h3><p>好的代码，一般都不是一撮而就的。即使一开始设计的代码非常优秀，随着业务的快速迭代，也可能被改的面目全非。</p>
<p>为了避免重构带来的负面影响（delay需求或者带来bug），我们需要做好以下的功课：<br>① 掌握一些常见的“无痛”重构技巧，这在下文会有具体讲解。<br>② 小步快跑，不要企图一口吃成个胖子。改一点，测试一点，一方面减少代码merge的痛苦，另一方面减少上线的风险。<br>③ 建立自动化测试机制，要做到即使代码改坏了，也能保证系统最小核心功能的可用，并且保证自己修改的部分被测试覆盖到。<br>④ 熟练掌握IDE的自动重构功能。这些会很大程度上减少我们的体力劳动，避免犯错。</p>
<h3 id="静态检查"><a href="#静态检查" class="headerlink" title="静态检查"></a>静态检查</h3><p>现在市面上有很多代码静态检查的工具，也是发现bug和风格不好的比较容易的方式。可以与发布系统做集成，强制把主要问题修复掉才可以上线。目前美团点评技术团队内部的研发流程中已经普遍接入了Sonar质量管理平台。</p>
<h3 id="多读开源代码和身边优秀同学的代码"><a href="#多读开源代码和身边优秀同学的代码" class="headerlink" title="多读开源代码和身边优秀同学的代码"></a>多读开源代码和身边优秀同学的代码</h3><p>感谢开源社区，为我们提供了这么好的学习机会。无论是JDK的源码，还是经典的Netty、Spring、Jetty，还是一些小工具如Guava等，都是clean code的典范。多多学习，多多反思和总结，必有收益。</p>
<h3 id="代码整洁的常见技巧"><a href="#代码整洁的常见技巧" class="headerlink" title="代码整洁的常见技巧"></a>代码整洁的常见技巧</h3><p>前面的内容都属于热身，让大家有个整体宏观的认识。下面终于进入干货环节了，我会分几个角度讲解编写整洁代码的常见技巧和误区。</p>
<h3 id="通用技巧"><a href="#通用技巧" class="headerlink" title="通用技巧"></a>通用技巧</h3><h4 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h4><p>这是整洁代码的最重要也是最基本的原则了。简单来讲，大到一个module、一个package，小到一个class、一个method乃至一个属性，都应该承载一个明确的职责。要定义的东西，如果不能用一句话描述清楚职责，就把它拆掉。</p>
<p>我们平时写代码时，最容易犯的错误是：一个方法干了好几件事或者一个类承载了许多功能。</p>
<p>先来聊聊方法的问题。个人非常主张把方法拆细，这是复用的基础。如果方法干了两件事情，很有可能其中一个功能的其他业务有差别就不好重用了。另外语义也是不明确的。经常看到一个get()方法里面竟然修改了数据，这让使用你方法的人情何以堪？如果不点进去看看实现，可能就让程序陷入bug，让测试陷入麻烦。</p>
<p>再来聊聊类的问题。我们经常会看到“又臭又长”的service/biz层的代码，里面有几十个方法，干什么的都有：既有增删改查，又有业务逻辑的聚合。每次找到一个方法都费劲。不属于一个领域或者一个层次的功能，就不要放到一起。</p>
<p>我们team在code review中，最常被批评的问题，就是一个方法应该归属于哪个类。</p>
<h4 id="优先定义整体框架"><a href="#优先定义整体框架" class="headerlink" title="优先定义整体框架"></a>优先定义整体框架</h4><p>我写代码的时候，比较喜欢先去定义整体的框架，就是写很多空实现，来把整体的业务流程穿起来。良好的方法签名，用入参和出参来控制流程。这样能够避免陷入业务细节无法自拔。在脑海中先定义清楚流程的几个阶段，并为每个阶段找到合适的方法／类归属。</p>
<p>这样做的好处是，阅读你代码的人，无论读到什么深度，都可以清晰地了解每一层的职能，如果不care下一层的实现，完全可以跳过不看，并且方法的粒度也会恰到好处。</p>
<p>简而言之，我比较推崇写代码的时候“广度优先”而不是“深度优先”，这和我读代码的方式是一致的。当然，这件事情跟个人的思维习惯有一定的关系，可能对抽象思维能力要求会更高一些。如果开始写代码的时候这些不够清晰，起码要通过不断地重构，使代码达到这样的成色。</p>
<h4 id="清晰的命名"><a href="#清晰的命名" class="headerlink" title="清晰的命名"></a>清晰的命名</h4><p>老生常谈的话题，这里不展开讲了，但是必须要mark一下。有的时候，我思考一个方法命名的时间，比写一段代码的时间还长。原因还是那个逻辑：每当你写出一个类似于”temp”、”a”、”b”这样变量的时候，后面每一个维护代码的人，都需要用几倍的精力才能理顺。</p>
<p>并且这也是代码自描述最重要的基础。</p>
<h4 id="避免过长参数"><a href="#避免过长参数" class="headerlink" title="避免过长参数"></a>避免过长参数</h4><p>如果一个方法的参数长度超过4个，就需要警惕了。一方面，没有人能够记得清楚这些函数的语义；另一方面，代码的可读性会很差；最后，如果参数非常多，意味着一定有很多参数，在很多场景下，是没有用的，我们只能构造默认值的方式来传递。</p>
<p>解决这个问题的方法很简单，一般情况下我们会构造paramObject。用一个struct或者一个class来承载数据，一般这种对象是value object，不可变对象。这样，能极大程度提高代码的可复用性和可读性。在必要的时候，提供合适的build方法，来简化上层代码的开发成本。</p>
<h4 id="避免过长方法和类"><a href="#避免过长方法和类" class="headerlink" title="避免过长方法和类"></a>避免过长方法和类</h4><p>一个类或者方法过长的时候，读者总是很崩溃的。简单地把方法、类和职责拆细，往往会有立竿见影的成效。以类为例，拆分的维度有很多，常见的是横向／纵向。例如，如果一个service，处理的是跟一个库表对象相关的所有逻辑，横向拆分就是根据业务，把建立／更新／修改／通知等逻辑拆到不同的类里去；而纵向拆分，指的是<br>把数据库操作/MQ操作/Cache操作/对象校验等，拆到不同的对象里去，让主流程尽量简单可控，让同一个类，表达尽量同一个维度的东西。</p>
<h4 id="让相同长度的代码段表示相同粒度的逻辑"><a href="#让相同长度的代码段表示相同粒度的逻辑" class="headerlink" title="让相同长度的代码段表示相同粒度的逻辑"></a>让相同长度的代码段表示相同粒度的逻辑</h4><p>这里想表达的是，尽量多地去抽取private方法，让代码具有自描述的能力。举个简单的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public void doSomeThing(Map params1,Map params2)&#123;</div><div class="line">Do1 do1 = getDo1(params1);</div><div class="line">Do2 do2 = new Do2();</div><div class="line">do2.setA(params2.get(&quot;a&quot;));</div><div class="line">do2.setB(params2.get(&quot;b&quot;));</div><div class="line">do2.setC(params2.get(&quot;c&quot;));</div><div class="line">mergeDO(do1,do2);</div><div class="line">&#125;</div><div class="line">private void getDo1(Map params1);</div><div class="line">private void mergeDo(do1,do2)&#123;...&#125;;</div></pre></td></tr></table></figure></p>
<p>类似这种代码，在业务代码中随处可见。获取do1是一个方法，merge是一个方法，但获取do2的代码却在主流程里写了。这种代码，流程越长，读起来越累。很多人读代码的逻辑，是“广度优先”的。先读懂主流程，再去看细节。类似这种代码，如果能够把构造do2的代码，提取一个private 方法，就会舒服很多。</p>
<h3 id="面向对象设计技巧"><a href="#面向对象设计技巧" class="headerlink" title="面向对象设计技巧"></a>面向对象设计技巧</h3><h4 id="贫血与领域驱动"><a href="#贫血与领域驱动" class="headerlink" title="贫血与领域驱动"></a>贫血与领域驱动</h4><p>不得不承认，Spring已经成为企业级Java开发的事实标准。而大部分公司采用的三层/四层贫血模型，已经让我们的编码习惯，变成了面向DAO而不是面向对象。</p>
<p>缺少了必要的模型抽象和设计环节，使得代码冗长，复用程度比较差。每次撸代码的时候，从mapper撸起，好像已经成为不成文的规范。</p>
<p>好处是上手简单，学习成本低。但是每次都不能重用，然后面对两三千行的类看着眼花的时候，我的心是很痛的。关于领域驱动的设计模式，本文不会展开去讲。回归面向对象，还是跟大家share一些比较好的code技巧，能够在一个通用的框架下，尽量好的写出漂亮可重用的code。</p>
<p>个人认为，一个好的系统，一定离不开一套好的模型定义。梳理清楚系统中的核心模型，清楚的定义每个方法的类归属，无论对于代码的可读性、可交流性，还是和产品的沟通，都是有莫大好处的。</p>
<p>####为每个方法找到合适的类归属，数据和行为尽量要在一起<br>不得不承认，Spring已经成为企业级Java开发的事实标准。而大部分公司采用的三层/四层贫血模型，已经让我们的编码习惯，变成了面向DAO而不是面向对象。</p>
<p>缺少了必要的模型抽象和设计环节，使得代码冗长，复用程度比较差。每次撸代码的时候，从mapper撸起，好像已经成为不成文的规范。</p>
<p>好处是上手简单，学习成本低。但是每次都不能重用，然后面对两三千行的类看着眼花的时候，我的心是很痛的。关于领域驱动的设计模式，本文不会展开去讲。回归面向对象，还是跟大家share一些比较好的code技巧，能够在一个通用的框架下，尽量好的写出漂亮可重用的code。</p>
<p>个人认为，一个好的系统，一定离不开一套好的模型定义。梳理清楚系统中的核心模型，清楚的定义每个方法的类归属，无论对于代码的可读性、可交流性，还是和产品的沟通，都是有莫大好处的。</p>
<p>####为每个方法找到合适的类归属，数据和行为尽量要在一起<br>如果一个类的所有方法，都是在操作另一个类的对象。这时候就要仔细想一想类的设计是否合理了。理论上讲，面向对象的设计，主张数据和行为在一起。这样，对象之间的结构才是清晰的，也能减少很多不必要的参数传递。</p>
<p>不过这里面有一个要讨论的方法：service对象。如果操作一个对象数据的所有方法都建立在对象内部，可能使对象承载了很多并不属于它本身职能的方法。</p>
<p>例如，我定义一个类，叫做person，。这个类有很多行为，比如：吃饭、睡觉、上厕所、生孩子；也有很多字段，比如：姓名、年龄、性格。</p>
<p>很明显，字段从更大程度上来讲，是定义和描述我这个人的，但很多行为和我的字段并不相关。上厕所的时候是不会关心我是几岁的。如果把所有关于人的行为全部在person内部承载，这个类一定会膨胀的不行。</p>
<p>这时候就体现了service方法的价值，如果一个行为，无法明确属于哪个领域对象，牵强地融入领域对象里，会显得很不自然。这时候，无状态的service可以发挥出它的作用。但一定要把握好这个度，回归本质，我们要把属于每个模型的行为合理的去划定归属。</p>
<p>####警惕static<br>static方法，本质上来讲是面向过程的，无法清晰地反馈对象之间的关系。虽然有一些代码实例（自己实现单例或者Spring托管等）的无状态方法可以用static来表示，但这种抽象是浅层次的。说白了，如果我们所有调用static的地方，都写上import static，那么所有的功能就由类自己在承载了。</p>
<p>让我画一个类图？尴尬了……画不出来。</p>
<p>而单例的膨胀，很大程度上也是贫血模型带来的副作用。如果对象本身有血有肉，就不需要这么多无状态方法。</p>
<p>static真正适用的场景：工具方法，而不是业务方法。</p>
<p>####巧用method object<br>method object是大型重构的常用技巧。当一段逻辑特别复杂的代码，充斥着各种参数传递和是非因果判断的时候，我首先想到的重构手段是提取method object。所谓method object，是一个有数据有行为的对象。依赖的数据会成为这个对象的变量，所有的行为会成为这个对象的内部方法。利用成员变量代替参数传递，会让代码简洁清爽很多。并且，把一段过程式的代码转换成对象代码，为很多面向对象编程才可以使用的继承／封装／多态等提供了基础。</p>
<p>举个例子，上文引用的代码如果用method object表示大概会变成这样<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class DoMerger&#123;</div><div class="line">    map params1;</div><div class="line">    map params2;</div><div class="line">    Do1 do1;</div><div class="line">    Do2 do2;</div><div class="line">    public DoMerger(Map params1,Map params2)&#123;</div><div class="line">       this.params1 = params1;</div><div class="line">       this.params2 = parmas2;</div><div class="line">    &#125;</div><div class="line">    public void invoke()&#123;</div><div class="line">        do1 = getDo1();</div><div class="line">        do2 = getDo2();</div><div class="line">       mergeDO(do1,do2);</div><div class="line">    &#125;</div><div class="line">    private Do1 getDo1();</div><div class="line">     private Do2 getDo2();</div><div class="line">     private void mergeDo()&#123;</div><div class="line">        print(do1+do2);</div><div class="line">     &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>####面向接口编程<br>面向接口编程是很多年来大家形成的共识和最佳实践。最早的理论是便于实现的替换，但现在更显而易见的好处是避免public方法的膨胀。一个对外publish的接口，一定有明确的职责。要判断每一个public方法是否应该属于同一个interface，是很容易的。</p>
<p>整个代码基于接口去组织，会很自然地变得非常清晰易读。关注实现的人才去看实现，不是嘛？</p>
<p>####正确使用继承和组合<br>这也是个在业界被讨论过很久的问题，也有很多论调。最新的观点是组合的使用一般情况下比继承更为灵活，尤其是单继承的体系里，所以倾向于使用组合<br>，否则会让子类承载很多不属于自己的职能。</p>
<p>个人对此观点持保留意见，在我经历过的代码中，有一个小规律，我分析一下。</p>
<p>protected abstract 这种是最值得使用继承的，父类保留扩展点，子类扩展，没什么好说的。</p>
<p>protected final 这种方法，子类是只能使用不能修改实现的。一般有两种情况：<br>① 抽象出主流程不能被修改的，然而一般情况下，public final更适合这个职能。如果只是流程的一部分，需要思考这个流程的类归属，大部分变成public组合到其他类里是更合适的。<br>② 父类是抽象类无法直接对外提供服务，又不希望子类修改它的行为，这种大多数情况下属于工具方法，比较适合用另一个领域对象来承载并用组合的方式来使用。</p>
<p>protected 这种是有争议的，是父类有默认实现但子类可以扩展的。凡是有扩展可能的，使用继承更理想一些。否则，定义成final并考虑成组合。</p>
<p>综上所述，个人认为继承更多的是为扩展提供便利，为复用而存在的方法最好使用组合的方式。当然，更为大的原则是明确每个方法的领域划分。</p>
<p>###代码复用技巧</p>
<p>####模板方法<br>这是我用得最多的设计模式了。每当有两个行为类似但又不完全相同的代码段时，我总是会想到模板方法。提取公共流程和可复用的方法到父类，保留不同的地方作为abstract方法，由不同的子类去实现。</p>
<p>并在合适的时机，pull method up（复用）或者 pull method down（特殊逻辑）。</p>
<p>最后，把不属于流程的、但可复用的方法，判断是不是属于基类的领域职责，再使用继承或者组合的方法，为这些方法找到合适的安家之处。</p>
<p>####extract method<br>很多复用的级别没有这么大，也许只是几行相同的逻辑被copy了好几次，何不尝试提取方法（private）。又能明确方法行为，又能做到代码复用，何乐不为？</p>
<p>####责任链<br>经常看到这样的代码，一连串类似的行为，只是数据或者行为不一样。如一堆校验器，如果成功怎么样、失败怎么样；或者一堆对象构建器，各去构造一部分数据。碰到这种场景，我总是喜欢定义一个通用接口，入参是完整的要校验／构造的参数，<br>出参是成功/失败的标示或者是void。然后有很多实现器分别实现这个接口，再用一个集合把这堆行为串起来。最后，遍历这个集合，串行或者并行的执行每一部分的逻辑。</p>
<p>这样做的好处是：<br>① 很多通用的代码可以在责任链原子对象的基类里实现；<br>② 代码清晰，开闭原则，每当有新的行为产生的时候，只需要定义行的实现类并添加到集合里即可；<br>③ 为并行提供了基础。</p>
<p>####为集合显式定义它的行为<br>集合是个有意思的东西，本质上它是个容器，但由于泛型的存在，它变成了可以承载所有对象的容器。很多非集合的类，我们可以定义清楚他们的边界和行为划分，但是装进集合里，它们却都变成了一个样子。不停地有代码，各种循环集合，做一些相似的操作。</p>
<p>其实很多时候，可以把对集合的操作显示地封装起来，让它变得更有血有肉。</p>
<p>例如一个Map，它可能表示一个配制、一个缓存等等。如果所有的操作都是直接操作Map，那么它的行为就没有任何语义。第一，读起来就必须要深入细节；第二，如果想从获取配置读取缓存的地方加个通用的逻辑，例如打个log什么的，你可以想象是多么的崩溃。</p>
<p>个人提倡的做法是，对于有明确语义的集合的一些操作，尤其是全局的集合或者被经常使用的集合，做一些封装和抽象，如把Map封装成一个Cache类或者一个config类，再提供GetFromCache这样的方法。</p>
<p>###总结<br>本文从clean code的几个大前提出发，然后提出了实践clean code的一些手段，重点放在促成clean code的一些常用编码和重构技巧。<br>当然，这些只代表笔者本人的一点点感悟。好的代码，最最需要的，还是大家不断追求卓越的精神。欢迎大家一起探索交流这个领域，为clean code提供更多好的思路与方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">bo.wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bo.wang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
