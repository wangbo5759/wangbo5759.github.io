<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Android框架," />










<meta name="description" content="基于RxJava Retrofit网络框架的搭建RxJava、Retrofit两个第三方库的优势RxJava的使用场景本文讨论的如无特殊说明，均指代rxjava2 和 retrofit2。我们先讨论一下rxJava引入的背景。有一些应用场景，特别是一些复杂的异步回调场景，如果使用传统的开发模式，会如何实现。列举一些场景：

EditText： 根据输入内容自动搜索时，只有当输入间隔大于某个dura">
<meta property="og:type" content="article">
<meta property="og:title" content="基于RxJava Retrofit的网络框架（一）">
<meta property="og:url" content="http://yoursite.com/2018/10/12/ReactiveX/index.html">
<meta property="og:site_name" content="Muse--D.D">
<meta property="og:description" content="基于RxJava Retrofit网络框架的搭建RxJava、Retrofit两个第三方库的优势RxJava的使用场景本文讨论的如无特殊说明，均指代rxjava2 和 retrofit2。我们先讨论一下rxJava引入的背景。有一些应用场景，特别是一些复杂的异步回调场景，如果使用传统的开发模式，会如何实现。列举一些场景：

EditText： 根据输入内容自动搜索时，只有当输入间隔大于某个dura">
<meta property="og:updated_time" content="2018-10-25T14:10:15.578Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基于RxJava Retrofit的网络框架（一）">
<meta name="twitter:description" content="基于RxJava Retrofit网络框架的搭建RxJava、Retrofit两个第三方库的优势RxJava的使用场景本文讨论的如无特殊说明，均指代rxjava2 和 retrofit2。我们先讨论一下rxJava引入的背景。有一些应用场景，特别是一些复杂的异步回调场景，如果使用传统的开发模式，会如何实现。列举一些场景：

EditText： 根据输入内容自动搜索时，只有当输入间隔大于某个dura">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/12/ReactiveX/"/>





  <title>基于RxJava Retrofit的网络框架（一） | Muse--D.D</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Muse--D.D</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/12/ReactiveX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="bo.wang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Muse--D.D">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基于RxJava Retrofit的网络框架（一）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-12T00:00:00+08:00">
                2018-10-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="基于RxJava-Retrofit网络框架的搭建"><a href="#基于RxJava-Retrofit网络框架的搭建" class="headerlink" title="基于RxJava Retrofit网络框架的搭建"></a>基于RxJava Retrofit网络框架的搭建</h2><h3 id="RxJava、Retrofit两个第三方库的优势"><a href="#RxJava、Retrofit两个第三方库的优势" class="headerlink" title="RxJava、Retrofit两个第三方库的优势"></a>RxJava、Retrofit两个第三方库的优势</h3><h4 id="RxJava的使用场景"><a href="#RxJava的使用场景" class="headerlink" title="RxJava的使用场景"></a>RxJava的使用场景</h4><p>本文讨论的如无特殊说明，均指代rxjava2 和 retrofit2。<br>我们先讨论一下rxJava引入的背景。有一些应用场景，特别是一些复杂的异步回调场景，如果使用传统的开发模式，会如何实现。<br>列举一些场景：</p>
<ol>
<li>EditText： 根据输入内容自动搜索时，只有当输入间隔大于某个duration时，才触发搜索。<br>同时要根据输入内容，实时判断其有效性。<br>对输入的内容，实时做出改变（比如不能输入数字，特殊字符等）<br>（<a href="https://www.jianshu.com/p/9aaccd7bb600）" target="_blank" rel="external">https://www.jianshu.com/p/9aaccd7bb600）</a></li>
<li>联合判断<br><a href="https://www.jianshu.com/p/88ce90240396" target="_blank" rel="external">https://www.jianshu.com/p/88ce90240396</a></li>
<li>注册–登录–获取用户信息（注册的一般流程） 获取权限–获取经纬度–鉴权–生成订单（生成订单一般流程） 这样一连串的网络请求。</li>
<li>结合多个接口的数据，再更新UI；或者历史记录、购物车记录等，需要合并本地缓存和网络请求返回的数据;</li>
<li>网络请求前置条件token的获取，token可以本地缓存，本地缓存拿不到要去网络获取。同时对于token拿不到时的网络请求先等待，token获取后将等待的请求一一发出。甚至token请求需要设置重试次数，超过次数才停止请求</li>
<li>防重复操作，倒计时</li>
<li>多重缓存处理：先读取缓存更新UI，在网络请求更新UI（<a href="https://www.jianshu.com/p/7474950af2df）" target="_blank" rel="external">https://www.jianshu.com/p/7474950af2df）</a></li>
<li>多处场景需要同一个监听事件，但是每个场景注册时间点不同，如何做到事件产生之后注册的监听者也能收到回调。</li>
</ol>
<p>这些应用场景几乎是每个app都会遇到的，传统的处理方式：层层递进（回调），各种标志位控制，嵌套的if else，各种异步调用分散在代码各处，要将各个回调结果汇总，并且综合处理回调的不同状态。而且由于异步回调的特点，代码处理方式不会像同步调用那样直接可控，异步回调导致的时序问题又将问题复杂度提高了几个level。我经常会想，这种callback的异步调用方式，为何会将代码变得丑陋不堪和难以维护？设计模式中只提供了观察者模式，但是对于观察者回调复杂后，没有提出更好的解决方案。RxJava（或者说响应式编程）主要解决了这类的问题。<br>关于RxJava是如何解决以上场景中遇到的问题，以及如何和retrofit一起联合使用，短短几行无法说不清，在基于RxJava Retrofit的网络框架（二）中会详解。</p>
<h4 id="Retrofit的使用"><a href="#Retrofit的使用" class="headerlink" title="Retrofit的使用"></a>Retrofit的使用</h4><p>Retrofit并不实现网络请求本身（网络请求由okhttp负责），他是一个框架，为网络请求本身提供可扩展，可配置，易使用的外部封装。okhttp负责提高网络请求的性能和兼容性，Retrofit负责更好的使用他。框架的重要性不言而喻，好的框架让使用者关注更少细节，轻易的扩展。okhttp好像汽车的发动机，对于汽车性能和稳定性起到决定性作用，框架就是除了发动机以外其他部分，除了对发送机功能的整合外，漂亮的外观，舒适易用的体验才是人们愿意开这台车的原因。<br>以下列举Retrofit相对于volley Android-Async-Http等框架的优势</p>
<ol>
<li>简洁易用：通过注解配置网络参数，大量设计模式（建造者模式，工厂）简化配置和使用。</li>
<li>功能强大：支持RxJava方式（也支持callback方式），支持同步&amp;异步，</li>
<li>耦合度低，扩展性好：模块高度封装，彻底解耦。</li>
</ol>
<p>由于Android-Async-Http的停更，Google对volley基本放弃的态度，这两套框架使用者和价值日渐减少。反观okhttp，Google官方应用则广泛使用。作为okhttp的黄金搭档（同为square公司出品），Retrofit可以说是目前Android app网络请求框架的不二选择，与okhttp搭配，是性能、稳定性、兼容性、易用性都达到很高水平的框架组合。</p>
<h3 id="Observable网络框架的抽象"><a href="#Observable网络框架的抽象" class="headerlink" title="Observable网络框架的抽象"></a>Observable网络框架的抽象</h3><h4 id="Observable网络框架建立的原因"><a href="#Observable网络框架建立的原因" class="headerlink" title="Observable网络框架建立的原因"></a>Observable网络框架建立的原因</h4><ol>
<li>Retrofit已经对网络请求做了封装，为什么还要封装?<br>网络请求中对于请求流程、配置、加解密、异常处理对于每个app都是固定不变的，如果业务每次请求都自己处理逻辑，会存在冗余代码，且质量不易保证。所以我们需要基于Retrofit对请求流程、配置、加解密、异常处理等操作做二次封装，并对调用方式进行统一。</li>
<li>框架封装方式Observable是什么？<br>对网络请求二次封装（一般为异步请求），传统使用callback方式异步回调网络请求结果。但是这种callback的方式，没有利用到Retrofit的一大优势–rxjava调用，所以我们要基于rxjava调用方式，封装一个基于Observable的网络请求框架。<br>以下所说网络框架，均指基于Observable的网络请求二次封装框架。</li>
</ol>
<h4 id="Observable网络框架要解决的问题"><a href="#Observable网络框架要解决的问题" class="headerlink" title="Observable网络框架要解决的问题"></a>Observable网络框架要解决的问题</h4><p>网络框架要帮助业务处理以下几个问题：</p>
<ol>
<li>支持Get Post请求，对Request的参数业务可轻松配置</li>
<li>对Request 参数做发送前处理：组合和加密处理</li>
<li>返回Response 解密处理，Java实体化</li>
<li>返回Response code码判断及处理</li>
<li>网络请求cancle机制 progressBar配置等通用处理<br>达到的目标：业务使用框架时，只需要关注业务相关（Request参数，Response返回值的配置和处理），其他都交给框架处理。同时对于网络请求的属性可配置（error是否提示，progressBar是否显示等）</li>
</ol>
<h4 id="Observable网络框架如何实现"><a href="#Observable网络框架如何实现" class="headerlink" title="Observable网络框架如何实现"></a>Observable网络框架如何实现</h4><p>设计原则：</p>
<ol>
<li>网络请求Api返回Observable对象，作为网络请求事件的生产者：<br>生产者负责请求的发起，和返回的所有预处理。</li>
<li>为业务提供BaseObserver类，使用者实现其子类作为消费者<br>消费者基类提供对response的一般处理，消费者业务也可以使用自己Observer处理</li>
</ol>
<hr>
<p>在Observable的创建过程中，框架如何封装？</p>
<p>首先我们需要一个Manager或Helper全局实例，通过他可以发起网络请求，一般设计为单例全局持有，有利于网络请求一些资源的共用。<br>我们暂定为NetHelper,其网络请求接口定义为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request, final TypeReference&lt;R&gt; t）</div></pre></td></tr></table></figure></p>
<p>sendRequest方法中，我们来看下Observable对象的生成过程：此处我们基于Retrofit本身Observable生成方式，我们先看下Retrofit最基础是如何创建Observable的。</p>
<p>第一步，定义Request，Request类的定义在Retrofit里通过注解的方式完成的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public interface Request &#123;</div><div class="line"></div><div class="line">    @POST(&quot;&#123;url&#125;&quot;)</div><div class="line">    Observable&lt;JSONObject&gt; postJSONResult(@Path(value=&quot;url&quot;,encoded =true) String url, @FieldMap Map&lt;String, String&gt; params);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到我们的定义方式是通用的（每个request都可以复用），每个request都是通过postJSONResult方法获取observable，传入自己的url和params即可完成不同的网络请求。</p>
<p>第二步，创建retrofit<br>NetHelper.java中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 初始化okhttp</div><div class="line">OkHttpClient client = new OkHttpClient.Builder()</div><div class="line">        .build();</div><div class="line"></div><div class="line">// 初始化Retrofit</div><div class="line">retrofit = new Retrofit.Builder()</div><div class="line">        .client(client)</div><div class="line">        .baseUrl(Request.HOST)</div><div class="line">        .addCallAdapterFactory(RxJava2CallAdapterFactory.create())</div><div class="line">        .addConverterFactory(MyConverterFactory.create())</div><div class="line">        .build();</div></pre></td></tr></table></figure></p>
<p>OkHttpClient每次请求的时候都要创建，注意：OkHttpClient.Builder()中有ConnectionPool作为OkHttp的连接池要复用，否则请求过多时容易导致内存溢出。<br>创建Retrofit实例过程中，设置了okHttpClient，baseUrl，调用方式rxJava（通过addCallAdapterFactory）<br>GsonConverterFactory这些都是一般的写法，GsonConverterFactory作用是把Response通过GSon转为javaBean。App业务中一般是先解密后Gson转，所以此处使用MyConverterFactory实现解密功能。</p>
<p>第三步，生成Observable<br>这一步是生成observable的过程，与httpRequest本身有关（我们前面提到了Request类是一个支持Retrofit通用类，业务自定义的请求类HttpRequest实现了 getURLParam() getURLAction()等方法）,所以这个获取Observable的方法可以放到HttpRequest中进行（NetHelper.sendRequest方法是传入了HttpRequest对象的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Request request = retrofit.create(Request.class);</div><div class="line">return request.postJSONResult(getURLAction(),getURLParam());</div></pre></td></tr></table></figure></p>
<p>对于httpRequest中入参的组合和加密，实现在getURLParam()方法里。<br>备注：我们的网络post请求params是query形式的，如果是body表单，还需要另外的处理方式。</p>
<p>以上三步，已经初步将Observable返回。通过以上几步只是基于Retrofit自身的Observable创建方法做了一些封装。下面的处理是框架的重点和核心：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）&#123;</div><div class="line"></div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">                .compose(ResponseTransformer.handleResult())</div><div class="line">                .subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread());</div><div class="line"></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>注意：sendRequest方法一定要Observable所有的链式操作执行完后在返回。</p>
<hr>
<p>NetHelper.getApiObservable方法后，再加上网络请求的线程配置，这时候业务subscribe消费者，就可以直接得到解密后的JsonObject了。注意此时是string而不是Retrofit通常的JavaBean，这是因为我们要定义一个通用的Request类，将其接口返回值定义为了Observable<jsonobject>,所以我们还需要一步转换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.map(new Function&lt;JSONObject,R&gt;() &#123;</div><div class="line">    @Override</div><div class="line">    public R apply(JSONObject jsonObject) throws Exception &#123;</div><div class="line">        if (jsonObject != null)&#123;</div><div class="line">            R response = jsonObject.toJavaObject(con);</div><div class="line">            if (orgRequest != null) &#123;</div><div class="line">                HttpHelper.printHttpLog(orgRequest, jsonObject.toString());</div><div class="line">            &#125;</div><div class="line">            return response;</div><div class="line">        &#125; else &#123;</div><div class="line">            return null;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></jsonobject></p>
<p>response的异常处理，progressbar的显示等，也需要架构统一处理。我们引入了ResponseTransformer，你可以把他理解为map操作符，在交给消费者前对response结果做了处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public static &lt;T extends Serializable&gt; ObservableTransformer&lt;T, T&gt; handleResult() &#123;</div><div class="line">    return upstream -&gt; upstream</div><div class="line">            .onErrorResumeNext(new ErrorResumeFunction&lt;T&gt;())</div><div class="line">            .flatMap(new ResponseFunction&lt;T&gt;());</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ErrorResumeFunction&lt;T extends Serializable&gt; implements Function&lt;Throwable, ObservableSource&lt;? extends T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;? extends T&gt; apply(Throwable throwable) throws Exception &#123;</div><div class="line">        return Observable.error(CustomException.handleException(throwable));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">private static class ResponseFunction&lt;T extends Serializable&gt; implements Function&lt;T, ObservableSource&lt;T&gt;&gt; &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public ObservableSource&lt;T&gt; apply(T tResponse) throws Exception &#123;</div><div class="line">        int code = tResponse.getCode();</div><div class="line">        String message = tResponse.getMsg();</div><div class="line"></div><div class="line">        if (code == SUCCESS.value()) &#123;</div><div class="line">            return Observable.just(tResponse);</div><div class="line">        &#125; else &#123;</div><div class="line">            return Observable.error(new ApiException(code, message));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出对于事件流upstream，做了正常和异常的再分流，对于服务器错误（超时，404等）通过onErrorResumeFunction继续抛出Observable.error,<br>对于正常返回，根据response中code的定义，只有SUCCESS时才返回数据Observable.just(),其他情况（业务错误等）作为错误情况继续抛出。<br>你可能有两个疑问，一个是response中code的判定可以在observer中处理吗，另一个是服务器错误和业务错误为何都作为error抛出。</p>
<p>第一个问题：<br>code值的判定不可以在observer中处理，而必须在Observable一端处理。因为Observable形式的网络请求是作为数据流中的一环出现的，可能当前网络请求只是一连串异步调用（rxjava调用）的一环。<br>第二个问题：<br>response中code!=SUCCESS是业务错误的情况，必须向数据流中发出，让业务处理此异常。（那同时对于Response的定义也是，code!=SUCCESS必须是不需要业务处理的情况才行）<br>两种错误都抛出error（内部code不同），方便架构使用者在事件响应时，既能捕捉所有错误，又能区分错误的类型。</p>
<hr>
<p>哪些处理放到了BaseObserver中?</p>
<p>BaseObserver顾名思义，是架构使用者在rxjava流式调用最后一步所使用的观察者基类，他适合将网络请求的UI响应放入其中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public  abstract class   BaseObserver&lt;T &gt; implements Observer&lt;T&gt;&#123;</div><div class="line">  /**</div><div class="line">    * 请求成功</div><div class="line">    * @param t</div><div class="line">    */</div><div class="line">   public abstract void onSuccess(T t);</div><div class="line"></div><div class="line">   /**</div><div class="line">    * 请求失败</div><div class="line">    * @param</div><div class="line">    * @param object</div><div class="line">    */</div><div class="line">   public abstract void onFail(ApiException);</div><div class="line"></div><div class="line">   @Override</div><div class="line">    public void onSubscribe(Disposable d) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNext(T t) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">        onSuccess(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">      if (isShowProgress()) &#123;</div><div class="line">          showProgress(false);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      if (e instanceof ApiException)&#123;</div><div class="line">            ApiException apiException = (ApiException)e;</div><div class="line">            switch(apiException.getCode())&#123;</div><div class="line">              case:NOT_LOGIN</div><div class="line">                break;</div><div class="line">              case:TOKEN_ERROR</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求是否loading显示</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowProgress()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>BaseObserver中，我们可以看到处理了showProgress，ApiException做了处理。同时可以对progressBar是否显示做配置。可以满足一般的网络请求架构使用，当然也可以自行subscribe自己的Observer。</p>
<h4 id="Observable网络框架的解耦和复用"><a href="#Observable网络框架的解耦和复用" class="headerlink" title="Observable网络框架的解耦和复用"></a>Observable网络框架的解耦和复用</h4><h5 id="BaseObserver的解耦"><a href="#BaseObserver的解耦" class="headerlink" title="BaseObserver的解耦"></a>BaseObserver的解耦</h5><p>我们可以看到BaseObserver实际做了error的异常响应，loading控制，对外接口的定义等工作。实际上这几部分工作有一定的耦合，业务使用时无法定制（使用了BaseObserver）<br>我们可以如下优化：</p>
<ol>
<li>将callback接口化<br>我们定义的onSuccess(T)和onFail（boolean isException ,Object object）两个抽象方法是完全面向业务使用者的。将其抽象为接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public interface ObserverCallback &lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;&#123;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求成功</div><div class="line">     * @param t</div><div class="line">     */</div><div class="line">    void onSuccess(T t);</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 请求失败</div><div class="line">     * @param isException true：返回Throwable false：返回String（ErrorMsg）</div><div class="line">     * @param object</div><div class="line">     */</div><div class="line">    void onFail(boolean isException ,Object object);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>化为接口的好处有可以与其他的网络请求调用方式（callback方式，非observable方式），回调接口上统一，降低切换成本。</p>
<ol>
<li>将loading逻辑和error响应逻辑分离：定义LoadingObserver，其实现ObserverCallback接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">public abstract class LoadingObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        implements Observer&lt;T&gt; ,ObserverCallback&lt;T&gt;&#123;</div><div class="line"></div><div class="line">    protected BaseContext mBaseContext;</div><div class="line"></div><div class="line">    public LoadingObserver(BaseContext baseContext)&#123;</div><div class="line">        mBaseContext = baseContext;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onSubscribe(Disposable d) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(true);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onNext(T t) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">        onSuccess(t);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onComplete() &#123;</div><div class="line">        if (isShowProgress()) &#123;</div><div class="line">            showProgress(false);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    protected void showProgress(boolean isShow)&#123;</div><div class="line">        if (mBaseContext != null) &#123;</div><div class="line">            mBaseContext.showLoading(isShow);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * 网络请求是否loading显示</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    protected boolean isShowProgress()&#123;</div><div class="line">        return true;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这样做的好处有<br>1、将更为通用的loading逻辑抽离，使其可以被独立使用或继承。<br>2、如果app存在不同业务线，可将error影响单独处理（不同业务线code定义可能不同），将loadingObserver类下沉，适配多业务线情况</p>
<ol>
<li>MapiObserver代码变成如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">public abstract class  MapiObserver&lt;T extends MapiHttpResponse&lt;? extends Serializable&gt;&gt;</div><div class="line">        extends LoadingObserver&lt;T&gt;&#123;</div><div class="line"></div><div class="line"></div><div class="line">    public MapiObserver(BaseContext baseContext)&#123;</div><div class="line">        super(baseContext);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onError(Throwable e) &#123;</div><div class="line">        super.onError(e);</div><div class="line"></div><div class="line">        handleError(e);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private void handleError(Throwable e)&#123;</div><div class="line">        //handle error code</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>至此，MapiObserver被分为了三层，MapiObserver这一层可以有多个更为具体的Observer来扩展。每一层都有自己的功能和扩展性。</p>
<h5 id="ObservableSource一端的解耦"><a href="#ObservableSource一端的解耦" class="headerlink" title="ObservableSource一端的解耦"></a>ObservableSource一端的解耦</h5><p>我们看下Observable一端做了哪些事情：</p>
<ol>
<li>对Request 参数做发送前处理：组合和加密处理</li>
<li>返回Response 解密处理，Java实体化</li>
<li><p>返回Response code码判断及分类<br>Observable端解耦的目的<br>1、耦合性降低后，方便后续的扩展和组合<br>2、将公共的，不易变化的逻辑下沉<br>这是Observable生成的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">private static Observable&lt;R&gt; sendRequest(final HttpRequest request，final TypeReference&lt;R&gt; t）</div><div class="line">  &#123;</div><div class="line">        return NetHelper.getApiObservable(request)</div><div class="line">              .map(new JavaBeanFunc(t))</div><div class="line">              .compose(ResponseTransformer.handleResult())</div><div class="line">              .subscribeOn(Schedulers.io())</div><div class="line">              .observeOn(AndroidSchedulers.mainThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Request请求params参数组合加密处理放到何处？<br>前面一章已经提到，params是通过HttpRequest类中的getURLParam()方法完成。<br>原因有2点 1、params定义在HttpRequest中，在Httprequest类中拿最方便。2、组合和加密的过程如果需要定制，那么直接在HttpRequest子类中就可以，和框架没有关系。</p>
</li>
<li>Response解密处理，Java实体化，在何处处理？<br>Response解密处理网上有两种处理方式，<br>1、在okhttp里使用interceptor拦截器解密 2、ResponseTransformer中处理。<br>这两种方式都有问题：<br>虽然app内部一般解密方式不变，但是要适应多业务线，或者作为适应性更广的框架来讲，这块解密逻辑放到框架中显然耦合性太高。<br>我们采用的方式是定义接口：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public interface ResponseDecryptHandler &#123;</div><div class="line">    String decrypt(String var1) throws IOException;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>HttpRequest类中定义实现接口，并将这种解密方式作为Convertor设置给Retrofit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addConverterFactory(SecurityConvertFactory.create(request.responseDecryptHandler()))</div></pre></td></tr></table></figure></p>
<p>对于JavaBean实体化，一般都采用fastJson方式，这里我们通过map操作符完成，作为链式调用中的一环出现，替换方便。</p>
<ol>
<li>前面提到，response的code分为了解析和处理两个部分，分别放在observable和observer中完成。其中ResponseTransformer是用于解析response的返回值。<br>ErrorResumeFunction和ResponseFunction分别是网络错误和业务错误，网络错误不会变，业务错误的判断是可能扩展的。ResponseFunction的实现是可以多样的。<br></li>
</ol>
<hr>
<p>以上可以看出Observable的生成过程中，除了一部分的逻辑放入的Request的接口中用于扩展，其他的功能在Observable的生成过程中以链式调用的方式存在，每个链式调用的功能由一个类承担。这也是rxjava的优势所在，在调用方式上天然地将各部分解耦了。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android框架/" rel="tag"># Android框架</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/11/LRecycler/" rel="next" title="下拉刷新分页加载控件">
                <i class="fa fa-chevron-left"></i> 下拉刷新分页加载控件
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/25/ReactiveX2/" rel="prev" title="基于RxJava Retrofit的网络框架（二）">
                基于RxJava Retrofit的网络框架（二） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">bo.wang</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#基于RxJava-Retrofit网络框架的搭建"><span class="nav-number">1.</span> <span class="nav-text">基于RxJava Retrofit网络框架的搭建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RxJava、Retrofit两个第三方库的优势"><span class="nav-number">1.1.</span> <span class="nav-text">RxJava、Retrofit两个第三方库的优势</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RxJava的使用场景"><span class="nav-number">1.1.1.</span> <span class="nav-text">RxJava的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Retrofit的使用"><span class="nav-number">1.1.2.</span> <span class="nav-text">Retrofit的使用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Observable网络框架的抽象"><span class="nav-number">1.2.</span> <span class="nav-text">Observable网络框架的抽象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable网络框架建立的原因"><span class="nav-number">1.2.1.</span> <span class="nav-text">Observable网络框架建立的原因</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable网络框架要解决的问题"><span class="nav-number">1.2.2.</span> <span class="nav-text">Observable网络框架要解决的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable网络框架如何实现"><span class="nav-number">1.2.3.</span> <span class="nav-text">Observable网络框架如何实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Observable网络框架的解耦和复用"><span class="nav-number">1.2.4.</span> <span class="nav-text">Observable网络框架的解耦和复用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BaseObserver的解耦"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">BaseObserver的解耦</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ObservableSource一端的解耦"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">ObservableSource一端的解耦</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">bo.wang</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  









<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="//unpkg.com/valine/dist/Valine.min.js"></script>



  





  

  

  

  
  

  

  

  

</body>
</html>
